title: Teaching Guide for Unit 7: Recursive and Higher-Order Functions

{

h3: Purpose
	raw-html:<div class="comment"><p><a href="/bjc-r/cur/teaching-guide/U7/u6-main.html?course=bjc4nyc_2015-2016_teacher.html&novideo&noassignment">Old Recursive and Higher-Order Functions TG</a></p><p><a href="http://localhost/bjc-r/topic/topic.html?topic=nyc_bjc/7-recursive-reporters.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">U7 Student Labs</a></p></div><p>Unit 7 is about recursive functions, combining the ideas of recursion, from Unit 6, and functional programming, introduced in Unit 3 with the higher order functions on lists. One highlight of the course is the implementation by students of three key list operations: <code>map</code>, <code>keep</code>, and <code>combine</code>.</p><p>After a brief introduction to the form of a recursive function (in which the recursive call is an input to a combining function, as opposed to a separate instruction as in recursive commands), we work through the example of sorting lists, showing selection sort and partition sort to introduce O(n log n) timing.</p><p> We dive right into <em>branched</em> recursive functions, in which each call gives rise to two or more recursive calls.  Linear-recursive functions (those with only one recursive call) are easier to write, but we avoid starting with them for two reasons:</p><p><ul><li>Most linear-recursive functions could instead be implemented as loops, leading students to as "Why are we using this confusing technique instead of a simple loop?"  Branched recursive functions do not lend themselves as easily to looping, so they're more compelling for students.</li><li>With linear-recursive functions, it's easy for students to develop the "go back" model of recursion, as if it <em>were</em> a simple loop.  That model is totally wrong for recursive functions (even linear-recursive ones), but once a student gets it into his or her head, it's hard to dislodge.</li></ul></p><p>Other examples in the unit include Pascal's triangle (we see how the naïve implementation takes exponential time, but techniques such as memoization can be used to create an efficient program that still maintains the essentially recursive definition), conversion of numbers to and from binary, which is then generalized to arbitrary bases (up to 36, using all the letters as digits); and finding the subsets of a set (a simple example of a computation that’s unavoidably exponential in time, because the desired output is exponentially large).<!-- (using mergesort to exemplify O(n log n) algorithms, because the algorithm is simpler than Quicksort and is guaranteed n log n rather than just probabalistically n log n) --></p><p>Finally, students build simple examples of recursive procedures that apply a function to every item of a list (square all the numbers, take the first letter of all the words, and so on), then <em>generalize that pattern</em> to write the <code>map</code> function, and similarly for <code>keep</code> and <code>combine</code>. This last programming lab is one highlight of the course, because it combines several central ideas: abstraction, functional programming, and recursion.</p>
	raw-html:<div class="todo">From <a href="http://localhost/bjc-r/cur/teaching-guide/U7/old/u6-main.html?course=bjc4nyc_2015-2016_teacher.html&novideo&noassignment">old version</a> just in case you want any of this. --MF<br /><br /><p>This unit extends the technique of recursion, introduced in Unit 5, to reporters, allowing us to write recursive <em>functions.</em></p><p>In a sense, there is nothing new here: Students learned about reporters in Unit 1, and about recursion in Unit 5.  But experience has shown that students have more trouble writing recursive functions than they do with recursive commands.  The fact that the recursive calls come inside a combiner function, as explained in <a href="/bjc-r/cur/programming/7-recursive-reporters/1-recursive-reporters/recursive-reporters-intro.html">Lab 1</a>, makes it even more important to develop the "leap of faith" understanding of recursion than in an imperative (command script) program.</p></div>
	
h3: Pacing
		raw-html:<p>The six weeks of Programming Labs (because Lab 3 includes several projects) and one week of Social Implications Labs for Unit 7 can be distributed in whatever way works best with your class. Consider: <ul><li>Working through the four programming labs in the first six weeks and then the social implications lab in the seventh week as presented below.  </li><li>Work through the four programming labs over all seven weeks of Unit 7 while concurrently working through the social implications lab (either on specific days of the week or as a part of each class across several days).</li><li>Consider doing Social Implications Lab 5 <i>before</i> Programming Lab 4, because the latter (in which students build the higher order list functions themselves) makes a thrilling climax to the course.</li></ul></p>
	
//h3: Big Ideas 
        //raw-html:<div class="todo">Needs attention</div><p></p>
        
//h3: Computational Thinking Practices
        //raw-html:<div class="todo">Needs attention</div><p></p>
	
heading: Programming Labs
	resource: Lab 1: Recursive Reporters [/bjc-r/cur/teaching-guide/U7/lab-pages/1-recursive-reporters.html]
	raw-html:<ul><li>2-3 days</li></ul>
	resource: Lab 2: Sorting [/bjc-r/cur/teaching-guide/U7/lab-pages/2-sorting.html]
	raw-html:<ul><li>3-5 days</li></ul>
	resource: Lab 3: Recursive Reporter Projects [/bjc-r/cur/teaching-guide/U7/lab-pages/3-recursive-reporter-projects.html]
	raw-html:<ul><li>10-14 days (if all projects done)</li></ul>
	resource: Lab 4: Some Simple Ones [/bjc-r/cur/teaching-guide/U7/lab-pages/4-higher-order-functions.html]
	raw-html:<ul><li>3 days</li></ul>
	
heading: Social Implications Labs
	resource: Lab 5: Robots and Artificial Intelligence [/bjc-r/cur/teaching-guide/U7/lab-pages/5-robots-and-ai.html]
	raw-html:<ul><li>1-5 days</li></ul>
	
//heading: Assessment: TBD
        //raw-html:<div class="todo">Needs attention</div><p></p>
}
