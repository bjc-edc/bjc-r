<!DOCTYPE html>
<html lang="en">
    <head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 3: Parallelism, Page 1</title>
    </head>

	
    <body>
		<h2>Parallelism</h2>
        <div class="todo">
            CSN-2: Parallel and distributed computing leverages multiple computers to more quickly solve complex problems or process large data sets.
            <ul>
                <li>
                    CSN-2.A: Compare problem solutions that use sequential, parallel, and distributed computing.
                    <ul>
                        <li>CSN-2.A.1: Sequential computing is a computational model in which operations are performed in order one at a time.</li>
                        <li>CSN-2.A.2: Parallel computing is a computational model where the program is broken into multiple smaller sequential computing operations some of which are performed simultaneously.</li>
                        <li>CSN-2.A.3: Distributed computing is a computational model in which multiple devices are used to run a program.</li>
                    </ul>
                </li>
                <li>
                    CSN-2.B: Determine the efficiency of sequential and parallel solutions.
                    <ul>
                        <li>CSN-2.B.1: Comparing efficiency of solutions can be done by comparing the time it takes them to perform the same task</li>
                        <li>CSN-2.B.2: A sequential solution takes as long as the sum of all of its steps.</li>
                        <li>CSN-2.B.3: A parallel computing solution takes as long as its sequential tasks plus the longest of the tasks done in parallel.</li>
                        <li>CSN-2.B.4: The “speedup” of a parallel solution is measured in the time it took to complete the task sequentially divided by the time it took to complete the task when done in parallel.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div class="learn">
            <!--<p><strong>In this lab,</strong> you will learn .</p>-->
            <p><strong>On this page,</strong> you will learn how running multiple scripts in parallel can reduce the total time it takes to run an algorithm.</p>
        </div>
        <p>In Snap<em>!</em>, you are accustomed to seeing a bunch of scripts that all run independently, which may or may not be associated with different sprites. This is kind of like <em>parallel computing</em>. So, if we had a different computer for each sprite, that would be true parallelism. As it is, there is only one computer, and it divides its attention among the processes by running a little bit of one and then running a little bit of the next one. Specifically, it switches at the bottom of loops (<code>forever</code>, <code>repeat</code>, etc.).</p>
        
        <!--<p>Snap<em>!</em>  supports parallelism. The programming environment is full of concurrency, implicit (two scripts both start when the green flag is clicked, or when they receive the same broadcast message), and explicit (the launch block). Let's first explore the explicit kind, then we will play with the implicit kind a bit. </p>
        <p>Let's try to use concurrency for what it was meant for: <b>speed!</b> </p>
        <p>There are three important models of the machine you should develop:
            <ol>
                <li>Snap<em>!</em> is like a parent with lots of kids, the parent wants to give the kids equal attention. So if there are 3 things happening at one time, Snap<em>!</em>  will rotate among the three of them, giving each of them a chance to do their "thing" (e.g., complete one iteration of a loop). It will choose the same order every time, in a very predictable way. This is known as time-sharing. </li>
                <li>Snap<em>!</em> has a speed governor so that projects can run at the same speed on different machines. It is obvious why that is important&#8212;imagine developing this great Pac Man game on your parent's slow computer and working very hard to get the timing just right so it is not too fast or slow. However, when you share it with others who have faster machines, it runs too fast to play (because the other computers have a faster "heartbeat", the clock rate). So Snap<em>!</em>  slows itself down on faster computers so that it always looks like it is running on the same, slow, computer. The reason this is relevant in the discussion of concurrency is that (on the vast majority of computers) Snap<em>!</em> = spends a lot of time just sitting there, waiting, so it has lots of idle "cycles" to handle multiple things running at the same time. </li>
                <li>Snap<em>!</em>  actually does NOT make use of more than one core (independent hardware computation unit), it runs everything in one core and time shares any parallel task on the single core. This gives Snap<em>!</em>  much more control over its parallelism, since once you decide to use two (or more) physical cores, you can no longer control when (or in what order) the computations will return, and you open up the standard Pandora's box of concurrency problems, like deadlock and race conditions. So your Snap<em>!</em> programs are insulated from these realities, allowing you to have predictable parallelism (usually impossible) at the cost of being able to run really fast and make use of hardware resources. </li>
            </ol>
        </p>-->
        <div class="vocabFullWidth">: <strong>Sequential</strong> and <strong>Parallel Computing</strong>
            <div class="comment">CSN-2.A.1, CSN-2.A.2, CSN-2.A.3</div>
            <p>
                This section covers two computational models:
                <ul>
                    <li>In <strong>sequential computing</strong>, operations are performed in order one at a time.</li>
                    <li>In <strong>parallel computing</strong>, the program is broken into smaller steps, some of which are performed at the same time.</li>
                </ul>
            </p>
        </div>
        
        <div class="comment">CSN-2.B.1</div>
        <p>You can compare the efficiency of two different algorithmic solutions to a problem by comparing the time it takes them to perform the same task.</p>
        
        <div class="forYouToDo" id="first">
			<ol>
                <li>
                    <!-- Question 1 -->
                    <div class="assessment-data" type="multiplechoice" identifier="How long will this sequential script take to run?"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="true">
                        <div class="prompt">
                            <div class="comment">CSN-2.B, CSN-2.B.2</div>
                            How long will this sequential program take to run?<br />
                            <img class="indent" src="/bjc-r/img/5-algorithms/quizlet-sequential.png" alt="wait (6), wait (4), wait (8)" title="wait (6), wait (4), wait (8)" />
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">18</div>
                            <div class="feedback">Correct!</div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">8</div>
                            <div class="feedback">A sequential solution takes as long as the sum of the run times of all of its steps.</div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">4</div>
                            <div class="feedback">A sequential solution takes as long as the sum of the run times of all of its steps.</div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">6</div>
                            <div class="feedback">A sequential solution takes as long as the sum of the run times of all of its steps.</div>
                        </div>
                        <div class="responseDeclaration" identifier="ri1">
                            <div class="correctResponse" identifier="c1"></div>
                        </div>
                    </div>
                </li>
            </ol>
        </div>
    
        <div class="comment">CSN-2.B.2</div>
        <p>The run time of a sequential algorithm is the sum of the run times of all its steps.</p>
    
        <div class="forYouToDo">
			<ol start="2">
				<li>
                    <!-- Question 2 -->
                    <div class="assessment-data" type="multiplechoice" identifier="How long will this parallel script take to run?"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri2" shuffle="true">
                        <div class="prompt">
                            <div class="comment">CSN-2.B, CSN-2.B.3</div>
                            How long will this parallel program take to run?<br />
                            <img class="indent" src="/bjc-r/img/5-algorithms/quizlet-parallel-1.png" alt="broadcast (go) and wait, wait (6) secs" title="broadcast (go) and wait, wait (6) secs" />
                            <img class="indent" src="/bjc-r/img/5-algorithms/quizlet-parallel-2.png" alt="when I receive (go): wait (4) secs" title="when I receive (go): wait (4) secs" />
                            <img class="indent" src="/bjc-r/img/5-algorithms/quizlet-parallel-3.png" alt="when I receive (go): wait (8) secs" title="when I receive (go): wait (8) secs" />
                            
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">18</div>
                            <div class="feedback">
                                The two <code>when I receive</code> tasks happen in parallel, not one after the other.
                            </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">8</div>
                            <div class="feedback">
                                The longest parallel time does matter, but it's not the only thing that contributes to the total time.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">6</div>
                            <div class="feedback">
                                <code>Broadcast and wait</code> waits until all the tasks that it started have finished.
                            </div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">14</div>
                            <div class="feedback">
                                Correct!
                            </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri2">
                            <div class="correctResponse" identifier="c4"></div>
                        </div>
                    </div>
                </li>
			</ol>
		</div>
    
        <p>Writing a program that does nothing but wait is, of course, unrealistic, but what is realistic is that in most problems, there isn't a solution that's purely parallel. Some part of the computation has to be done sequentially. In the previous question, the sequential part is modeled by <code>wait 6 secs</code>.</p>
        <p>As a more realistic example, suppose you want to know the average word length in list of 100,000 words. You can divide the task among several computers (one for each starting letter). Each computer adds the lengths of all the words assigned to it (all the "A" words, all the "B" words, etc). Then one computer has to add the 26 partial results and divide by the total number of words to find the average.</p>
        <div class="comment">CSN-2.B.3</div>
        <p>To calculate the run time of this parallel solution, you would add the run time of the longest parallel portion (the run time for the letter with the most words) to the run time of the sequential portion (adding the 26 partial results and dividing the sum by the total number of words).
            <div class="todo">We stopped here.</div>
    
        
        <div class="forYouToDo">
			<ol start="3">
				<li>
				    <div class="todo">Give them a more realistic example to compute</div></li>
			</ol>
		</div>
		
        <div class="vocabFullWidth">
            <div class="comment">CSN-2.B.4</div>
            <p>
                Programmers refer to the <strong>speedup</strong> of parallel solution to describe how many times as fast the parallel solution is compared to the sequential solution:<br />
                <span class="katex indent">\text{speedup} = \frac{\text{sequential time}}{\text{parallel time}}</span>
            </p>
        </div>
        
        <div class="ifTime">
			<ol start="4">
				<li>
                    <!-- Question 3 -->
                    <div class="assessment-data" type="multiplechoice" identifier="How long will this parallel script take to run?"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri3" shuffle="true">
                        <div class="prompt">
                            What is the <em>speedup</em> for the parallel solution shown above when compared to the sequential solution?
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">2</div>
                            <div class="feedback">
                                Think about the value of x after the first step.
                            </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri3">
                            <div class="correctResponse" identifier="c2"></div>
                        </div>
                    </div>
                </li>
			</ol>
		</div>
        
        <h3>Distributed Computing</h3>
        <div class="todo">
        <ul>
            <li>
                CSN-2.C: Describe benefits and challenges of parallel and distributed computing.
                    <ul>
                        <li>CSN-2.C.1: Parallel computing consists of a parallel portion and a sequential portion.</li>
                        <li>CSN-2.C.2: Solutions that use parallel computing can scale more effectively than solutions that use sequential computing.</li>
                        <li>CSN-2.C.3: Distributed computing allows problems to be solved that could not be solved on a single computer, either because of the processing time or storage needs involved.</li>
                        <li>CSN-2.C.4: Distributed computing allows much larger problems to be solved quicker than they could be solved using a single computer.</li>
                        <li>CSN-2.C.5: When increasing the use of parallel computing in a solution, the efficiency of the solution is still limited by the sequential portion. This means at some point, adding parallel portions will no longer increase efficiency.</li>
                    </ul>
                </li>
            </ul>
        </div>
    
        <div class="vocabFullWidth">
            <div class="comment">CSN-2.A.3</div>
            <p>In <strong>distributed computing</strong>, <em>multiple devices</em> are used to run a program.</p>
        </div>
		

    
        
        
    </body>
</html>