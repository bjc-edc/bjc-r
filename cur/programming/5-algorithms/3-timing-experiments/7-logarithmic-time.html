<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 3: Timing Experiments, Page 7</title>
	</head>

	<body>
    	<h2>Timing Binary Searches</h2>
		
<div class="todo">BK: Removing this page from the lab for this cycle. The difference between linear and binary search is in Lab 1, and there is nothing in this page needed to meet the standards. Could consider re-including in Unit 6/7.</div>
        
   In an earlier <a href="/bjc-r/cur/programming/5-algorithms/1-searching-lists/2-improving-search.html#bsearch">lab</a>,   made a table that  tracks the number of guesses it takes to find the last number in a list as a function of the length of the list.  The finished table looks like this:
   
  <table id="tableBlue" class="center">
                        <tr>
                            <td>Length</td>
                            <td># Of Guesses</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>2</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>15</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>63</td>
                            <td>5</td>
                        </tr>
                        <tr>
                            <td>127</td>
                            <td>6</td>
                        </tr>
                    </table> 
 
<div class="dialogue">
    <div><span>Betsy:</span> This looks too good to be true.</div>
    <div><span>Alphie:</span> I wonder why they gave us odd numbers for the inputs.</div>
    <div><span>Betsy:</span> Probably because a list with an odd number of elements has a "middle" entry, so the list is easier to split into two equa sizel lists</div>
    <div><span>alphie:</span> </div>
    <div class="stagedir"></div>
    <div><span>1:</span> </div>
    <div><span>2:</span> </div>
</div> 
 
 
 
 
 
 
 
 
 
  
        
        
        <p>We will end this lab by introducing another kind of running time that appears frequently when analyzing algorithms. <a href="/bjc-r/cur/programming/old-labs/algorithms/algorithms-in-snap.html" target="_blank">Two labs ago</a>, we looked at a few ways of finding a number in a list.  <a href="/bjc-r/cur/programming/old-labs/algorithms/timing/quiz-searching-through-time.html" target="_blank">Earlier in this lab</a>, we decided that an algorithm that merely walks through a list to find the number is a linear-time algorithm. (This algorithm, by the way, is fancily known as a <em>linear search</em>.  Now you know why.)  However, the eternal question: Can we do better?</p>
        <p>We also saw an algorithm that worked on sorted lists: we kept dividing the list of numbers into smaller and smaller halves, always looking at the middlemost element to narrow in on the number we are looking for. What is the running time of this algorithm? Well, the runtime is definitely not constant-time, because the longer the list, the more elements we have to look through. However, the runtime is definitely not linear-time either, because we don't ever end up looking at all of the elements of the list. The runtime of this algorithm must lie somewhere in between.</p>
        <p>Let's count the number of splits that we have to do for a sorted list of a given size. For a list of size 4, we only ever have to do at most two splits before we find the number we are looking for, or conclude that the number is not in the list. For a list of size 8, after the first split, we are now concerned only with a list of size 4. But, as we have just seen, we only have to do at most two splits before we are done. Again, for a list of size 16, after the first split, we are now concerned only with a list of size 8, which can take three more splits. To summarize:</p>
        <div class="comment">MF: Table needs help. </div>
        <table id="t5m:" style="font-size: 1em; line-height: inherit; border-collapse: collapse;" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody><tr style="text-align: left;"><td width="20%">Size of list</td><td width="20%"><code>4</code></td><td width="20%"><code>8</code></td><td width="20%"><code>16</code></td><td width="20%"><code>32</code></td></tr><tr style="text-align: left;"><td width="20%">Number of splits</td><td width="20%"><code>2</code></td><td width="20%"><code>3</code></td><td width="20%"><code>4</code></td><td width="20%"><code>5</code></td></tr></tbody></table>
        <p>Notice that when the size of the input doubles, the number of splits (and thus the runtime of the algorithm) increases by one. Also, notice that the top row is growing much faster than the bottom row. This behavior is similar to that of the logarithmic function that you may have seen before, where every multiplicative increase in the input is converted to an additive increase in the output. Such a growth is thus called a <em>logarithmic</em> growth, and this algorithm is a <em>logarithmic-time</em> algorithm. (In contrast to the linear search algorithm, this algorithm is known as a <em>binary search</em>.)</p>
        <p>Logarithmic-time algorithms are also sought-after, since their runtimes are close to, although not quite, constant-time. You can increase the sizes of their inputs by a large factor, yet their running time will increase by a small, <em>added</em> amount, which makes them valuable. In general, any algorithm that involves dividing something into smaller pieces can be a logarithmic-time algorithm.</p>   


	</body>
</html>