<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 3: Timing Experiments, Page 5</title>
	</head>

	<body>
    	
        <h2>Analyzing the Behaviors</h2>
         <div class="dialogue">
        <div class="stagedir">
                Alphie and Betsy are talking about their work so far. 
            </div>
        
       
            <div><span>Alphie: </span> I don't see how you can say that a reporter takes a certain amount of time when different computers run at different speeds.  So, what takes 92 millesconds on one machine may take half of that on another. </div>
            	
            <div><span>Betsy: </span> Well, look at the graphs we made on the page before this.  You can't read see how <em>long</em> the reporter takes to output, you just see how the run time of the reporter scales as we look at larger and larger inputs.  <em>That's</em> a property of the reporter that will hold on any computer. </div>
            
            
            <div><span>Alphie: </span> Good.  But graphs are tricky.  By changing the scales of the axes, you can make a curve look like a line or <em>vice-versa</em>. Looking at our graphs gives us an idea of what's happening with the rum time, but I think we need a more reliable method.</div>
            
			
      </div>

<div class="takeNote">  The "more reliable method" that Alphie wants comes from the mathematics behind the graphs you generated.  Many of those graphs can be approximated with the graph of an equation of the form <span class="katex">y = f(x) </span>  where <span class="katex"> f  </span>is a function that you've seen in algebra class, like <span class="katex">y = x^2 </span> or <span class="katex">y = 3x </span>.    
</div>
        
<div class="forYouToDo">
<div class="sidenote">``Sketch'' means by hand or computer.  You've got some nice graphing programs, so <span class="katex">\dots.</span>    </div> 
Sketch the graphs of
    <ol>
        <li> <span class="katex">y = x^2 </span></li>
        <li>   <span class="katex">y = 3x </span></li>
        <li><span class="katex">y = 3</span></li>
        <li><span class="katex">y = \frac{x(x+1)}2</span>
    </ol>
</div> 


     
        
          
        
        <h3>Constant Time</h3>
		
 
 
        
       
<p>One of the simplest reporters reporters has to be "add 1''. </p>
         
        <div class="forYouToDo" id="first">
            <ol>
<div class="sidenote">Pick some small inputs and some very big ones.</div>  
                <li> Experiment with the <code>average time</code> of adding 1 to whole numbers of various sizes, and make a data-plot of the average times.  For example, you could try something like this:</li>
 
 
 <p><img class="inline" src="/bjc-r/img/5-algorithms/constant.png" alt="list of constant times" title="list of constant times" /> </p>
               
 <p> <img class="inline" src="/bjc-r/img/5-algorithms/graphdat.png" alt="data-plot of constant time" title="data-plot of constant time" />  </p>             
               
   <li> <img class="inline" src="/bjc-r/img/icons/talk-with-your-partner.png" alt="Talk with Your Partner" title="Talk with Your Partner" />  Describe the behavior of the run-time.            
               
               
                
            </ol>
        </div>
 <div class="takeNote"> <p>You probably noticed that the computer takes approximately the same time to add 1  a number, no matter how large the number is. This is why computer scientists call incrementing a number a <em>constant-time</em> operation. It turns out, that <em>any</em> basic arithmetic operation (addition, subtraction, multiplication, division, and exponentiation) is  a constant-time operation.</p>
        
        <p>Why did the computer take approximately the same amount of time to increment a number, even though that number was getting larger? Think about how you would add one to a number back in your elementary school days; this is similar to how a computer does its arithmetic (ignoring technical details). The elementary school way of adding numbers goes digit by digit, and so the amount of time it takes for you to add two numbers depends on how many digits each number has. As we doubled the number we were incrementing, we didn't consistently add digits to it, and so the computer took approximately the same time. Even as we began scaling the number by ten, the computer (and you!) takes a relatively small amount of time to account for the extra digit, so the total time remains approximately constant.</p>
        <p>Constant-time operations are the Holy Grail of computer science algorithms, and unfortunately, most algorithms are <em>not</em> constant-time...</p> 
    
</div>       
        
        
        
        
        
        
  
        
        <div class="takeItFurther">
    		<img class="imageRight" src="/bjc-r/img/icons/tough-stuff-mini.png" alt="Tough Stuff" title="Tough Stuff" />
            <ol type="A">
        		<li>
            		Take another huge leap and find out approximately how long it takes for the computer to increment numbers that you progressively scale by 10: 
                    <ul>
                        <li>160,000,000</li>
                        <li>1,600,000,000</li>
                        <li>16,000,000,000</li>
                    </ul>
                    What do you observe? How is this similar to or different from scaling by 2?
                </li>
            </ol>
        </div>
        
        <div class="todo">MF: The section below is too long. Let's  trim it down considerably, especially the third paragraph.</div>
         


	</body>
</html>