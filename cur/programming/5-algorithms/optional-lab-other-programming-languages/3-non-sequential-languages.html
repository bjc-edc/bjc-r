<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Optional Lab: Other Programming Languages, Page 3</title>
	</head>

	<body>
		<h2>Non-Sequential Languages</h2>
		<!--<div class="learn"></div>-->

		<p>In the early days, all programming languages were sequential, because that's how computer hardware works, and higher level languages were seen as a convenient abbreviation for machine language, rather than as a source of abstraction.  Since then, several types of programming language based abstraction ("programming paradigms") have been invented. Most modern languages have some aspects of most of these, but in this section you'll learn about languages that are
		<em>entirely</em> based on one particular paradigm. It's worthwhile to learn such a language because it will immerse you in how things are done in that paradigm, even if in real life you end up programming in a mixed-paradigm language such as Snap<em>!</em>, Python, or JavaScript.</p>

		<h3>Functional Programming in Haskell</h3>

		<p>Imagine if Snap<em>!</em> had only reporters and predicates, with no command blocks.  To perform a computation, you'd build up an expression in the scripting area, then click on it to see the result in a speech balloon.  You could make script variables, but you'd give them a value at the time you create them, and you couldn't then <em>change</em> the value.  That would be a <em>functional programming</em> language.</p>

		<p>Here's the same binary search algorithm shown above, written in Haskell, a purely functional language:</p>

<pre class="indent">find :: Ord a => Array Int a -> a -> Maybe Int
find arr x = uncurry (search arr x) (bounds arr)

search :: Ord a => Array Int a -> a -> Int -> Int -> Maybe Int
search arr x lo hi
  | hi - lo + 1 == 0 = Nothing
  | x == el = Just mid
  | x > el = search arr x (mid+1) hi    -- eliminate half the list
  | otherwise = search arr x lo (mid-1)
  where mid = (hi + lo) `div` 2         -- find the middle word
        el = arr ! mid</pre>
<p><small>Source: <a href="https://exercism.io/tracks/haskell/exercises/binary-search/solutions/1a379e35bf0741109dae902f8ae1096c">exercism.io</a>, CC-BY-SA</small></p>

		<p>This looks very different from the other programs you've seen,
		but don't throw up your hands in despair.  You're <em>not</em>
		expected to be able to learn to program in Haskell in just a few
		days, but you can read this example with some help.
		Start with the fourth line, <code>search arr x lo hi</code>;
		it's like the hat block that begins a Snap<em>!</em> procedure,
		in this case a <code>search</code> procedure with four inputs.</p>

		<p>In <code>search</code> you'll see functional programming
		making a difference in the programming style.  The Snap<em>!</em>
		version of the program is organized as a <code>repeat until</code>
		loop, in which the values of the variables <var>low</var>,
		<var>high</var>, <var>current index</var>, and
		<var>current item</var> are changed on every repetition.  If you're
		not allowed to change variables' values, what can you do instead?</p>

		<p>
			The answer is that <code>search</code> calls itself recursively,
		in the lines
			<pre class="indent">  | x > el = search arr x (mid+1) hi
  | otherwise = search arr x lo (mid-1)</pre>
			In the recursive calls, either <var>lo</var> or <var>hi</var> has a different value.  This may seem like a quibble.  Isn't that the same as changing the value?  No, it isn't.  The recursive call has <em>its own local variables</em> with the same names as the outer call.  You can see that this matters in a case in which two recursive calls are combined, as in this program to calculate Fibonacci numbers:<br />
			<div class="commentBig">Why does this have text-language-style names for the function and variable? Please remake with snap-style naming, update all the text references, and add alt/title text to the image. --MF, 12/20/21</div>
			<img class="indent" src="/bjc-r/img/5-algorithms/fib.png">
		</p>
		<p>If you try to trace through computing <code>fib 4</code> on the
		assumption that there's a single variable <var>n</var> shared by
		all the recursive calls, you'll get the wrong answer.</p>

		<p>The <code>where</code> in the last two lines of the program
		is how Haskell creates script variables and gives them their
		(unchanging) values.</p>

		<p>The four lines that start with vertical
		bars (<code>|</code>) are like a set of nested
		<code>if</code>/<code>else</code> blocks:  If <var>hi</var> is
		one less than <var>lo</var>, return nothing.  If the value you're
		looking for is equal to <code>item <var>mid</var> of
		<var>arr</var></code>, return the index <var>mid</var>.  (This
		version of binary search returns the position of the value in
		the list, if any, instead of just <code>True</code>.)  If the
		value you want is more than the value at the midpoint, search
		from the midpoint to the end of the list.  Otherwise, search
		from the beginning of the list to the midpoint.</p>

		<div class="endnote">
			<a href="#hint-haskell" data-toggle="collapse" title="Click for more details on functional programming."><img class="inline" src="/bjc-r/img/icons/read-more-mini.png" alt="Read More" title="Read More" />Could you tell me more about functional programming?</a>
			<div id="hint-haskell" class="collapse">
				<p>The two lines with <code>Ord a</code> and so on are <em>type
				declarations.</em> Such declarations aren't a necessary part of a
				functional language, but the main functional languages do use them.
				The "a" on those lines is the name of a data type that's being created
				in each declaration.  <code>Find</code> and <code>search</code> are of
				type "function," but not any old function.  <code>Find</code> is of
				type "function that takes as inputs an array (like a Snap<em>!</em>
				list) of values of type
				<code>a</code>, which has to be an Ordered type (because binary
				search doesn't make sense otherwise), and a single value
				of type <code>a</code>, and returns either an integer or nothing at
				all."  Looking at this another way, each of those lines creates an
				abstract data type.  (The name <code>a</code> is local to
				each function.)</p>

				<p>&nbsp;</p>

				<p><code>Find</code> is the main procedure; <code>search</code>
				is a helper function.  Note that <code>find</code> takes two
				inputs, <var>arr</var> for the array and <var>x</var> for
				the value to be found.  <code>Search</code>, though, takes
				<em>four</em> inputs: <var>arr</var>, <var>x</var>,
				<var>lo</var> for the lowest array index to examine, and
				<var>hi</var> for the highest index.  So how can
				<code>find</code> say <code>(search arr x)</code>, calling
				<code>search</code> with only two inputs?</p>

				<p>This is part of what it means to take function-as-data
				seriously.  When you call any Haskell function with fewer
				inputs than it expects, it returns <em>a function</em> of
				the remaining inputs, sort of as if when you defined<br />
				<img src="/bjc-r/img/5-algorithms/search4.png"
				alt="search reporter block with four inputs: arr, x, lo, hi"
				title="search reporter block with four inputs: arr, x, lo, hi"
				/><br />
				you automatically also got this one:<br />
				<img src="/bjc-r/img/5-algorithms/search2.png"
				alt="search reporter block with two inputs: arr, x;
				reporting an anonymous function (gray ring) that takes
				two inputs named lo and hi, and calls the four-input search
				with arr, x, lo, and hi"
				title="search reporter block with two inputs: arr, x;
				reporting an anonymous function (gray ring) that takes
				two inputs named lo and hi, and calls the four-input search
				with arr, x, lo, and hi" /><br />
				and similarly for one-input and three-input versions.
				Turning a function into a function with fewer inputs is
				called <em>currying</em> it, named after Haskell Curry, a
				mathematician who contributed to the early development
				of lambda calculus, the mathematical basis for functional
				programming.  So the call to <code>uncurry</code> turns
				the two-input function back into a four-input function by
				supplying the missing two inputs, namely
				<code>(bounds arr)</code>, a function call that
				reports the lowest and
				highest indices of the array, which will be 0 and
				the array length minus 1.</p>
			</div>
		</div>

		<p>Even if you're convinced that functional programming is a
		good idea (which it is, because it avoids the kind of bug in
		which two parts of the program are using the same variable for
		different purposes, and because functional code turns out to
		be the easiest to parallelize for multi-processor machines),
		why would you choose a language that <em>forces</em> you to
		program in that style?  Well, many people don't.  You can, if
		you're disciplined about it, program functionally in any
		language that's functional <em>enough</em> to include higher
		order functions, which are an important benefit of functional
		programming.  (You did something like this in the Tic-Tac-Toe
		project, not in the part that displays moves on the stage, but
		in the part that computes the best move for the computer.
		That computation is one function calling another:  <img
		src="/bjc-r/img/5-algorithms/next-move.png" alt="next move for
		computer" title="next move for computer" /> calls <img
		src="/bjc-r/img/5-algorithms/winning-square-for-player.png"
		alt="winning square for player" title="winning square for
		player" />, which calls <img
		src="/bjc-r/img/5-algorithms/winning-triple-for-player.png"
		alt="winning triple for player" title="winning triple for
		player" />, which calls <img
		src="/bjc-r/img/5-algorithms/status-of-all-winning-triples.png"
		alt="status of all winning triples" title="status of all
		winning triples" />, which calls <img
		src="/bjc-r/img/3-lists/status-of-triple.png" alt="status of
		triple" title="status of triple" />.)  But a purely functional
		language helps eliminate program bugs, which is especially
		important when a team of programmers work together on the same
		program.  And compilers for functional languages can take
		advantage of the constraints of functional programming to
		generate very efficient programs.  In any case,
		<em>learning</em> a purely functional language ensures that
		you discover every aspect of functional programming.
		<!-- For
		example, you saw just now that we <em>can</em> curry a function
		in Snap<em>!</em>, but you've never done it in this course,
		because it doesn't happen automatically, so the hassle of
		setting it up does away with the ease and power of the technique.
		[Can't say this because currying is in the hinted yellow box.] -->
		</p>

		<h3>Object Oriented Programming (OOP) in Smalltalk</h4>

		<p>Imagine if in Snap<em>!</em> you could make only sprite-local
		procedures and variables, not global ones.  Imagine also that
		<em>everything</em> in the language were like sprites in that
		way.  So, for example, imagine that the number <code>3</code> had its own
		procedures&mdash;its own <code>+</code> and so on.  Something
		that has its own local procedures (called <em>methods</em>)
		and its own local variables (often called <em>fields</em>,
		depending on the language) is called an <em>object.</em></p>

		<p>It would be unusable if you actually had to write a <code>+</code>
		method for <code>3</code> and a different one for <code>4</code>.
		But think about making clones of a sprite, as you did in the
		Tic-Tac-Toe project.  Each clone <em>inherits</em> the methods
		and some other attributes from its parent sprite.  Similarly,
		<code>3</code> and <code>4</code> are <em>instances</em> of
		the class (type of object) <code>Integer</code>, which in turn
		inherits from the class <code>Number</code>.  You can think of
		an object class as a souped-up abstract data type with methods
		other than just its selectors.</p>

		<p>So, what happens when you say <code>3 + 4</code>?  You are
		sending the <em>message</em> <code>+ 4</code> to the object
		<code>3</code>.  (In Snap<em>!</em>, the <code>broadcast</code>
		block sends a message to all objects, and the <code>tell</code>
		and <code>ask</code> blocks send a message to a specific object.)
		The message <code>+ 4</code> consists of a <em>keyword,</em>
		<code>+</code>, along with an input, <code>4</code>.</p>

		<p>These days, most programming languages are <em>sort of</em>
		object oriented, just as most <em>sort of</em> support functional
		programming.  For example, in the translation table above,
		the translation of the <code>map</code> block to JavaScript
		is <code>value.map(someFunction)</code>.  <code>Map</code>
		takes two inputs, a function and a list.  Python expresses
		that idea as a two-input function, <code>map(some_function,value)</code>.
		Why does JavaScript put one of the inputs in front of the
		function name?  The reason is that JavaScript's <code>map</code> isn't a
		global procedure; it's the keyword of a message that
		you can send to a list.  Their message-passing syntax is
		<code>object.keyword(inputs)</code>.</p>

		<p>But most languages don't go so far as to treat numbers
		as objects.  In most languages, including Snap<em>!</em>,
		<code>+</code> is a global function that takes two numbers as
		inputs.  The only widely known language that's truly
		object oriented, in which <em>everything</em> is an object,
		is Smalltalk, the language that introduced object oriented
		programming to the world.</p>

		<p>Here's the binary search program in Smalltalk:</p>

<pre>SequenceableCollection >> binaryFindIndexOf: aNumber left: leftIndex right: rightIndex
      | middle |
      leftIndex = rightIndex ifTrue: [ ^ 0 ].
      middle := (rightIndex + leftIndex) // 2.  "find the middle word"
      ^ (self at: middle) = aNumber
            ifTrue: [ middle ]
            ifFalse: [
                (self at: middle) > aNumber     "eliminate half the list"
                    ifTrue: [ self binaryFindIndex: aNumber left: leftIndex right: middle - 1 ]
                    ifFalse: [ self binaryFindIndex: aNumber left: middle + 1 right: rightIndex ]
            ]</pre>
<p><small>Source: <a href="https://stackoverflow.com/questions/67847078/binary-search-in-smalltalk">stackoverflow.com</a>, CC BY-SA</small>, and Bernat Romagosa</p>

		<p>The first line of this program says that it is adding a new
		method to the class <code>SequenceableCollection</code>, which
		is a parent class of arrays, lists, and other kinds of
		sequences of items.  The corresponding message has three
		keywords, <code>binaryFindIndexOf:</code>, <code>left:</code>, and
		<code>right:</code>. This is similar to the way Snap<em>!</em>
		blocks can have title text mixed with input slots.  The inputs
		to this method are named <var>aNumber</var> (a Smalltalk convention
		that helps make the code self-documenting because we know what
		kind of object it expects), <var>leftIndex</var>, and
		<var>rightIndex</var>.  (Shouldn't there be an input for the
		collection in
		which the method will search?  No, because that collection is an
		object, and <code>binaryFindIndexOf</code> is a method of the
		collection.)</p>

		<p>The vertical bars in the second line are the Smalltalk syntax
		for <code>script variables</code>.  Another noteworthy piece of
		syntax is that Smalltalk uses square brackets <code>[ ]</code>
		the way Snap<em>!</em> uses gray rings, surrounding a piece of
		code that can be input to a message.  Smalltalk sensibly uses
		<code>=</code> to mean the equality test; its equivalent to
		<code>set</code> is the two-character sequence <code>:=</code>.
		(Smalltalk was developed long before Unicode; if they were
		designing it today they'd probably use <code>←</code>.
		The hat (<code>^</code>) is like <code>report</code>.
		The double slash <code>//</code> is division with the result
		rounded to an integer.</p>

		<p>The Boolean values True and False are, of course, objects;
		they accept messages with keywords <code>ifTrue:</code> and
		<code>ifFalse:</code>, each of which takes a code block (in
		square brackets, in this program) as input.  So there's no
		need for an explicit <code>if</code> procedure.</p>

		<p>The name <code>self</code> refers to the object that is carrying
		out the method, like <img src="/bjc-r/img/5-algorithms/my-self.png">
		or <img src="/bjc-r/img/5-algorithms/obj-myself.png"> in
		Snap<em>!</em>.  The message <code>at: <var>middle</var></code>, sent to a
		collection, means the same as <code>item <var>middle</var> of
		<var>collection</var></code> in Snap<em>!</em>.  The rest of the program should
		now make sense.</p>

		<div class="endnote">
			<a href="#hint-generic" data-toggle="collapse" title="Click for more details on message passing."><img class="inline" src="/bjc-r/img/icons/read-more-mini.png" alt="Read More" title="Read More" />Could you tell me more about
			object oriented programming?</a>
			<div id="hint-generic" class="collapse">
				<p>Object oriented programming with message passing
				does a great job with functions of
				one input, such as asking a list for its length.  It's a little more
				awkward for a function like <code>+</code>, whose two inputs really
				play mathematically similar roles.
				Saying that <code>3</code> is the actor and
				<code>4</code> is just an input feels peculiar.  Some languages try
				to overcome this issue by using <em>generic functions</em> instead
				of message passing.  That means that you could define functions
				<code>sum(integer,integer)</code>, <code>sum(integer,float)</code>,
				and so on, so that all the inputs help determine which method is
				used.  When you call a function, the language looks for the best
				fit between the methods you've defined and the classes (types) of
				the inputs.</p>

				<p>Think about Python's <code>" ".join(["hello","world"])</code>
				notation.  This is the same <code>object.method(inputs)</code>
				syntax that JavaScript uses, and it works well.  But it seems a
				little strange that what you're supposed to think of as the active
				object is the delimiter character, rather than the meaningful
				strings you're combining.  Compare that with JavaScript's
				<code>"hello".concat("&nbsp;","world")</code>, which makes the first
				string the actor and other strings, including delimiters, the
				inputs.  That seems more Smalltalk-like.</p>

				<p>&nbsp;</p>

				<p>Smalltalk is a <em>class/instance</em> language.  That means
				that there's a special kind of object called a <em>class</em>
				that contains all the methods for any object of that class.
				For example, <code>Integer</code> is a class, and <code>3</code>
				is an instance.  The inheritance of methods from parents
				happens in the classes, not the instances.</p>

				<p>As you know, Snap<em>!</em> takes a different approach.
				Every object combines the features of classes and instances;
				it can have methods and can inherit, like a class, but it's
				a specific value, like an instance.  (For example, sprites
				can have methods, and can inherit them, but a sprite can be
				shown on the stage and move around, like an instance.)  This
				approach is called <em>prototyping</em> OOP.</p>

				<p>Many languages that purport to use prototyping (JavaScript,
				for example) have a <em>special kind of object</em> called
				a "prototype," and that's the kind of object that can have
				methods and a parent.  If you're asking yourself "How does
				that differ from a class?" you're right.  Snap<em>!'</em>s
				prototyping is both simpler and more flexible.</p>

			</div>
		</div>

		<p>Why would you use an object oriented language?  Programmers'
		opinions on this question have changed dramatically over time.  When
		Alan Kay and his team at
		<a href="https://en.wikipedia.org/wiki/PARC_(company)">Xerox PARC</a>
		introduced Smalltalk, very few people got the point.  But today, there
		are many programmers who insist that using anything <em>other</em>
		than object oriented programming is professional malpractice.  (They
		don't use Smalltalk, though; many use Java, the language of the
		College Board AP Computer Science A course.)  The main thing that's
		made OOP so popular is <em>information hiding,</em> which means that
		one object can't directly examine another object's variables or
		call its methods, but must
		instead send the target object a message that it accepts from
		other kinds of objects ("public messages").</p>

		<p>Ironically, information hiding isn't a necessary part of OOP.
		In Smalltalk, any message an object understands can be sent to
		it by other objects.  (There are no private methods.)
		In a language for learning, such as Smalltalk in
		its early days and Snap<em>!,</em> information hiding isn't
		important.  Programs are small, and they have just one or two authors.
		(The people who talk about malpractice are thinking about teams of 500
		programmers, and all the ways they can step on each others' feet
		unless the objects each one programs are protected from each other.)
		That's why Snap<em>!</em>, like Smalltalk, allows an object to call
		<em>any</em> method of another object, not just a few for which the
		other object publishes messages.  Snap<em>!</em>'s developers were
		more interested in one of Smalltalk's central ideas:
		<em>simulation.</em></p>

		<p>In pre-OOP programming, there's one program running all the time,
		and it's in charge of all the necessary computations.  That's fine if
		you're computing a function, for example, but some programs are
		meant to model the behavior of a complex system with many independent
		actors, such as the disease simulation project in this unit.  The
		simple model used in that project has only one object type, people.
		A better model would have different kinds of people (for example,
		those who do and those who don't follow medical advice about wearing
		masks) and would model the disease itself, such as its ability to
		mutate.  OOP is great at this kind of simulation, because each object
		is responsible for its own behavior.  (Scratch, from which Snap<em>!</em>
		inherited the idea of sprites, was originally implemented in
		Smalltalk, whose influence is seen in such details as multi-keyword
		block names, as well as in the organization of a program as scripts
		that belong to specific sprites, with no central program.)</p>

		<h3>Declarative Programming in Prolog</h3>

		<p>This section isn't going to start with "Imagine if Snap<em>!</em>..."
		Declarative programming is a very, very different approach.  What you
		have to imagine is that programs don't have algorithms!</p>

		<p>Instead, a program consists of <em>facts</em> and <em>rules</em>
		that you are teaching the computer.  One of the standard examples is
		about family trees.  "Brian's mother is Tessa" is a fact, a specific
		piece of information.

<pre>mother('Brian','Tessa').</pre>

		Rules are more general:  "If person A's mother is person B,
		and person B's mother is person C, then person A's grandmother
		is person C."  Here's how that would look in Prolog,
		the best-known declarative language:</p>

<pre>grandmother(A,C) :-
    mother(A,B),
    mother(B,C).</pre>

		<p>What about the mother of someone's father?  Shouldn't that have
		to be in the rule, too?  The answer is that you can have as many
		rules as you want about grandmotherhood:</p>

<pre>grandmother(A,C) :-
    father(A,B),
    mother(B,C).</pre>

		<p>Once you've taught the computer some rules and facts, you
		can ask questions, such as "Who is Brian's grandmother?":</p>

<pre>?- grandmother('Brian', X)</pre>

		<p>A very important difference between declarative programming
		(also called <em>logic programming</em>)
		and the other paradigms you've seen is that a question may have
		more than one answer!  This is very different from a function,
		which can only report one value.  Prolog doesn't just pick one
		answer to show you; it shows all the answers it can figure out
		from the information it has (one at a time).  Here's an example:</p>

<pre>?- append(X,Y,[a,b,c,d]).
<span style="background: #f7ffa0">X = [],
Y = [a, b, c, d]</span> ;
<span style="background: #f7c99b">X = [a],
Y = [b, c, d]</span> ;
<span style="background: #a5fbd9">X = [a, b],
Y = [c, d]</span> ;
<span style="background: #b0b6ff">X = [a, b, c],
Y = [d]</span> ;
<span style="background: #d1a191">X = [a, b, c, d],
Y = []</span> ;
<span style="background: #f9a1a0">false.</span></pre>

		<p>The user has asked "what two lists can be appended together
		to get the list <code>[a,b,c,d]</code>?"  There are five possible
		pairs of lists that satisfy the condition.  Prolog prints the
		first answer (shown in yellow above), then waits for the user to type
		the space key or semicolon, then displays the next answer, and
		so on.  When the user asks for a sixth answer, the result is
		"false," which means that Prolog can't find any more values for
		<var>X</var> and <var>Y</var> that make the query true.  (That
		doesn't mean it's <em>proven</em> false; for example, if you teach Prolog
		about your family tree and then ask questions about someone else's
		family, Prolog won't find any information, but that doesn't mean
		the other person really doesn't have any relatives.)</p>

		<p>Wow!  Snap<em>!</em> has an
		<img src="/bjc-r/img/5-algorithms/append.png" alt="append block"
		title="append block" />
		function; you can ask it questions such as
		"what do I get if I append the list <code>[a,b]</code> and the list
		<code>[c,d]</code>?"  But you can't "run it backward," asking
		questions such as "What must I append to <code>[a,b]</code> in order
		to get <code>[a,b,c,d]</code>?" let alone "What two lists can I
		append to get <code>[a,b,c,d]</code>?"  But Prolog's <code>append</code>
		isn't a function of two lists; it's a <em>relation</em> (you can
		think of it a predicate function, although you shouldn't forget
		that it's not really a function, running an algorithm, at all)
		among <em>three</em> lists, which is
		True if the result of appending the first two inputs is the third
		input.  There's no special magic in <code>append</code>; if it
		weren't predefined in Prolog, you could
		define it this way:

<pre>append([],Z,Z).

append([A|X],Y,[A|Z]) :- append(X,Y,Z).</pre>

		<p>The notation
		<code>[A|B]</code> represents a nonempty list whose first item is
		<var>A</var> and whose all-but-first is <var>B</var>.
		The first rule says that if you append an empty list and any
		list <var>Z</var>, you get <var>Z</var>.  The second rule says
		that if the first list <em>isn't</em> empty, then the first item
		of the result must be the first item of the first list, and the
		rest of the result must be the result of appending the rest of
		the first list and the second list.</p>

		<p>Okay, time for binary search in Prolog:</p>

<pre>contains(List, Value) :- even_division(_, [Value|_], List).

contains(List, Value) :-                          % eliminate first half of list
    even_division(_, [Center|SecondHalf], List),
    Center < Value, SecondHalf \= [],
    contains(SecondHalf, Value).

contains(List, Value) :-                          % eliminate second half of list
    even_division(FirstHalf, [Center|_], List),
    Center > Value, FirstHalf \= [],
    contains(FirstHalf, Value).

even_division(First, Second, Xs) :-               % find the middle word
    append(First, Second, Xs),
    length(First,F),
    length(Second,S),
    S >= F, S-F =< 1.</pre>
<p><small>Source: <a href="https://wiki.colby.edu/display/LPE/Prolog+Binary+Search">colby.edu</a></small></p>

		<p>The first thing to say about this program is that it's not really a
		good model of how to program in Prolog.  The helper rule
		<code>even_division</code> wants to divide a list into two equal-size
		pieces; it ends up dividing the list into two pieces <em>every
		possible way</em> (like the <code>append</code> example earlier), and
		then checks each of those divisions to find one whose two pieces are
		the same length.  If you really wanted to do a binary search in
		Prolog, you'd do it by using a more complicated data structure that
		comes pre-divided into equal size pieces.  But for the purpose of
		this lab, comparing languages, it's best to use the same
		structure in all the sample	programs.</p>

				<p>The
				underscore character <code>_</code>, used by itself, means that you
				don't care what value goes in that slot in the program.  (Underscores
				can also be used as part of a variable name or a relation name, as in the
				relation <code>even_division</code>.)</p>

				<p>So the first rule</p>

		<pre>contains(List, Value) :- even_division(_, [Value|_], List).</pre>

				<p>means that the given <var>Value</var> is in the <var>List</var>
				if it happens to be the middle item of the list&mdash;that is,
				<var>List</var> can be divided into two equal parts, you don't
				care what's in the first part, and the second part has
				<var>Value</var> as its first item, followed by some values you
				don't care about.<p>

				<p>The next rule handles the case in which the value is larger
				than the middle item of the list.  It says that <var>List</var>
				contains <var>Value</var> provided that the middle item
				<var>Center</var> is less than <var>Value</var>, the second
				half of <var>List</var> has items other than just <var>Center</var>,
				and those other items (<var>SecondHalf</var>) include the desired
				<var>Value</var>.  (The requirement that <var>SecondHalf</var>
				isn't an empty list is there to prevent infinite loops in which
				the program keeps dividing an empty list into two (equal size)
				empty lists.)</p>

				<p>Similarly, the third rule handles the case in which the value
				is smaller than <var>Center</var>.</p>

				<p>Why isn't there a rule saying to report False if the value
				isn't found?  This is the mind-stretching part of declarative
				programming.  A rule isn't a function, and it doesn't report a
				value.  That would be an algorithm!  A rule doesn't <em>do</em>
				anything; it's just another kind of data.  If Prolog can't
				match the question you ask against any combination of facts and
				rules, then you just don't get an answer at all.  That's not
				considered an error.</p>

				<p>The use of <code>even_division</code> in this program is an
				attempt to have it work the way binary search works, by dividing
				the list in half at each step.  But if you just want to know if
				a value is in a list and aren't worried about efficiency, the
				entire program could be replaced by one rule:</p>

		<pre>contains(List, Value) :- append(_, [Value|_], List).</pre>

				<p>This says that the list can be divided into two pieces
				(the first of which might be empty; you don't care what's
				in it), such that the desired value is the first item in
				the second piece of the list.  That example should give you
				some feeling for the power of the declarative programming notation.</p>

				<p>How does a Prolog program actually work?  If there are no
				algorithms, only data, how can any matching of queries to
				things in its database happen?  The answer is that the language
				itself implements a single, universal algorithm, called
				<em>resolution,</em> that will always find every answer to
				a question you ask that can be deduced from the database,
				provided that it doesn't get caught in an infinite loop.
				(If resolution could guarantee the impossibility of
				infinite loops, it would solve the Halting Problem, which
				you know can't be done.)</p>

		<div class="endnote">
			<a href="#hint-resolution" data-toggle="collapse" title="Click for more details on resolution."><img class="inline" src="/bjc-r/img/icons/read-more-mini.png" alt="Read More" title="Read More" />Could you tell me more about
			declarative programming?</a>
			<div id="hint-resolution" class="collapse">
				<p>The Prolog database consists of facts and rules.  The
				difference is that facts don't contain variables.  So,
				given a query such as <code>mother('Brian',X)</code>, it's
				pretty easy to see whether that matches a fact such as
				<table>
					<tr><td><code>father('Brian','Len')</code>&nbsp;</td>
						<td>Nope, father≠mother</td></tr>
					<tr><td><code>mother('Bob','Tessa')</code>&nbsp;</td>
						<td>Nope, 'Bob'≠'Brian'</td></tr>
					<tr><td><code>mother('Brian','Tessa')</code>&nbsp;</td>
						<td>Yes, provided that X='Tessa'</td></tr>
				</table>
				The only subtlety is that if the same variable is used twice
				in a query, it has to match the same text every time, so that
				someone who says <code>mother(X,X)</code>, presumably wanting
				to find someone who's their own mother, doesn't match every
				fact about mothers in the database.</p>

				<p>Rules are more complicated, because both the query and
				the rule can have variables.  Consider the query
				<code>append(X,Y,[a,b,c,d])</code> that you saw earlier.
				If the same variable name is used twice <em>in the same query,</em>
				or <em>in the same rule,</em> that name must match the same
				value each time it's used.  But it's okay for a user to use
				a variable name in a query that happens to be the same as
				a name used in a rule; they don't have to have the same
				value.  It's like using the same name in a <code>script
				variables</code> block in two different scripts; they're
				different variables despite the coincidence of the names.</p>

				<p>So, when trying to match a query against a rule, the first
				step is to systematically <em>rename</em> all the variables
				in the rule, with unique names.  For example, the first time
				Prolog compares a query with the rule
				<pre>append([],Z,Z).</pre>
				it (temporarily) changes the rule to something like
				<pre>append([],Z.1,Z.1).</pre>
				The next time it compares something to that rule, it'll
				change it to
				<pre>append([],Z.2,Z.2).</pre>
				And so on.</p>

				<p>Okay, compare the <code>append</code> query above with
				this first rule:
<pre>append(X,Y,[a,b,c,d]).
append([],Z.1,Z.1).</pre>
				This results in the following pairings:
<pre>X = []
Y = Z.1
Z.1 = [a,b,c,d]</pre>
				Combining the information in the last two of those
				pairings gives <code>Y = [a,b,c,d]</code>, so that
				gives both of the variables in the query values,
				so Prolog gives the first answer.</p>

				<p>That was a simple rule, in that its conclusion
				always holds.  The other <code>append</code> rule
				includes a condition that must be true in order for
				the rule to apply.  After renaming, that rule says
<pre>append([A.2|X.2],Y.2,[A.2|Z.2]) :- append(X.2,Y.2,Z.2).</pre>
				The resolution rule for rules with conditions is
				that first we try to match the query with the
				<em>conclusion</em> of the rule, then if that works, we
				take the condition of the rule as <em>a new query.</em>  In
				this case, we are comparing
<pre>append(X,Y,[a,b,c,d]).
append([A.2|X.2],Y.2,[A.2|Z.2]).</pre>
				The technical name for matching two expressions that
				can both contain variables is <em>unification.</em>
				Figuring out exactly how to get it right is hard,
				but luckily, it's been done, so you don't have to.
				Here are the results:
<pre>X = [A.2|X.2]
Y = Y.2
[A.2|Z.2] = [a,b,c,d]</pre>
				But now think about what the [...|...] notation means.
				That last match can be expressed as the two matches
<pre>A.2 = a
Z.2 = [b,c,d]</pre>
				This isn't enough to give us values for <var>X</var>
				and <var>Y</var> in the original query with no
				variables in the values.  But knowing that <var>A.2</var>
				must have the value <code>a</code> is a big step
				forward.  It tells us that <var>X</var> is a list
				whose first item is <code>a</code>.</p>

				<p>Now, <em>remembering all the pairings so far,</em>
				we start again with the query <code>append(X.2,Y.2,Z.2)</code>.
				Compare that with the first <code>append</code> rule:
<pre>append(X.2,Y.2,Z.2).
append([],Z.3,Z.3).</pre>
				From this we learn
<pre>X.2 = []
Y.2 = Z.3
Z.2 = Z.3</pre>
				This might be dizzy-making for people, but luckily
				computers don't get dizzy.  Here again are all the
				matches Prolog has found for this second answer:
<pre>X = [A.2|X.2]
Y = Y.2
[A.2|Z.2] = [a,b,c,d]
A.2 = a
Z.2 = [b,c,d]
X.2 = []
Y.2 = Z.3
Z.2 = Z.3</pre>
				You can trace through these equations to learn that
<pre>X = [A.2|X.2] = [a|[]] = [a]
Y = Y.2 = Z.3 = Z.2 = [b,c,d]</pre>
				and that's the second answer.  We'll stop here, but
				if you want you can match the query
<pre>append(X.2,Y.2,Z.2)</pre>
				against the second rule, and the result of that
				against the first rule, and so on.</p>
			</div>
		</div>

		<p>Why would you program in a declarative language?  Some
		problems just lend themselves to a database-ish frame of
		mind.  Think about family trees again.  There may be gaps
		in what you know about your ancestors; an algorithm that
		expects everyone in the database to have exactly two parents
		in the database wouldn't work if there's missing information.
		Similarly, if you have two mothers or two fathers, a situation
		that's more common these days than in the past, Prolog won't
		mind.  You just tell it two facts such as
		<code>mother('me','mom1')</code> and <code>mother('me','mom2')</code>.
		Also, nothing beats declarative programming for situations in
		which a problem can have more than one answer.  Think about
		a quadratic equation with two solutions.  In ordinary programming,
		you can write a function that reports a list of two numbers, but
		a list isn't a number, and can't take part in further numeric
		computations.  It's better if you get two separate answers, each
		of which is a number.</p>

		<h4>The Morals of the Story</h4>

		<p>So, one overall moral of this story is that if you have the urge to
		learn more programming languages, you'll be intellectually better off
		learning Haskell, Smalltalk, or Prolog, rather than learning a bunch
		of languages that are pretty much all the same, such as JavaScript,
		Python, C, Java, and so on.  (If you want a programming job this
		summer, though, you might need to learn the language a potential
		employer wants to use.)</p>

		<p>And, by the way, don't think that because this page is telling you
		about other languages it means you've learned all there is to know
		about Snap<em>!</em>.  For example, read Sections VIII (OOP
		with Procedures) and X (Continuations) in the
		<a href="https://snap.berkeley.edu/snap/help/SnapManual.pdf">Snap<em>!</em>
		Reference Manual</a>.</p>

		<p>But also, bear in mind that learning computer science doesn't
		mean learning a lot of programming languages.  If you study CS
		at the university level, you won't be taking classes named after
		programming languages; they'll have names like "Algorithms and
		Data Structures," "Graphics," "Operating Systems," "User Interface
		Design," "Compilers," "Recursive Function Theory," and so on.
		Maybe instead of learning another language, you should work your
		way through
		<em><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html">Structure
		and Interpretation of Computer Programs</a>,</em>
		the course that separates the wizards from the muggles.</p>
	</body>
</html>
