<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
		
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unidad 5 Laboratorio 1: Algoritmos de búsqueda y eficiencia, Página 5</title>
	</head>

	<body>
		<h2>Categorizando algoritmos</h2>
        <div class="todo">
            <p>PAUL SHOULD REVIEW THIS CONTENT.</p>
            <h3>TG and solutions need to be checked. --MF, 12/19/18</h3>
        </div>
        <div class="learn"><strong>En esta p&aacute;gina</strong>,comparar&aacute;s cuatro algoritmos y aprender&aacute;s c&oacute;mo cada uno de ellos toma una categor&iacute;a diferente de tiempo para ejecutarse.</div>
        
        <div class="forYouToDo" id="first">
			<ol>
				<li>
                    Localiza el bloque <img src="/bjc-r/img/5-algorithms/25000integers.es.png" alt="25,000 enteros empezando desde ()" title="25,000 enteros empezando desde ()"> incluido en tu proyecto, y registra el tiempo que demora para varios n&uacute;meros iniciales.<br>
                    <table class="bordered center standard" summary="tabla mostrando el n&uacute;mero de intentos necesarios para encontrar el &uacute;ltimo n&uacute;nero en una lista ordenada para una lista de largo dado">
                        <tbody>
<tr>
                            <th scope="col">N&uacute;mero inicial</th>
                            <th scope="col">&nbsp;Tiempo de <code>25,000 n&uacute;meros enteros<br></code></th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td style="height: 20px;"><br></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td><br></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td><br></td>
                        </tr>
                        <tr>
                            <td>1,000,000</td>
                            <td><br></td>
                        </tr>
                        <tr>
                            <td>10,000,000</td>
                            <td><br></td>
                        </tr>
                    </tbody></table>
                </li>
                <li><img class="imageRight" src="/bjc-r/img/icons/talk-with-your-partner.es.png" alt="Habla con tu compañero" title="Habla con tu compañero">Mira la tabla. &iquest;C&oacute;mo describir&iacute;as lo que sucede con el tiempo a medida que el n&uacute;mero inicial se hace m&aacute;s grande? Escribe una hip&oacute;tesis sobre este patr&oacute;n.</li>
                <li>
                    <div class="sidenoteBig">Hay varias maneras diferentes de ordenar una lista, algunas de las cuales aprender&aacute;s en Unidad 8. El bloque <code>categor&iacute;a</code> utiliza un algoritmo de "categor&iacute;a de inserci&oacute;n".</div>
                    Localiza el bloque <img class="inline nopadtb" src="/bjc-r/img/5-algorithms/sort.es.png" alt="sort 'list input slot'" title="sort 'list input slot'"> incluido en tu proyecto, y progr&aacute;malo para cada longitud de lista.<br>
                    <table class="bordered center standard" summary="tabla mostrando el n&uacute;mero de intentos necesarios para encontrar el &uacute;ltimo n&uacute;mero en una lista para una lista de largo dado">
                        <tbody>
<tr>
                            <th scope="col">Longitud de la lista</th>
                            <th scope="col">Tiempo de la <code>categor&iacute;a</code> </th>
                        </tr>
                        <tr>
                            <td>10</td>
                            <td><br></td>
                        </tr>
                        <tr>
                            <td>100</td>
                            <td><br></td>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td><br></td>
                        </tr>
                    </tbody></table>
                </li>
                <li><img class="inline" src="/bjc-r/img/icons/talk-with-your-partner-mini.es.png" alt="Habla con tu compañero" title="Habla con tu compañero">&iquest;C&oacute;mo describir&iacute;as lo que sucede con el tiempo a medida que el tama&ntilde;o de la lista de entrada se hace m&aacute;s grandeger? Escribe una hip&oacute;tesis.</li>
			</ol>
		</div>
        
        <p>Puedes clasificar los algoritmos por la cantidad de tiempo que tardan en ejecutarse. <!--To classify an algorithm, you look at the number of steps it takes to complete the algorithm and compare it to the size of the input. For example, <code>25,000 integers</code> takes <em>constant time:</em> computing 25,000 integers starting at seven takes as long as computing 25,000 integers starting at seven million. As a second example, <code>linear search</code> takes <em>linear time:</em> if you have ten times as many words in the dictionary, then it takes ten times as long to search through them all. As a third example, consider the <code>sort</code> algorithm you timed. It takes <em>quadratic time:</em> multiplying the input size by ten multiplies the time required by 10<sup>2</sup>. As another example, consider the <code>binary search</code> algorithm you timed. In binary search, multiplying the input size by ten <em>adds</em> a constant amount to the time required instead of multiplying by a constant amount. This is an example of <em>sublinear time</em>.--></p>
        
        <div class="forYouToDo">
        <div class="vocabBig">
            <ul>
                <li>Un algoritmo toma <strong>tiempo lineal</strong> el n&uacute;mero de pasos es proporcional al tama&ntilde;o de la entrada; doblando el tama&ntilde;o de la entrada se dobla el tiempo requerido.</li>
                <li>Un algoritmo toma <strong>tiempo sublineal </strong>si el tiempo aumenta m&aacute;s lentamente que el tama&ntilde;o.</li>
                <li>Un algoritmo toma <strong>tiempo constante </strong>si toma la misma cantidad de tiempo sin importar el tama&ntilde;o de la entrada.</li>
                <li>Un algoritmo toma <strong>tiempo cuadr&aacute;tico </strong>si el n&uacute;mero de pasos es proporcional al <em>cuadrado</em> del tama&ntilde;o de la entrada.</li>
            </ul>
        </div>
			<ol start="5">
				<li>Vuelve a mirar tu tabla para la <code>b&uacute;squeda lineal</code>. Confirma que al multiplicar la longitud de la lista por diez, se multiplica aproximadamente el tiempo empleado por diez&nbsp; (<em>tiempo lineal</em>).<!--the search time for the <var>100,000 word list</var> is (about) ten times as long as the time for the <var>10,000 word list</var>, which is (about) ten times as long as the time for the <var>1,000 word list</var>.--></li>
				<li>Vuelve a mirar tu tabla para la <code>b&uacute;squeda binaria</code>. Confirma que el tiempo de b&uacute;squeda para cada lista de palabras es menor que para la b&uacute;squeda lineal (<em>tiempo sublineal</em>).</li>
                <li>Vuelve a ver tu tabla para los <code>25,000 n&uacute;meros enteros</code>. Confirma que toma aproximadamente la misma cantidad de tiempo independientemente de la entrada (<em>tiempo constante</em>).</li>
				<li>Vuelve a ver tu tabla para <span style="font-family: monospace;">categor&iacute;a</span><code></code>. Confirma que al multiplicar la longitud de la lista por diez, se multiplica aproximadamente el tiempo por cien. (<em>tiempo cuadr&aacute;tico</em>).<!--Confirm that the time to sort the <var>100,000 word list</var> is (about) one hundred times as long as the time for the <var>10,000 word list</var>, which is (about) one hundred times as long as the time for the <var>1,000 word list</var>.--></li>
			</ol>
		</div>
        
        <p>La diferencia entre la b&uacute;squeda lineal y la b&uacute;squeda binaria puede ser muy importante si se busca en una lista de diez millones de elementos, pero la diferencia <em>m&aacute;s</em> importante en el algoritmo de eficiencia est&aacute; entre el tiempo polin&oacute;mico (proporcional a cualquier potencia del tama&ntilde;o de la entrada) y el tiempo exponencial.</p>
        
        <div class="vocabFullWidth">
            <ul>
                <li>
                    Un algoritmo toma <strong>tiempo polin&oacute;mico</strong> si el n&uacute;mero de pasos es menor o igual a una potencia del tama&ntilde;o de la entrada, como la constante (<em>n</em><sup>0</sup>), sublineal, lineal (<em>n</em><sup>1</sup>), cuadr&aacute;tico (<em>n</em><sup>2</sup>), o c&uacute;bico (<em>n</em><sup>3</sup>).
                    
                </li>
                <li>
                    Un algoritmo toma <strong>tiempo exponencial</strong> si el n&uacute;mero de pasos es menor o igual a una funci&oacute;n como 2<sup><em>n</em></sup>, 10<sup><em>n</em></sup>, etc., que es mucho m&aacute;s lento que cualquier polinomio. </li>
            </ul>
        </div>
        <p>En un algoritmo de tiempo exponencial, solo <em>a&ntilde;adiendo 1</em> al tama&ntilde;o de la entrada (<em>n</em>) of a 2<sup><em>n</em></sup> el algoritmo de tiempo &iexcl;<em>duplica</em> el n&uacute;mero de pasos! As&iacute; que, por ejemplo, si el tama&ntilde;o de la entrada es 20, <em>cualquier</em> algoritmo de tiempo polin&oacute;mico ser&aacute; lo suficientemente r&aacute;pido, pero un algoritmo de tiempo exponecial puede tomar muchos <em>a&ntilde;os</em> en finalizar.</p>
		
        <div class="commentBig">slow down animation, add labels, make exponential graph red, and fix weird hiccups on graphs; image also needs alt-text like what is in commented out text here. --MF, 4/2/19</div>
        <img class="indent noshadow" src="/bjc-r/img/5-algorithms/algorithm-time-graphs.gif" alt="" title="" width="230"><br>
        
        <div class="examFullWidth">
            <ul>
                <div class="comment">AAP-4.A.7</div>
                <li>El t&eacute;rmino "<strong>tiempo razonable</strong>" describe cualquier algoritmo que se ejecuta en tiempo polin&oacute;mico. Los algoritmos de tiempo exponencial <em>no</em> son considerados razonables. </li>
            </ul>
        </div>
    
        <div class="todo">
<div class="endnote">On the Internet, many people use the word exponential to mean "happening very fast", such as clickbait-headline-example-blah or example-bleh. -some nicer version of, now you know better-</div></div>
        
        <!--<img class="indent noshadow" style="height:300px" src="/bjc-r/img/5-algorithms/size-vs-time.es.png" alt="graph of size vs. time showing a straight line through the origin and up to the right with the points for x=10,000 and x=100,000 marked" title="graph of size vs. time showing a straight line through the origin and up to the right with the points for x=10,000 and x=100,000 marked" />-->
        
        <div class="comment">AAP-2.M.2 text before bullets</div>
        <p>Una raz&oacute;n por la que vale la pena aprender estas categor&iacute;as es para evitar reinventar la rueda. Por ejemplo, has aprendido que si una lista est&aacute; ordenada, puedes buscarla en tiempo sublineal utilizando la b&uacute;squeda binaria. Por lo tanto, cuando escribas un programa que necesite buscar en una lista repetidamente, vale la pena ordenar la lista antes de buscar. Conocer los algoritmos que ya existen puede ayudarte a construir nuevos algoritmos.</p>
        
        <p>Todos los algoritmos que has explorado hasta ahora en este laboratorio (<code>b&uacute;squeda lineal</code>; <code>b&uacute;squeda binaria</code>; <code>25,000 n&uacute;meros enteros</code>; y <code>categor&iacute;a</code>) son algoritmos de tiempo razonable. La siguiente actividad opcional es un ejemplo de un algoritmo de tiempo exponencial.</p>
        <div class="ifTime">
			<ol>
				<p>Un problema que puede ser familiar y que requiere un algoritmo de tiempo exponencial es el de calcular cualquier elemento dado del Tri&aacute;ngulo de Pascal. En el Tri&aacute;ngulo de Pascal, cada n&uacute;mero se encuentra sumando los dos n&uacute;meros de arriba. Por ejemplo, 4 + 6 = 10 y 15 + 6 = 21 como se muestra abajo. El primer y &uacute;ltimo n&uacute;mero de cada fila, que no tienen dos n&uacute;meros encima de ellos son 1. <br>
                    <img class="indent noshadow" src="/bjc-r/img/5-algorithms/pascals-triangle-numbers.jpg" alt="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1" title="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1">
                    <img class="indent" src="/bjc-r/img/5-algorithms/pascals-triangle-6-3-reporting.es.png" alt="pascals triangle, row: (6) position (3) reporting 10" title="pascals triangle, row: (6) position (3) reporting 10">
                </p>
                <li>
                    Localiza el <img class="inline" src="/bjc-r/img/8-recursive-reporters/pascals-triangle.es.png" alt="pascals triangle, row: () position: ()" title="pascals triangle, row: () position: ()"> bloque incluido en tu proyecto, y progr&aacute;malo para varias entradas.<br>
                    <div class="endnote">Si tardan demasiado en ejecutarse, puedes detener el programa; s&oacute;lo tienes que rellenar la tabla hasta donde te permita la velocidad de tu ordenador.</div>
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tbody>
<tr>
                            <th scope="col" style="white-space: nowrap;">Entradas</th>
                            <th scope="col" style="white-space: nowrap;">Tri&aacute;ngulo de tiemo dePascal</th>
                        </tr>
                        <tr>
                            <td>5, 2</td>
                            <td><br></td>
                        </tr>
                        <tr>
                            <td>10, 5</td>
                            <td><br></td>
                        </tr>
                        <tr>
                            <td>15, 7</td>
                            <td><br></td>
                        </tr>
                        <tr>
                            <td>20, 10</td>
                            <td><br></td>
                        </tr>
                        <tr>
                            <td>25, 12</td>
                            <td><br></td>
                        </tr>
                    </tbody></table>
                    <div class="endnote">El valor de la&nbsp; <var>fila</var> es la entrada del <code>tri&aacute;ngulo de pascal</code> que interesa. (La entrada de <var>posici&oacute;n</var> s&oacute;lo se da para obtener un tiempo para una de las posiciones cercanas al centro de la fila, que tardan m&aacute;s en calcularse.)</div> 
                    <p>Estas entradas de <var>fila</var> son muy peque&ntilde;as comparadas con el tama&ntilde;o de la entrada de los algoritmos de <code>b&uacute;squeda lineal</code>, <code>b&uacute;squeda binaria</code>, y <code>categor&iacute;a</code>, y a&uacute;n as&iacute; el tiempo requerido para el <code>tri&aacute;ngulo de pascal</code> es mucho mayor. Tu computadora probablemente no puede hacer mucho m&aacute;s all&aacute; de los <var>25</var>.</p>
                    <div class="endnote">Este algoritmo funciona sumando los dos n&uacute;meros de arriba usando el algoritmo dentro de s&iacute; mismo recursivamente, pero hay mejores algoritmos que calculan el valor de un n&uacute;mero en el Tri&aacute;ngulo de Pascal en tiempo lineal.</div>
                </li>
			</ol>
		</div>
        
        <div class="forYouToDo">
			<ol start="9">
                <div class="comment">AAP-4.A part a</div>
                <li>Escribe un p&aacute;rrafo que explique la diferencia entre los algoritmos que se ejecutan en un tiempo razonable y los que no lo hacen.</li>
				<li>
                    Esta pregunta es similar a las que ver&aacute;s en el examen de AP CSP.
                    <!-- Question 1 -->
                    <div class="assessment-data" type="multiplechoice" identifier="Timing of database tasks" hasinlinefeedback="true" maxchoices="1" responseidentifier="ri1" shuffle="true">
                        <div class="prompt">
                            La siguiente tabla muestra el tiempo que tarda la computadora en realizar varias tareas sobre los datos de ciudades de diferentes tama&ntilde;os.
                            
<p>
                                </p><table class="bordered center standard" summary="hours required for various data management tasks for towns of various sizes">
                                    <tbody>
<tr>
                                        <th scope="col">Tarea</th>
                                        <th scope="col">Ciudad peque&ntilde;a<br>(poblaci&oacute;n 1,000)</th>
                                        <th scope="col">Ciudad mediana<br>(poblaci&oacute;n 10,000)</th>
                                        <th scope="col">Ciudad grande<br>(poblaci&oacute;n 100,000)</th>
                                    </tr>
                                    <tr>
                                        <th scope="row">Entrada de datos</th>
                                        <td style="height: 20px;">2 horas</td>
                                        <td>20 horas</td>
                                        <td>200 horas</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Copia de seguridad de los datos</th>
                                        <td>0.5 horas</td>
                                        <td>5 horas</td>
                                        <td>50 horas</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">B&uacute;squeda a trav&eacute;s de los datos</th>
                                        <td>5 horas</td>
                                        <td>15 horas</td>
                                        <td>25 horas</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Clasificaci&oacute;n de datos</th>
                                        <td>0.01 hora</td>
                                        <td>1 hora</td>
                                        <td>100 hora</td>
                                    </tr>
                                </tbody></table>
                            <p></p>
                            Basado en la informaci&oacute;n de la tabla, cu&aacute;l de las siguientes tareas es probable que tome <em><strong>la mayor</strong></em> cantidad de tiempo cuando se ampl&iacute;a para una ciudad de poblaci&oacute;n 1,000,000.
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">Entrada de datos</div>
                            <div class="feedback">
                                <!--Entering data seems to take <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-entering-data.jpg" alt="population/1000" title="population/1000" /> hours, so for a population of 1,000,000, it should take about 2,000 hours.--> Al multiplicar el tama&ntilde;o de la poblaci&oacute;n por 10, el tiempo necesario para introducir los datos tambi&eacute;n se multiplica por 10, de modo que para una poblaci&oacute;n de 1.000.000, deber&iacute;a tomar alrededor de 10&times;200=2000 horas.
                            </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">Copia de seguridad de los datos</div>
                            <div class="feedback">
                                <!--Backing up data seems to take about <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-backing-up.jpg" alt="5^((population/1000)-1)" title="5^((population/1000)-1)" /> hours, so for a population of 1,000,000, it should take about 125 hours.--> Al multiplicar el tama&ntilde;o de la poblaci&oacute;n por 10, el tiempo necesario para hacer copias de seguridad de los datos se multiplica por 10, por lo que para una poblaci&oacute;n de 1.000.000, deber&iacute;a tardar unas 10&times;50=500 horas.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">B&uacute;squeda a trav&eacute;s de los datos</div>
                            <div class="feedback">
                                La b&uacute;squeda de datos parece aumentar en unas 10 horas cada vez que la poblaci&oacute;n se multiplica por 10, por lo que para una poblaci&oacute;n de 1.000.000, deber&iacute;a llevar unas 35 horas..
                            </div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">Clasificaci&oacute;n de datos</div>
                            <div class="feedback">
                                &iexcl;Correcto! <!--Sorting the data seems to go up exponentially as the the population grows. For a population of 1,000,000, it should take about 10,000 hours.--> Al multiplicar el tama&ntilde;o de la poblaci&oacute;n por 10, el tiempo necesario para la clasificaci&oacute;n de los datos se multiplica por 100. Por lo tanto, para una poblaci&oacute;n de 1.000.000, deber&iacute;a tomar alrededor de 100&times;100=10.000 horas.
                            </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri1">
                            <div class="correctResponse" identifier="c4"></div>
                        </div>
                    </div>
                </li>
            </ol>
        </div>
</body></html>
