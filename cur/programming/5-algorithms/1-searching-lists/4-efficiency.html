<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 1: Search Algorithms and Efficiency, Page 4</title>
	</head>

	<body>
		<div class="todo">
            <p>PAUL MUST REVIEW THIS CONTENT.</p>
            <p>TG and solutions will need to be checked. --MF, 12/19/18</p>
        </div>
        
        <h2>Exactly How Much Faster Is Binary Search?</h2>
        <div class="learn">
        	<div class="comment">Needs attention. --MF, 4/1/19</div>
            <p><strong>On this page</strong>, you will learn that some correct algorithms take too long to be practical.</p>
        </div>
		
        <div class="forYouToDo" id="first">
            <ol>
                <li>
                    <div class="comment">AAP-2.P.3</div>
                    Use the <img class="inline" src="/bjc-r/img/5-algorithms/computation-time-of.png" alt="computation time of 'grey ring input slot'" title="computation time of 'grey ring input slot'" /> block provided in this project to test the time it takes to find the "zebra" each algorithm and word list.
                    <table class="bordered center standard" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col">Length of List</th>
                            <th scope="col">Linear Search Time</th>
                            <th scope="col">Binary Search Time</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </li>
            </ol>
        </div>
        <p>
            The actual amount of physical time that it takes to solve a problem depends not only on your algorithm but also on how fast your computer is. Therefore, computer scientists who want to measure the speed of an algorithm do it in terms of the number of steps. For example, what we really want to know about binary search is how many times <var>current item</var> is compared to <var>value</var> (that is, how many times <img class="inline nopadtb" src="/bjc-r/img/5-algorithms/current-item=value.png" alt="(current item) = (value)" title="(current item) = (value)" /> is called).
        </p>
        <div class="forYouToDo">
			<ol start="2">
                <li>
                	<div class="comment">AAP-2.P</div>
                    <div class="comment">AAP-2.P.3</div>
                    If "zebra" is the <em>last word</em> in a word list, calculate the following:
                    <ul>
                        <li>How many comparisons are made if you do <code>linear search for (</code><var>zebra</var><code>)</code>?</li>
                        <li>How many comparisons are made if you do <code>binary search for (</code><var>zebra</var><code>)</code>?</li>
                    </ul>                
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Length of List</th>
                            <th scope="col" style="white-space: nowrap;">Linear Search Steps</th>
                            <th scope="col" style="white-space: nowrap;">Binary Search Steps</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li>
                	<div class="comment">AAP-2.P.3</div>
                	Compare the two search algorithms:
                    <ol>
                        <li>Which has more blocks in its code?</li>
                        <li>Which runs faster for large inputs?</li>
                    </ol>
                </li>
            </ol>
        </div>
        <div class="takeNote">In this course, you are mostly working with small problems, so it doesn't matter how efficient the algorithm is. But in the real world, programmers deal with lists of billions of items, so the efficiency of an algorithm can make a huge difference. </div>
        
        
        
        
        
        
        <div class="todo">
            <hr />
            <h2>Content pulled from 5.3 </h2>
            <hr />
        </div>
        <div class="todo">Introduce idea of Pascal's Triangle very breifly. Include some examples of where that comes up --MF, 4/1/19</div>
        <div class="forYouToDo">
			<ol start="4">
				<li>
                    <div class="comment">maybe have them sort the words lists before this... --MF, 4/1/19</div>
                    Maybe do this: Locate the <code>insertion sort</code> block included in your project, and time it for various inputs.<br />
                    <div class="sidenote">If these take too long to run, you can stop; just fill in the table as far as the speed of your computer will allow.</div>
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Length of List</th>
                            <th scope="col" style="white-space: nowrap;">Insertion Sort Time</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li>
                    Locate the <img class="inline" src="/bjc-r/img/8-recursive-reporters/pascals-triangle.png" alt="pascals triangle, row: () position: ()" title="pascals triangle, row: () position: ()" /> block included in your project, and time it for various inputs.<br />
                    <div class="sidenote">If these take too long to run, you can stop; just fill in the table as far as the speed of your computer will allow.</div>
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Inputs</th>
                            <th scope="col" style="white-space: nowrap;">Pascal's Triangle Time</th>
                        </tr>
                        <tr>
                            <td>5, 2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10, 5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>15, 7</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>20, 10</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>25, 12</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li>Maybe do some graphing?</li>
			</ol>
		</div>
        <p>You can classify algorithms by the amount of time they take to run.</p>
        <div class="todo">Then introduce polynomial vs. exponential</div>
                <div class="todo">content was commented out but might be relevant to new version. --MF, 3/29/19
            	<li>
                	The plot is not a line. There are several ways this can happen:
                	<ol>
                    	                       
                        <li>The plot looks close to the graph of a polynomial function (roughly like the graph of <span class="katex">y = x^n</span> for some positive integer <span class="katex">n</span>). This is called <em>polynomial time</em>.</li>
                        <li>The plot looks close to the graph of an exponential function, like <span class="katex">x \rightarrow 2^x</span> Guess what this kind of timing behavior is called. 
                        </li>
                        <li>There's  another kind of run-time that comes up often&#8212;you saw it when you looked at binary searches (like the guessing game). You'll analyze this type of reporter later in this lab. <div class="comment">Put a link here to page U5L1P2</div></li>
                    </ol>
                </li>
            </ul>
        </p>
        </div>

		


        	


        <div class="todo">
            <p>I want to put the two definitions in vocab box(es) and to yellowbox-hint all the efficiency categories. --MF, 9/26/18</p>
            <p>BH and MF agreed to focus on polynomial vs. exponential and on clarifying what exponential means (since many people get it wrong), and then to say, oh BTW, the college board calls this reasonable and unreasonable. --MF, 3/22/19</p>
        </div>
        <p>
            To classify an algorithm, look at the number of steps it takes to complete the algorithm, compared to the size of the input.
            <ul>
                <li>
                    <strong>Reasonable Time:</strong> If the number of steps is less than or equal to a power of the size of the input, then the algorithm takes <em>polynomial time</em>.
                    <!--<ul>
						<li>Some algorithms always take the same number of steps, even as the input grows. These algorithms take <em>constant time</em>.</li>
                        <li>Some algorithms take a number of steps proportional to the input size. <!--(If you double the size of the input, the number of steps doubles also.)- -> These algorithms take <em>linear time</em>. <!--A linear search of a list is an example.- -></li>
                        <li>Some algorithms take a number of steps more than constant but less than linear. These algorithms take <em>sublinear time</em>. <!--A binary search is an example.- -></li>
                        <li>If the number of steps is less than or equal to a power of the size of the input, then the algorithm takes <em>polynomial time</em>.</li>
                    </ul>-->
                    <p>
                        <em>Polynomial time</em> includes constant (<em>n</em><sup>0</sup>), sublinear, linear (<em>n</em><sup>1</sup>),  quadratic (<em>n</em><sup>2</sup>), cubic (<em>n</em><sup>3</sup>), etc. functions:
                        <!--In constant time algorithms, changing the size of the input does not change the number of steps. In linear time algorithms, changing the size of the input changes the number of steps by the same amount. In quadratic time algorithms, doubling the size of the input quadruples the number of steps, and trippling the size of the input 9-tuples the number of steps.--> 
                    </p>
                    <div class="endnote">
                        <div class="comment">As we edit this hint link, be sure to fix the title text too. --MF, 3/29/19</div>
                        <a href="#hint-efficiency-table" data-toggle="collapse" title="What kinds of polynomials?">What kinds of polynomials?</a>
                        <div id="hint-efficiency-table" class="collapse">
                            <table class="bordered" summary="list of several reasonable time efficiencies">
                                <tr>
                                    <th scope="col" style="width:20%;">algorithm efficiency</th>
                                    <th scope="col" style="width:40%;">If you double the size of input,<br />the time... </th>
                                    <th scope="col" style="width:40%;">example algorithm</th>
                                </tr>
                                <tr>
                                    <td>constant</td>
                                    <td>stays the same (multiplies by 2<sup>0</sup> which is 1)</td>
                                    <td><code>item (</code><var>87</var><code>) of ()</code></td>
                                </tr>
                                <tr>
                                    <td>sublinear</td>
                                    <td>multiplies by some number between 1 and 2 (between 2<sup>0</sup> and 2<sup>1</sup>)</td>
                                    <td>binary search: <code>position of () in sorted list</code></td>
                                </tr>
                                <tr>
                                    <td>linear</td>
                                    <td>multiplies by 2 (which is 2<sup>1</sup>)</td>
                                    <td>linear search: <code>position of () in unsorted list</code></td>
                                </tr>
                                <tr>
                                    <td>quadratic</td>
                                    <td>multiplies by 4 (which is 2<sup>2</sup>)</td>
                                    <td>some kinds of sorting algorithms</td>
                                </tr>
                                <tr>
                                    <td>cubic</td>
                                    <td>multiplies by 8 (which is 2<sup>3</sup>)</td>
                                    <td>some gene mapping algorithms used in biology</td>
                                </tr>
                            </table>
                            <p>It's rare to find polynomial time algorithms that take more than cubic (<em>n</em><sup>3</sup>) time.</p>
                            <p><a href="#hint-between-categories" data-toggle="collapse" title="What if an algorithm takes an amount of time that's between two categories?">What if an algorithm takes an amount of time that's <em>between</em> two categories?</a></p>
                            <div id="hint-between-categories" class="collapse">These categories say that an algorithm takes <em>at most</em> so much time.  So, for example, a constant-time algorithm is also a linear-time algorithm, and also a polynomial-time algorithm<!--, and also an exponential-time algorithm-->.  But <em>usually</em> if someone says an algorithm "takes quadratic time," they mean that it takes <em>more than</em> linear time but <em>not more than</em> quadratic time.</div>
                        </div>
                    </div>
                </li>
                <div class="comment">There is wording about exponential time here and in the LI above --MF, 3/29/19</div>
                <li>
                    <strong>Unreasonable Time:</strong> If the number of steps is more than any power of the size of the input (that is, more than any polynomial function<!--, such as an <em>exponential</em> function, 2<sup><em>n</em></sup>-->), then the algorithm takes an <em>unreasonable</em> amount of time.
					<div class="endnote">The classic example of an <em>unreasonable time</em> algorithm is one that takes <em>exponential</em> (2<sup><em>n</em></sup>) <em>time</em>. Just <em>adding 1</em> to the input size (<em>n</em>) <em>doubles</em> the number of steps! <!--Examples of exponential time algorithms include climate models or models of molecular physics.--></div>
                    <!--<ul>
                        <li>If the number of steps is an <em>exponential</em> function of the size of the input (or another function larger than any polynomial), we say that the algorithm takes an <em>unreasonable</em> amount of time. For an algorithm that takes 2<sup><em>n</em></sup> time, just <em>adding 1</em> to the input size (<em>n</em>) <em>doubles</em> the number of steps!</li>
                    </ul>-->
			        <p>One kind of problem whose solution often ends up unreasonable is an <em>optimization</em> problem (such as "find the best" or "find the smallest"). </p>
                </li>
            </ul>
        </p>
		<div class="takeNote">
            <div class="todo">This feels more important than we are giving time for. --MF, 3/11/19</div>
            It's important to recognize that an unreasonable-time algorithm <strong>still solves a problem correctly</strong>. Unreasonable-time algorithms can sometimes be replaced by <em>heuristics</em>, which are polynomial-time algorithms that don't solve the problem exactly, but give a good enough approximation.</div>
        <div class="endnote">
            <div class="comment">Yellowbox-Hint this too. --MF, 9/26/18</div>
            One reason it's worth learning these categories is that in writing programs, you often need to solve a problem for which there are already established solutions. For example, you've learned that searching for something in an unordered list takes linear time, but if the list is sorted, you can search it faster (in sublinear time).  So when you're writing a program that needs to search through a list repeatedly, you'll know that it's worthwhile to sort the list before the searching. Knowing about standard algorithms that already exist can help you construct new algorithms.
        </div>
        
        
        <div class="forYouToDo">
			<ol start="6">
                <li>Write a paragraph explaining the difference between algorithms that run in a reasonable time and algorithms that require unreasonable time to run.</li>
				<li>
                    This question is similar to those you will see on the AP CSP exam.
                    <!-- Question 1 -->
                    <div class="assessment-data" type="multiplechoice" identifier="Timing of database tasks"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="true">
                        <div class="prompt">
                            The table below shows the computer time it takes to complete various tasks on the data of different sized towns.
                            <p>
                                <table class="bordered" summary="hours required for various data management tasks for towns of various sizes">
                                    <tr>
                                        <th scope="col">Task</th>
                                        <th scope="col">Small Town<br />(population 1,000)</th>
                                        <th scope="col">Mid-sized Town<br />(population 10,000)</th>
                                        <th scope="col">Large Town<br />(population 100,000)</th>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Entering Data</th>
                                        <td>2 hours</td>
                                        <td>20 hours</td>
                                        <td>200 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Backing up Data</th>
                                        <td>0.5 hours</td>
                                        <td>5 hours</td>
                                        <td>50 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Searching through Data</th>
                                        <td>5 hours</td>
                                        <td>15 hours</td>
                                        <td>25 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Sorting Data</th>
                                        <td>0.01 hour</td>
                                        <td>1 hour</td>
                                        <td>100 hours</td>
                                    </tr>
                                </table>
                            </p>
                            Based on the information in the table, which of the following tasks is likely to take the <em><strong>longest</strong></em> amount of time when scaled up for a city of population 1,000,000.
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">Entering data</div>
                            <div class="feedback">
                                <!--Entering data seems to take <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-entering-data.jpg" alt="population/1000" title="population/1000" /> hours, so for a population of 1,000,000, it should take about 2,000 hours.-->
                                As the population size is multiplied by 10, the time needed for entering data is also multiplied by 10, so for a population of 1,000,000, it should take about 10&times;200=2000 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">Backing up data</div>
                            <div class="feedback">
                                <!--Backing up data seems to take about <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-backing-up.jpg" alt="5^((population/1000)-1)" title="5^((population/1000)-1)" /> hours, so for a population of 1,000,000, it should take about 125 hours.-->
                                As the population size is multiplied by 10, time needed for backing up data is multiplied by 10, so for a population of 1,000,000, it should take about 10&times;50=500 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">Searching through data</div>
                            <div class="feedback">
                                Searching through the data seems to go up by about 10 hours each time the population is multiplied by 10, so for a population of 1,000,000, it should take about 35 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">Sorting data</div>
                            <div class="feedback">
                                Correct! <!--Sorting the data seems to go up exponentially as the the population grows. For a population of 1,000,000, it should take about 10,000 hours.-->  As the population size is multiplied by 10, the time needed for the sorting of data is multiplied by 100.  So, for a population of 1,000,000, it should take about 100&times;100=10,000 hours.
                            </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri1">
                            <div class="correctResponse" identifier="c4"></div>
                        </div>
                    </div>
                </li>
			</ol>
		</div>
        <div class="todo">TIF needs edits</div>
        <div class="takeItFurther">
            <ol type="A">
                <li>
                   <a class="run" href="/bjc-r/prog/5-algorithms/U5L3-listfrom.xml" target="_blank"><img class="inline" src="/bjc-r/img/icons/load-save.png" alt="Click here to load this file. Then save it to your Snap! account." title="Click here to load this file. Then save it to your Snap! account."></a><br />Use the <img src="/bjc-r/img/5-algorithms/listfrom.png" alt="list from () to ()" title="list from () to ()" /> block to build the following two blocks in Snap<em>!</em>. Then, determine which block's algorithm can be executed in a reasonable time, and which cannot.
                    <div class="sidenote">The list of 2-digit numbers goes from 10 to 99. There's a math operations block that can give you powers of 10.</div>
                    <ol>
                        <li><img src="/bjc-r/img/5-algorithms/1000numbers.png" alt="1000 numbers starting from ()" title="1000 numbers starting from ()" /></li>
                        <li><img src="/bjc-r/img/5-algorithms/digitnumbers.png" alt="all () digit numbers" title="all () digit numbers" /></li>
                    </ol>
                </li>
            </ol>
        </div>
        

    </body>
</html>
