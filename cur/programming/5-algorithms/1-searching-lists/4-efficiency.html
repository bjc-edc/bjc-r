<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 1: Algorithms, Page 4</title>
	</head>

	<body>
		<div class="todo">
            <p>PAUL MUST REVIEW THIS CONTENT.</p>
            <p>TG and solutions will need to be checked. --MF, 12/19/18</p>
        </div>
        <div class="todo">
            <p>
                Point of page:
                <ul>
                    <li>different algorithms have different time requirements</li>
                    <li>the structure of the data changes what algorithms you can use</li>
                </ul>
            </p>
            <p>
                Plan:
                <ul>
                    <li>finding all the words such that ____</li>
                    <li>is ___ a word?</li>
                </ul>
            </p>
        </div>
    
        <h2>Exactly How Much Faster Is Binary Search?</h2>
        
        <div class="forYouToDo" id="first">
            <ol>
                <li>
                    <div class="comment">AAP-2.P.3</div>
                    Use the <img class="inline" src="/bjc-r/img/5-algorithms/computation-time-of.png" alt="computation time of 'grey ring input slot'" title="computation time of 'grey ring input slot'" /> block provided in this project to test the time it takes to find the "zebra" each algorithm and word list.
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Length of List</th>
                            <th scope="col" style="white-space: nowrap;">Linear Search Time</th>
                            <th scope="col" style="white-space: nowrap;">Binary Search Time</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </li>
            </ol>
        </div>
        <p>
            The actual amount of physical time that it takes to solve a problem depends not only on your algorithm but also on how fast your computer is. Therefore, computer scientists who want to measure the speed of an algorithm do it in terms of the number of steps. For example, what we really want to know about binary search is how many times <img class="inline nopadtb" src="/bjc-r/img/5-algorithms/current-item=value.png" alt="(current item) = (value)" title="(current item) = (value)" /> is called.
        </p>
        <div class="forYouToDo">
			<ol start="2">
                <li>
                	<div class="comment">AAP-2.P</div>
                    <div class="comment">AAP-2.P.3</div>
                    If "zebra" is the <em>last word</em> in a word list, calculate the following:
                    <ul>
                        <div class="comment">add images in place of code</div>
                        <li>How many words in the list are checked if you do <code>linear search (zebra)</code>?</li>
                        <li>How many words in the list are checked if you do <code>binary search (zebra)</code>?</li>
                    </ul>                
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Length of List</th>
                            <th scope="col" style="white-space: nowrap;">Linear Search Steps</th>
                            <th scope="col" style="white-space: nowrap;">Binary Search Steps</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li>
                	<div class="comment">AAP-2.P.3</div>
                	Compare the two search algorithms:
                    <ol>
                        <li>Which has more blocks in its code?</li>
                        <li>Which runs faster for large inputs?</li>
                    </ol>
                </li>
            </ol>
        </div>
        <div class="takeNote">In this course, you are mostly working with small problems, so it doesn't matter how efficient the algorithm is. But in the real world, programmers deal with lists of billions of items, so the efficiency of an algorithm can make a huge difference. </div>
        <div class="todo">
            <hr />
            <h2>Content pulled 5.3 </h2>
            <hr />
        </div>

        <div class="forYouToDo" id="first">
			<ol>
				<li>
                    <div class="todo">Only one of these is still going to exist. Need other examples. --MF, 3/11/19</div>
                    Throughout this course, you've programmed many algorithms. Try timing them. Here are some examples:
					<ul>	
                        <li><img src="/bjc-r/img/3-lists/U3ImageVideoAddendum_img/Graph datapoints.png" height="40" alt="Graph datapoints: ()" title="Graph datapoints: ()"/> (as you saw on <a href="/bjc-r/cur/programming/3-lists/4-graphing/2-building-a-grapher.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment" title="Unit 3 Lab 4: Building a Graphing App">Unit 3 Lab 4: Building a Graphing App</a>)</li>
                        <div class="comment">Only this <code>distict?</code> block is needed, and we can use it with <code>computation time of ()</code> in Lab 1. --MF, 3/13/19</div>
                        <li><img src="/bjc-r/img/5-algorithms/distinctelements.png" alt="are the numbers in () distinct?" title="are the numbers in () distinct?" /> (as you saw on <a href="/bjc-r/cur/programming/5-algorithms/1-searching-lists/5-comparing-search-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic" title="Unit 5 Lab 1: List Processing Algorithms">Unit 5 Lab 1: List Processing Algorithms</a>)</li>
                        <li><img class="" src="/bjc-r/img/5-algorithms/numbers-from-to.png" alt="numbers from () to ()" title="numbers from () to ()" /> (as you saw on <a href="/bjc-r/cur/programming/5-algorithms/3-timing-experiments/1-comparing-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic" title="Unit 5 Lab 3: Comparing Algorithms">Unit 5 Lab 3: Comparing Algorithms</a>)</li>
                    </ul>
                    <p>Time your algorithms for varying size inputs and describe the different behaviors you see. Again, use large inputs for meaningful results.</p>
                </li>
			</ol>
		</div>

        <div class="todo"><h2>BH and MF: keep page appended to end of 5.1.2 (page 3) with some yellowboxing the whitetext; drop #3-5; keep #7 and 6 in reversed order (need to say "unreasonable <em>for large inputs</em>"</h2></div>
		
		<div class="todo">
            <strong>Brian</strong>, after we review my changes below, we should address both of these:
            <ul>
            	<li>There is a lot of commented-out content on this page. If it's not needed, it should be removed. --MF, 12/20/17</li>
            </ul>
        </div>
        
        <div class="learn">
        	<p><strong>On this page</strong>, you will learn that some correct algorithms take too long to be practical.</p>
        </div>
		
        <div class="forYouToDo" id="first">
            <ol>
                <li>
                    <div class="todo">This <em>feels</em> repetitive even though the task actually isn't. --MF, 3/11/19</div>
                	If it isn't already open, load the project U5L3-timer from the previous page. You will be experimenting with <code>time function</code> with each of these input functions: 
                	<ul>	
                        <li><img src="/bjc-r/img/3-lists/U3ImageVideoAddendum_img/Graph datapoints.png" height="40" alt="Graph datapoints: ()" title="Graph datapoints: ()"/> (as you saw on <a href="/bjc-r/cur/programming/3-lists/4-graphing/2-building-a-grapher.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment" title="Unit 3 Lab 4: Building a Graphing App">Unit 3 Lab 4: Building a Graphing App</a>)</li>
                        <li><img src="/bjc-r/img/5-algorithms/distinctelements.png" alt="are the numbers in () distinct?" title="are the numbers in () distinct?" /> (as you saw on <a href="/bjc-r/cur/programming/5-algorithms/1-searching-lists/5-comparing-search-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic" title="Unit 5 Lab 1: List Processing Algorithms">Unit 5 Lab 1: List Processing Algorithms</a>)</li>
                        <li><img class="" src="/bjc-r/img/5-algorithms/numbers-from-to.png" alt="numbers from () to ()" title="numbers from () to ()" /> (as you saw on <a href="/bjc-r/cur/programming/5-algorithms/3-timing-experiments/1-comparing-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic" title="Unit 5 Lab 3: Comparing Algorithms">Unit 5 Lab 3: Comparing Algorithms</a>)</li>
                    </ul>
					For each one, what happens to the running time if you double the size of the input? 
                    <div class="endnote">What does it mean to double the size of the input for <code>numbers from () to ()</code>?</div>
                </li>
            </ol>
        </div> 

        <div class="todo">
        Do we want any of this? Could we use any of the graphing stuff from Jens that we are doing in U3 here? --MF, 3/29/19
            <p>
                It would be nice to create a data-plot of the average time it takes a reporter to ouput, given a list of inputs. To do this, you'll want to create a list. The reporter <code> make a list of times for a reporter between two inputs </code> creates such a list. Here's how it looks in action:<br />
                <a class="run" href="/bjc-r/prog/5-algorithms/U5L3avtime.xml"><img class="indent" src="/bjc-r/img/5-algorithms/listtimes.png" alt="average alphie" title="average alphie" /></a>
            </p>

            <div class="sidenote">You can create the block for yourself. Try it. Or you can click to load a pre-programmed version.</div>

            <p>
                What's happened here is that Alphie's reporter (adding the numbers between 1 and some upper limit) was applied to upper limits between  100 and 10000, and <code>average time</code>'d along the way.  The input 2 specifies what "along the way" means:  these special inputs start with 100 and are multiplied by 2 until you get the largest multiple less than 10000:<br />
                <table class="bordered center">
                    <tr>
                        <td>100</td>
                        <td>200</td>
                        <td>400</td>
                        <td>800</td>
                        <td>1600</td>
                        <td>3200</td>
                        <td>6400</td>
                    </tr>     
                </table>
            </p>

            <div class="forYouToDo">
                <ol start="2">
                    <li>Experiment with <code>make a list of times for a reporter between two inputs</code>. Try different reporters that you've built as inputs and vary the other inputs  (for example instead of 2, try 1.5, 1.1, and so on). </li>
                </ol>
            </div>
            <div class="takeNote">Because <code>make a list for a reporter between two inputs</code> often takes a long time to compute its output (think about what it's doing) you may want to store   outputs for various reporters in variables so that you can use them later. The reason that the last input multiplies by a factor (rather than making a constant increment) is so that you can get a large range of inputs without having to time the reporter on too many of them.</div> 
            <div class="forYouToDo">       
                <p>One way to analyze algorithms is to  use the <code> graph data points</code> package from U5L2 to plot the run time against the size of the input and to classify the reporters by the shape of the plots.</p>
                <ol start="3">
                    <img class="imageRight" src="/bjc-r/img/5-algorithms/alphiepict.png" alt="" title="" />
                    <li>Try it.  Create a data plot of the reporters you timed in the problem above: Pick a reporter and make a data-plot for the output of <code>make a list for a reporter between two inputs</code>.</li>
                </ol> 
            </div>      

        </div>

        <p>You can classify algorithms by the amount of time they take to run.</p>
        <div class="forYouToDo">
            <ol start="2">
                <li>
                   <a class="run" href="/bjc-r/prog/5-algorithms/U5L3-listfrom.xml" target="_blank"><img class="inline" src="/bjc-r/img/icons/load-save.png" alt="Click here to load this file. Then save it to your Snap! account." title="Click here to load this file. Then save it to your Snap! account."></a><br />Use the <img src="/bjc-r/img/5-algorithms/listfrom.png" alt="list from () to ()" title="list from () to ()" /> block to build the following two blocks in Snap<em>!</em>. Then, determine which block's algorithm can be executed in a reasonable time, and which cannot.
                    <div class="sidenote">The list of 2-digit numbers goes from 10 to 99. There's a math operations block that can give you powers of 10.</div>
                    <ol>
                        <li><img src="/bjc-r/img/5-algorithms/1000numbers.png" alt="1000 numbers starting from ()" title="1000 numbers starting from ()" /></li>
                        <li><img src="/bjc-r/img/5-algorithms/digitnumbers.png" alt="all () digit numbers" title="all () digit numbers" /></li>
                    </ol>
                </li>
            </ol>
        </div>	


        <div class="todo">
            <p>I want to put the two definitions in vocab box(es) and to yellowbox-hint all the efficiency categories. --MF, 9/26/18</p>
            <p>BH and MF agreed to focus on polynomial vs. exponential and on clarifying what exponential means (since many people get it wrong), and then to say, oh BTW, the college board calls this reasonable and unreasonable. --MF, 3/22/19</p>
        </div>
        <p>
            To classify an algorithm, look at the number of steps it takes to complete the algorithm, compared to the size of the input.
            <ul>
                <li>
                    <strong>Reasonable Time:</strong> If the number of steps is less than or equal to a power of the size of the input, then the algorithm takes <em>polynomial time</em>.
                    <!--<ul>
						<li>Some algorithms always take the same number of steps, even as the input grows. These algorithms take <em>constant time</em>.</li>
                        <li>Some algorithms take a number of steps proportional to the input size. <!--(If you double the size of the input, the number of steps doubles also.)- -> These algorithms take <em>linear time</em>. <!--A linear search of a list is an example.- -></li>
                        <li>Some algorithms take a number of steps more than constant but less than linear. These algorithms take <em>sublinear time</em>. <!--A binary search is an example.- -></li>
                        <li>If the number of steps is less than or equal to a power of the size of the input, then the algorithm takes <em>polynomial time</em>.</li>
                    </ul>-->
                    <p>
                        <em>Polynomial time</em> includes constant (<em>n</em><sup>0</sup>), sublinear, linear (<em>n</em><sup>1</sup>),  quadratic (<em>n</em><sup>2</sup>), cubic (<em>n</em><sup>3</sup>), etc. functions:
                        <!--In constant time algorithms, changing the size of the input does not change the number of steps. In linear time algorithms, changing the size of the input changes the number of steps by the same amount. In quadratic time algorithms, doubling the size of the input quadruples the number of steps, and trippling the size of the input 9-tuples the number of steps.--> 
                        <table class="bordered" summary="list of several reasonable time efficiencies">
                            <tr>
                                <th scope="col" style="width:20%;">algorithm efficiency</th>
                                <th scope="col" style="width:40%;">If you double the size of input,<br />the time... </th>
                                <th scope="col" style="width:40%;">example algorithm</th>
                            </tr>
                            <tr>
                                <td>constant</td>
                                <td>stays the same (multiplies by 2<sup>0</sup> which is 1)</td>
                                <td><code>item (</code><var>87</var><code>) of ()</code></td>
                            </tr>
                            <tr>
                                <td>sublinear</td>
                                <td>multiplies by some number between 1 and 2 (between 2<sup>0</sup> and 2<sup>1</sup>)</td>
                                <td>binary search: <code>position of () in sorted list</code></td>
                            </tr>
                            <tr>
                                <td>linear</td>
                                <td>multiplies by 2 (which is 2<sup>1</sup>)</td>
                                <td>linear search: <code>position of () in unsorted list</code></td>
                            </tr>
                            <tr>
                                <td>quadratic</td>
                                <td>multiplies by 4 (which is 2<sup>2</sup>)</td>
                                <td>some kinds of sorting algorithms</td>
                            </tr>
                            <tr>
                                <td>cubic</td>
                                <td>multiplies by 8 (which is 2<sup>3</sup>)</td>
                                <td>some gene mapping algorithms used in biology</td>
                            </tr>
                        </table>
                    </p>
                    <p>It's rare to find polynomial time algorithms that take more than cubic (<em>n</em><sup>3</sup>) time.</p>
                    <div class="endnote">
                        <p><a href="#hint-between-categories" data-toggle="collapse" title="What if an algorithm takes an amount of time that's between two categories?">What if an algorithm takes an amount of time that's <em>between</em> two categories?</a></p>
                        <div id="hint-between-categories" class="collapse">These categories say that an algorithm takes <em>at most</em> so much time.  So, for example, a constant-time algorithm is also a linear-time algorithm, and also a polynomial-time algorithm<!--, and also an exponential-time algorithm-->.  But <em>usually</em> if someone says an algorithm "takes quadratic time," they mean that it takes <em>more than</em> linear time but <em>not more than</em> quadratic time.</div>
                    </div>
                </li>
                <div class="comment">There is wording about expotentnial time here and in the LI above --MF, 3/29/19</div>
                <li>
                    <strong>Unreasonable Time:</strong> If the number of steps is more than any power of the size of the input (that is, more than any polynomial function<!--, such as an <em>exponential</em> function, 2<sup><em>n</em></sup>-->), then the algorithm takes an <em>unreasonable</em> amount of time.
					<div class="endnote">The classic example of an <em>unreasonable time</em> algorithm is one that takes <em>exponential</em> (2<sup><em>n</em></sup>) <em>time</em>. Just <em>adding 1</em> to the input size (<em>n</em>) <em>doubles</em> the number of steps! <!--Examples of exponential time algorithms include climate models or models of molecular physics.--></div>
                    <!--<ul>
                        <li>If the number of steps is an <em>exponential</em> function of the size of the input (or another function larger than any polynomial), we say that the algorithm takes an <em>unreasonable</em> amount of time. For an algorithm that takes 2<sup><em>n</em></sup> time, just <em>adding 1</em> to the input size (<em>n</em>) <em>doubles</em> the number of steps!</li>
                    </ul>-->
			        <p>One kind of problem whose solution often ends up unreasonable is an <em>optimization</em> problem (such as "find the best" or "find the smallest"). </p>
                </li>
            </ul>
        </p>
		<div class="takeNote">
            <div class="todo">This feels more important than we are giving time for. --MF, 3/11/19</div>
            It's important to recognize that an unreasonable-time algorithm <strong>still solves a problem correctly</strong>. Unreasonable-time algorithms can sometimes be replaced by <em>heuristics</em>, which are polynomial-time algorithms that don't solve the problem exactly, but give a good enough approximation.</div>
        <div class="comment">Yellowbox-Hint this too. --MF, 9/26/18</div>
        <p>One reason it's worth learning these categories is that in writing programs, you often need to solve a problem for which there are already established solutions. For example, you've learned that searching for something in an unordered list takes linear time, but if the list is sorted, you can search it faster (in sublinear time).  So when you're writing a program that needs to search through a list repeatedly, you'll know that it's worthwhile to sort the list before the searching. Knowing about standard algorithms that already exist can help you construct new algorithms.</p>
        
        
        <div class="todo">content was commented out but might be relevant to new version. --MF, 3/29/19
            	<li>
                	The plot is not a line. There are several ways this can happen:
                	<ol>
                    	                       
                        <li>The plot looks close to the graph of a polynomial function (roughly like the graph of <span class="katex">y = x^n</span> for some positive integer <span class="katex">n</span>). This is called <em>polynomial time</em>.</li>
                        <li>The plot looks close to the graph of an exponential function, like <span class="katex">x \rightarrow 2^x</span> Guess what this kind of timing behavior is called. 
                        </li>
                        <li>There's  another kind of run-time that comes up often&#8212;you saw it when you looked at binary searches (like the guessing game). You'll analyze this type of reporter later in this lab. <div class="comment">Put a link here to page U5L1P2</div></li>
                    </ol>
                </li>
            </ul>
        </p>
        </div>
        <div class="forYouToDo">
			<ol start="6">
                <li>Write a paragraph explaining the difference between algorithms that run in a reasonable time and algorithms that require unreasonable time to run.</li>
				<li>
                    This question is similar to those you will see on the AP CSP exam.
                    <!-- Question 1 -->
                    <div class="assessment-data" type="multiplechoice" identifier="Timing of database tasks"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="true">
                        <div class="prompt">
                            The table below shows the computer time it takes to complete various tasks on the data of different sized towns.
                            <p>
                                <table class="bordered" summary="hours required for various data management tasks for towns of various sizes">
                                    <tr>
                                        <th scope="col">Task</th>
                                        <th scope="col">Small Town<br />(population 1,000)</th>
                                        <th scope="col">Mid-sized Town<br />(population 10,000)</th>
                                        <th scope="col">Large Town<br />(population 100,000)</th>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Entering Data</th>
                                        <td>2 hours</td>
                                        <td>20 hours</td>
                                        <td>200 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Backing up Data</th>
                                        <td>0.5 hours</td>
                                        <td>5 hours</td>
                                        <td>50 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Searching through Data</th>
                                        <td>5 hours</td>
                                        <td>15 hours</td>
                                        <td>25 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Sorting Data</th>
                                        <td>0.01 hour</td>
                                        <td>1 hour</td>
                                        <td>100 hours</td>
                                    </tr>
                                </table>
                            </p>
                            Based on the information in the table, which of the following tasks is likely to take the <em><strong>longest</strong></em> amount of time when scaled up for a city of population 1,000,000.
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">Entering data</div>
                            <div class="feedback">
                                <!--Entering data seems to take <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-entering-data.jpg" alt="population/1000" title="population/1000" /> hours, so for a population of 1,000,000, it should take about 2,000 hours.-->
                                As the population size is multiplied by 10, the time needed for entering data is also multiplied by 10, so for a population of 1,000,000, it should take about 10&times;200=2000 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">Backing up data</div>
                            <div class="feedback">
                                <!--Backing up data seems to take about <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-backing-up.jpg" alt="5^((population/1000)-1)" title="5^((population/1000)-1)" /> hours, so for a population of 1,000,000, it should take about 125 hours.-->
                                As the population size is multiplied by 10, time needed for backing up data is multiplied by 10, so for a population of 1,000,000, it should take about 10&times;50=500 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">Searching through data</div>
                            <div class="feedback">
                                Searching through the data seems to go up by about 10 hours each time the population is multiplied by 10, so for a population of 1,000,000, it should take about 35 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">Sorting data</div>
                            <div class="feedback">
                                Correct! <!--Sorting the data seems to go up exponentially as the the population grows. For a population of 1,000,000, it should take about 10,000 hours.-->  As the population size is multiplied by 10, the time needed for the sorting of data is multiplied by 100.  So, for a population of 1,000,000, it should take about 100&times;100=10,000 hours.
                            </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri1">
                            <div class="correctResponse" identifier="c4"></div>
                        </div>
                    </div>
                </li>
			</ol>
		</div>
		

        
    

    </body>
</html>
