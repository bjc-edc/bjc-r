<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 1: Search Algorithms and Efficiency, Page 4</title>
	</head>

	<body>
		<div class="todo">
            <p>PAUL MUST REVIEW THIS CONTENT.</p>
            <p>TG and solutions will need to be checked. --MF, 12/19/18</p>
        </div>
        
        <h2>Exactly How Much Faster Is Binary Search?</h2>
        <div class="learn">
        	<div class="comment">Needs attention. --MF, 4/1/19</div>
            <p><strong>On this page</strong>, you will learn that some correct algorithms take too long to be practical.</p>
        </div>
		<div class="todo">Brian, I moved the linear stuff to the linear page (page 2), but I think this binary stuff should stay here because: page 3 has enough going on to cohere already and this connects better here (plus it's the page of this page!) --MF, 4/2/19</div>
        <div class="forYouToDo" id="first">
            <ol>
                <li>
                    <div class="comment">AAP-2.P.3</div>
                    Use the <img class="inline" src="/bjc-r/img/5-algorithms/computation-time-of.png" alt="computation time of 'grey ring input slot'" title="computation time of 'grey ring input slot'" /> block provided in this project to test the time it takes to find the "zebra" each algorithm and word list.
                    <div class="comment">summary needs edits</div>
                    <table class="bordered center standard" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col">Length of List</th>
                            <th scope="col"><code>Binary Search</code> Time</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li><img class="inline" src="/bjc-r/img/icons/talk-with-your-partner.png" alt="Talk with Your Partner" title="Talk with Your Partner" /> How would you describe what happens to the time as the input list gets bigger in each step of this chart? Write your hypothesis about the pattern.</li>
                <div class="todo">
                I propose not doing the steps again with binary. The point has already been made with linear. --MF, 4/2/19
                <li>
                	<div class="comment">AAP-2.P</div>
                    <div class="comment">AAP-2.P.3</div>
                    Add another column to your table. Assuming "zebra" is the <em>last word</em> in a word list, how many comparisons are made if you do <code>binary search for (</code><var>zebra</var><code>)</code> with each size list?                
                    <div class="comment">Edit table summary and CSS on all tables in this lab</div>
                    <table class="bordered center standard" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col">Length of List</th>
                            <th scope="col"><code>Binary Search</code> Time</th>
                            <th scope="col"><code>Binary Search</code> Steps</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li>some observation about how steps measure time again??</li>
                </div>
                <li>
                	<div class="comment">AAP-2.P.3</div>
                	Look back at your table for the <code>linear search</code> algorithm, and compare the two search algorithms:
                    <ol>
                        <li>Which has more blocks in its code?</li>
                        <li>Which runs faster for large inputs?</li>
                    </ol>
                </li>
            </ol>
        </div>
        
        <!--
        <h3>Timing Algorithms</h3>
        <div class="forYouToDo" id="first">
            <ol>
                <li>
                    <div class="comment">AAP-2.P.3</div>
                    Use the <img class="inline" src="/bjc-r/img/5-algorithms/computation-time-of.png" alt="computation time of 'grey ring input slot'" title="computation time of 'grey ring input slot'" /> block provided in this project to test the time it takes to find the "zebra" each algorithm and word list.
                    <table class="bordered center standard" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col">Length of List</th>
                            <th scope="col"><code>Linear Search</code> Time</th>
                            <th scope="col"><code>Binary Search</code> Time</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </li>
            </ol>
        </div>-->
        <!--<p>
            The actual amount of physical time that it takes to solve a problem depends not only on your algorithm but also on how fast your computer is. Therefore, computer scientists who want to measure the speed of an algorithm do it in terms of the number of steps. For example, what we really want to know about binary search is how many times <var>current item</var> is compared to <var>value</var> (that is, how many times <img class="inline nopadtb" src="/bjc-r/img/5-algorithms/current-item=value.png" alt="(current item) = (value)" title="(current item) = (value)" /> is called).
        </p>
        <div class="forYouToDo">
			<ol start="2">
                <li>
                	<div class="comment">AAP-2.P</div>
                    <div class="comment">AAP-2.P.3</div>
                    If "zebra" is the <em>last word</em> in a word list, calculate the following:
                    <ul>
                        <li>How many comparisons are made if you do <code>linear search for (</code><var>zebra</var><code>)</code>?</li>
                        <li>How many comparisons are made if you do <code>binary search for (</code><var>zebra</var><code>)</code>?</li>
                    </ul>                
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Length of List</th>
                            <th scope="col" style="white-space: nowrap;"><code>Linear Search</code> Steps</th>
                            <th scope="col" style="white-space: nowrap;"><code>Binary Search</code> Steps</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li>
                	<div class="comment">AAP-2.P.3</div>
                	Compare the two search algorithms:
                    <ol>
                        <li>Which has more blocks in its code?</li>
                        <li>Which runs faster for large inputs?</li>
                    </ol>
                </li>
            </ol>
        </div>-->
        <div class="takeNote"><div class="todo">This should be moved somewhere more sensible--maybe right after the pink box? --MF, 4/2/19</div>In this course, you are mostly working with small problems, so it doesn't matter how efficient the algorithm is. But in the real world, programmers deal with lists of billions of items, so the efficiency of an algorithm can make a huge difference. </div>
        
        <div class="forYouToDo">
			<ol start="4">
				<li>
                    Locate the <img src="/bjc-r/img/5-algorithms/25000integers.png" alt="25,000 integers starting from ()" title="25,000 integers starting from ()" /> block included in your project, and time it for various inputs.<br />
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Starting Number</th>
                            <th scope="col" style="white-space: nowrap;"><code>25,000 integers</code> Time</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1,000,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000,000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li><img class="imageRight" src="/bjc-r/img/icons/talk-with-your-partner.png" alt="Talk with Your Partner" title="Talk with Your Partner" /> Look at the table. How would you describe what happens to the time as the starting number gets bigger? Write a hypothesis about the pattern.</li>
                <li>
                    <div class="sidenoteBig">There are several different ways to sort a list, some of which you will learn about in Unit 8. This <code>sort</code> block uses an "insertion sort" algorithm.</div>
                    <div class="todo">maybe have them sort the words lists before this... --MF, 4/1/19 I want them to have an experience of what it does. --MF, 4/2/19</div>
                    Locate the <img class="inline nopadtb" src="/bjc-r/img/5-algorithms/sort.png" alt="sort 'list input slot'" title="sort 'list input slot'" /> block included in your project, and time it for various inputs.<br />
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Length of List</th>
                            <th scope="col" style="white-space: nowrap;"><code>Sort</code> Time</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li><img class="inline" src="/bjc-r/img/icons/talk-with-your-partner-mini.png" alt="Talk with Your Partner" title="Talk with Your Partner" />How would you describe what happens to the time as the size of the input list gets bigger? Write a hypothesis.</li>
			</ol>
		</div>
                
        <h3>Classifying Algorithms</h3>
        <div class="todo">This section needs attention after we decide if pieces of it belong earlier. We agreed on this oder: linear, sub, const, quad, exp. --MF, 4/2/19</div>
        <p>You can classify algorithms by the amount of time they take to run. To classify an algorithm, you look at the number of steps it takes to complete the algorithm and compare it to the size of the input.</p>
        <div class="vocabBig">
            <p>An algorithm takes <strong>constant time</strong> if it takes the same amount of time regardless of input size.</p>
        </div>
        <p> For example, <code>25,000 integers</code> takes <em>constant time:</em> computing 25,000 integers starting at seven takes as long as computing 25,000 integers starting at seven million.</p>
        <div class="forYouToDo">
			<ol start="5">
                <li>Look back at your calculations for the <code>25,000 integers</code> algorithm. Confirm that it time takes about the same amount of time regardless of the input.</li>
			</ol>
		</div>
    
        <div class="vocabBig">
            <p>An algorithm takes <strong>linear time</strong> the number of steps is proportional to the input size; doubling the input size doubles the time required.</p>
        </div>
        <p>As a second example, <code>linear search</code> takes <em>linear time:</em> if you have ten times as many words in the dictionary, then it takes ten times as long to search through them all.
        </p>
        <div class="forYouToDo">
			<ol start="6">
				<li>Look back at your calculations for the <code>linear search</code> algorithm. Confirm that the search time for the <var>100,000 word list</var> is (about) ten times as long as the time for the <var>10,000 word list</var>, which is (about) ten times as long as the time for the <var>1,000 word list</var>.</li>
			</ol>
		</div>

        <div class="vocabBig">
            <p>An algorithm takes <strong>quadratic time</strong> if the number of steps is proportional to the <em>square</em> of the input size.</p>
        </div>
        <p>As a third example, consider the <code>sort</code> algorithm you timed. It takes <em>quadratic time:</em> multiplying the input size by ten multiplies the time required by 10<sup>2</sup>.</p>
        <div class="forYouToDo">
			<ol start="7">
				<li>Look back at your calculations for the <code>sort</code> algorithm. Confirm that the time to sort the <var>100,000 word list</var> is (about) one hundred times as long as the time for the <var>10,000 word list</var>, which is (about) one hundred times as long as the time for the <var>1,000 word list</var>.</li>
			</ol>
		</div>

        
        
        
        <div class="vocabBig">
            <p>An algorithm takes <strong>sublinear time</strong> if it grows more slowly than the size.</p>
        </div>
        <p>As another example, consider the <code>binary search</code> algorithm you timed. In binary search, multiplying the input size by ten <em>adds</em> a constant amount to the time required instead of multiplying by a constant amount. This is an example of <em>sublinear time</em>.</p>
        <div class="forYouToDo">
			<ol start="7">
				<li>Look back at your calculations for the <code>binary search</code> algorithm. Confirm that the search time for each word list is less than for linear search.</li>
			</ol>
		</div>
            
            
            <div class="todo">or can be more than linear but less than quadratic time.</div>
		



        <p>The difference between linear search and binary search can be very important if you're searching in a list of ten million items, but the <em>most</em> important difference in algorithm efficiency is between polynomial time (proportional to any power of the input size) and exponential time.</p>

    
    
        

        <div class="todo">
            <s>In constant time algorithms, changing the size of the input does not change the number of steps. In linear time algorithms, changing the size of the input changes the number of steps by the same amount. In quadratic time algorithms, doubling the size of the input quadruples the number of steps, and trippling the size of the input 9-tuples the number of steps.</s> 
            <ul>
						<li>Some algorithms always take the same number of steps, even as the input grows. These algorithms take <em>constant time</em>.</li>
                        <li>Some algorithms take a number of steps proportional to the input size. <s>(If you double the size of the input, the number of steps doubles also.)</s> These algorithms take <em>linear time</em>. <s>A linear search of a list is an example.</s></li>
                        <li>Some algorithms take a number of steps more than constant but less than linear. These algorithms take <em>sublinear time</em>. <s>A binary search is an example.</s></li>
                        <li>If the number of steps is less than or equal to a power of the size of the input, then the algorithm takes <em>polynomial time</em>.</li>
            </ul>
        </div>

        <div class="vocabFullWidth">
            <ul>
                <li>
                    An algorithm takes <strong>polynomial time</strong> if the number of steps is less than or equal to a power of the size of the input, such as constant (<em>n</em><sup>0</sup>), sublinear, linear (<em>n</em><sup>1</sup>), quadratic (<em>n</em><sup>2</sup>), or cubic (<em>n</em><sup>3</sup>).
                    
                </li>
                <li>
                    Other algorithms may take <strong>exponential time</strong> (2<sup><em>n</em></sup>, 10<sup><em>n</em></sup>, etc.), which grows much faster than any polynomial. So for example, if the input size is 20 <em>any</em> polynomial time algorithm will be fast enough, but an exponential time algorithm might take many <em>years</em> to finish.                    
                </li>
            </ul>
        </div>
        <div class="examFullWidth">
            <ul>
                <li>The term "<strong>reasonable time</strong>" describes any algorithm that runs polynomial (constant, linear, square, etc.) time.  </li>
            </ul>
        </div>
        
        <div class="commentBig">slow down animation , add labels, and fix weird hiccups on graphs; image also needs alt-text like what is in commented out text here. --MF, 4/2/19</div>
        <img class="indent noshadow" src="/bjc-r/img/5-algorithms/algorithm-time-graphs.gif" alt="" title="" /><br />
        <!--<img class="indent noshadow" style="height:300px" src="/bjc-r/img/5-algorithms/size-vs-time.png" alt="graph of size vs. time showing a straight line through the origin and up to the right with the points for x=10,000 and x=100,000 marked" title="graph of size vs. time showing a straight line through the origin and up to the right with the points for x=10,000 and x=100,000 marked" />-->
        <div class="endnote">
            <div class="comment">As we edit this hint link, be sure to fix the title text too. --MF, 3/29/19</div>
            <a href="#hint-efficiency-table" data-toggle="collapse" title="What kinds of polynomials?">What kinds of polynomials?</a>
            <div id="hint-efficiency-table" class="collapse">
                <table class="bordered" summary="list of several reasonable time efficiencies">
                    <tr>
                        <th scope="col" style="width:20%;">algorithm efficiency</th>
                        <th scope="col" style="width:40%;">If you double the size of input,<br />the time... </th>
                        <th scope="col" style="width:40%;">example algorithm</th>
                    </tr>
                    <tr>
                        <td>constant</td>
                        <td>stays the same (multiplies by 2<sup>0</sup> which is 1)</td>
                        <td><code>item (</code><var>87</var><code>) of ()</code><div class="todo">BH got confused here.</div></td>
                    </tr>
                    <tr>
                        <td>sublinear</td>
                        <td>multiplies by some number between 1 and 2 (between 2<sup>0</sup> and 2<sup>1</sup>)</td>
                        <td>binary search: <code>position of () in sorted list</code></td>
                    </tr>
                    <tr>
                        <td>linear</td>
                        <td>multiplies by 2 (which is 2<sup>1</sup>)</td>
                        <td>linear search: <code>position of () in unsorted list</code></td>
                    </tr>
                    <tr>
                        <td>quadratic</td>
                        <td>multiplies by 4 (which is 2<sup>2</sup>)</td>
                        <td>some kinds of sorting algorithms</td>
                    </tr>
                    <tr>
                        <td>cubic</td>
                        <td>multiplies by 8 (which is 2<sup>3</sup>)</td>
                        <td>some gene mapping algorithms used in biology</td>
                    </tr>
                </table>
                <p>It's rare to find polynomial time algorithms that take more than cubic (<em>n</em><sup>3</sup>) time.</p>
                <p><a href="#hint-between-categories" data-toggle="collapse" title="What if an algorithm takes an amount of time that's between two categories?">What if an algorithm takes an amount of time that's <em>between</em> two categories?</a></p>
                <div id="hint-between-categories" class="collapse">These categories say that an algorithm takes <em>at most</em> so much time.  So, for example, a constant-time algorithm is also a linear-time algorithm, and also a polynomial-time algorithm<!--, and also an exponential-time algorithm-->.  But <em>usually</em> if someone says an algorithm "takes quadratic time," they mean that it takes <em>more than</em> linear time but <em>not more than</em> quadratic time.</div>
            </div>
        </div>
        <div class="todo">Can we cut this? --MF, 4/2/19
        <div class="endnote">The classic example of an <em>unreasonable time</em> algorithm is one that takes <em>exponential</em> (2<sup><em>n</em></sup>) <em>time</em>. Just <em>adding 1</em> to the input size (<em>n</em>) <em>doubles</em> the number of steps! <s>Examples of exponential time algorithms include climate models or models of molecular physics.</s></div>
        </div>


        <div class="todo">
            BH says this bit about optimization is wrong.
            <p>One kind of problem whose solution often ends up unreasonable is an <em>optimization</em> problem (such as "find the best" or "find the smallest"). </p>
        </div>

		<div class="todo">I think the Pascal's Triangle piece should be ITIT --MF, 4/2/19</div>
        <p>A problem that may be familiar that requires an exponential time algorithm is computing any given element of Pascal's Triangle. Pascal's Triangle starts with a number 1 at the top and at the start and end of each row, and then within each row below, any number in the triangle is found by adding the two numbers above and to the left and right. For example, 4 + 6 = 10 and 15 + 6 = 21 as shown below. <br />
            <img class="indent noshadow" src="/bjc-r/img/5-algorithms/pascals-triangle-numbers.jpg" alt="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1" title="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1" />
        <img class="indent" src="/bjc-r/img/5-algorithms/pascals-triangle-6-3-reporting.png" alt="pascals triangle, row: (6) position (3) reporting 10" title="pascals triangle, row: (6) position (3) reporting 10" />
        </p>
        <div class="ifTime">
			<ol>
				<li>
                    Locate the <img class="inline" src="/bjc-r/img/8-recursive-reporters/pascals-triangle.png" alt="pascals triangle, row: () position: ()" title="pascals triangle, row: () position: ()" /> block included in your project, and time it for various inputs.<br />
                    <div class="comment">On my machine, row 20 is slow, but doable, but row 25 is too slow. --MF, 4/2/19</div>
                    <div class="endnote">If these take too long to run, you can stop your program; just fill in the table as far as the speed of your computer will allow.</div>
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Inputs</th>
                            <th scope="col" style="white-space: nowrap;">Pascal's Triangle Time</th>
                        </tr>
                        <tr>
                            <td>5, 2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10, 5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>15, 7</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>20, 10</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>25, 12</td>
                            <td></td>
                        </tr>
                    </table>
                    <div class="endnote">The <var>row</var> value is the input to <code>pascals triangle</code> that matters. (The <var>position</var> input is only given so you get a time for one of the positions near the middle of the row, which take longer to compute.)</div> 
                    <p>These <var>row</var> inputs are very small compared to the input size for the <code>linear search</code>, <code>binary search</code>, and <code>sort</code> algorithms, and yet the time required for <code>pascals triangle</code> is much higher. Your computer probably can't do much past <var>25</var>.</p>
                </li>
			</ol>
		</div>


        
		<div class="takeNote">
            <div class="todo">This feels more important than we are giving time for. --MF, 3/11/19 Looking at AAP-4.A.8, AAP-4.A.9, and AAP-4.A part b, I worry that Pascal's Triangle isn't a great example (for approximations or heuristics). --MF, 4/2/19</div>
            It's important to recognize that an unreasonable-time algorithm <strong>still solves a problem correctly</strong>. Unreasonable-time algorithms can sometimes be replaced by <em>heuristics</em>, which are polynomial-time algorithms that don't solve the problem exactly, but give a good enough approximation.</div>
        <div class="todo">
        <div class="endnote">
            <div class="comment">Yellowbox-Hint this too. --MF, 9/26/18 Actually, do we need this at all? It reads like an old standard, especially at the end</div>
            One reason it's worth learning these categories is that in writing programs, you often need to solve a problem for which there are already established solutions. For example, you've learned that searching for something in an unordered list takes linear time, but if the list is sorted, you can search it faster (in sublinear time).  So when you're writing a program that needs to search through a list repeatedly, you'll know that it's worthwhile to sort the list before the searching. Knowing about standard algorithms that already exist can help you construct new algorithms.
        </div>
        </div>

        

        
        
        <div class="forYouToDo">
			<ol start="6">
                <div class="comment">AAP-4.A (part a only)</div>
                <li>Write a paragraph explaining the difference between algorithms that run in a reasonable time and those that do not.</li>
				<li>
                    This question is similar to those you will see on the AP CSP exam.
                    <!-- Question 1 -->
                    <div class="assessment-data" type="multiplechoice" identifier="Timing of database tasks"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="true">
                        <div class="prompt">
                            The table below shows the computer time it takes to complete various tasks on the data of different sized towns.
                            <p>
                                <table class="bordered" summary="hours required for various data management tasks for towns of various sizes">
                                    <tr>
                                        <th scope="col">Task</th>
                                        <th scope="col">Small Town<br />(population 1,000)</th>
                                        <th scope="col">Mid-sized Town<br />(population 10,000)</th>
                                        <th scope="col">Large Town<br />(population 100,000)</th>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Entering Data</th>
                                        <td>2 hours</td>
                                        <td>20 hours</td>
                                        <td>200 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Backing up Data</th>
                                        <td>0.5 hours</td>
                                        <td>5 hours</td>
                                        <td>50 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Searching through Data</th>
                                        <td>5 hours</td>
                                        <td>15 hours</td>
                                        <td>25 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Sorting Data</th>
                                        <td>0.01 hour</td>
                                        <td>1 hour</td>
                                        <td>100 hours</td>
                                    </tr>
                                </table>
                            </p>
                            Based on the information in the table, which of the following tasks is likely to take the <em><strong>longest</strong></em> amount of time when scaled up for a city of population 1,000,000.
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">Entering data</div>
                            <div class="feedback">
                                <!--Entering data seems to take <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-entering-data.jpg" alt="population/1000" title="population/1000" /> hours, so for a population of 1,000,000, it should take about 2,000 hours.-->
                                As the population size is multiplied by 10, the time needed for entering data is also multiplied by 10, so for a population of 1,000,000, it should take about 10&times;200=2000 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">Backing up data</div>
                            <div class="feedback">
                                <!--Backing up data seems to take about <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-backing-up.jpg" alt="5^((population/1000)-1)" title="5^((population/1000)-1)" /> hours, so for a population of 1,000,000, it should take about 125 hours.-->
                                As the population size is multiplied by 10, time needed for backing up data is multiplied by 10, so for a population of 1,000,000, it should take about 10&times;50=500 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">Searching through data</div>
                            <div class="feedback">
                                Searching through the data seems to go up by about 10 hours each time the population is multiplied by 10, so for a population of 1,000,000, it should take about 35 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">Sorting data</div>
                            <div class="feedback">
                                Correct! <!--Sorting the data seems to go up exponentially as the the population grows. For a population of 1,000,000, it should take about 10,000 hours.-->  As the population size is multiplied by 10, the time needed for the sorting of data is multiplied by 100.  So, for a population of 1,000,000, it should take about 100&times;100=10,000 hours.
                            </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri1">
                            <div class="correctResponse" identifier="c4"></div>
                        </div>
                    </div>
                </li>
			</ol>
		</div>
        <div class="todo">TIF needs edits; actually, we are now giving them part a, so do we need this at all? --MF, 4/2/19</div>
        <div class="takeItFurther">
            <ol type="A">
                <li>
                   <a class="run" href="/bjc-r/prog/5-algorithms/U5L3-listfrom.xml" target="_blank"><img class="inline" src="/bjc-r/img/icons/load-save.png" alt="Click here to load this file. Then save it to your Snap! account." title="Click here to load this file. Then save it to your Snap! account."></a><br />Use the <img src="/bjc-r/img/5-algorithms/listfrom.png" alt="list from () to ()" title="list from () to ()" /> block to build the following two blocks in Snap<em>!</em>. Then, determine which block's algorithm can be executed in a reasonable time, and which cannot.
                    <div class="sidenote">The list of 2-digit numbers goes from 10 to 99. There's a math operations block that can give you powers of 10.</div>
                    <ol>
                        <li><img src="/bjc-r/img/5-algorithms/1000numbers.png" alt="1000 numbers starting from ()" title="1000 numbers starting from ()" /></li>
                        <li><img src="/bjc-r/img/5-algorithms/digitnumbers.png" alt="all () digit numbers" title="all () digit numbers" /></li>
                    </ol>
                </li>
            </ol>
        </div>
        

    </body>
</html>
