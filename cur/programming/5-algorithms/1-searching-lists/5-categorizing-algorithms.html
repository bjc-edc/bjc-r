<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 1: Search Algorithms and Efficiency, Page 5</title>
	</head>

	<body>
		<div class="todo">
            <p>PAUL MUST REVIEW THIS CONTENT.</p>
            <p>TG and solutions will need to be checked. --MF, 12/19/18</p>
        </div>
        
        <h2>Categorizing Algorithms</h2>
        <div class="learn"><strong>On this page</strong>...</div>
        
        <div class="forYouToDo" id="first">
			<ol>
				<li>
                    Locate the <img src="/bjc-r/img/5-algorithms/25000integers.png" alt="25,000 integers starting from ()" title="25,000 integers starting from ()" /> block included in your project, and time it for various starting numbers.<br />
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Starting Number</th>
                            <th scope="col" style="white-space: nowrap;"><code>25,000 integers</code> Time</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1,000,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000,000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li><img class="imageRight" src="/bjc-r/img/icons/talk-with-your-partner.png" alt="Talk with Your Partner" title="Talk with Your Partner" /> Look at the table. How would you describe what happens to the time as the starting number gets bigger? Write a hypothesis about the pattern.</li>
                <li>
                    <div class="sidenoteBig">There are several different ways to sort a list, some of which you will learn about in Unit 8. This <code>sort</code> block uses an "insertion sort" algorithm.</div>
                    Locate the <img class="inline nopadtb" src="/bjc-r/img/5-algorithms/sort.png" alt="sort 'list input slot'" title="sort 'list input slot'" /> block included in your project, and time it for each length list.<br />
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Length of List</th>
                            <th scope="col" style="white-space: nowrap;"><code>Sort</code> Time</th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li><img class="inline" src="/bjc-r/img/icons/talk-with-your-partner-mini.png" alt="Talk with Your Partner" title="Talk with Your Partner" />How would you describe what happens to the time as the size of the input list gets bigger? Write a hypothesis.</li>
			</ol>
		</div>
        
        <p>You can classify algorithms by the amount of time they take to run. <!--To classify an algorithm, you look at the number of steps it takes to complete the algorithm and compare it to the size of the input. For example, <code>25,000 integers</code> takes <em>constant time:</em> computing 25,000 integers starting at seven takes as long as computing 25,000 integers starting at seven million. As a second example, <code>linear search</code> takes <em>linear time:</em> if you have ten times as many words in the dictionary, then it takes ten times as long to search through them all. As a third example, consider the <code>sort</code> algorithm you timed. It takes <em>quadratic time:</em> multiplying the input size by ten multiplies the time required by 10<sup>2</sup>. As another example, consider the <code>binary search</code> algorithm you timed. In binary search, multiplying the input size by ten <em>adds</em> a constant amount to the time required instead of multiplying by a constant amount. This is an example of <em>sublinear time</em>.--></p>
        
        <div class="forYouToDo">
        <div class="vocabBig">
            <ul>
                <li>An algorithm takes <strong>linear time</strong> the number of steps is proportional to the input size; doubling the input size doubles the time required.</li>
                <li>An algorithm takes <strong>sublinear time</strong> if the time grows more slowly than the size.</li>
                <li>An algorithm takes <strong>constant time</strong> if it takes the same amount of time regardless of input size.</li>
                <li>An algorithm takes <strong>quadratic time</strong> if the number of steps is proportional to the <em>square</em> of the input size.</li>
            </ul>
        </div>
			<ol start="5">
				<li>Look back at your table for <code>linear search</code>. Confirm that multiplying the list length by ten roughly multiplies the time taken by ten (<em>linear time</em>).<!--the search time for the <var>100,000 word list</var> is (about) ten times as long as the time for the <var>10,000 word list</var>, which is (about) ten times as long as the time for the <var>1,000 word list</var>.--></li>
				<li>Look back at your table for <code>binary search</code>. Confirm that the search time for each word list is less than for linear search (<em>sublinear time</em>).</li>
                <li>Look back at your table for <code>25,000 integers</code>. Confirm that it takes about the same amount of time regardless of the input (<em>constant time</em>).</li>
				<li>Look back at your table for <code>sort</code>. Confirm that multiplying the list length by ten roughly multiplies the time taken by one hundred (<em>quadratic time</em>).<!--Confirm that the time to sort the <var>100,000 word list</var> is (about) one hundred times as long as the time for the <var>10,000 word list</var>, which is (about) one hundred times as long as the time for the <var>1,000 word list</var>.--></li>
			</ol>
		</div>
        
        <p>The difference between linear search and binary search can be very important if you're searching in a list of ten million items, but the <em>most</em> important difference in algorithm efficiency is between polynomial time (proportional to any power of the input size) and exponential time.</p>
        
        <div class="vocabFullWidth">
            <ul>
                <li>
                    An algorithm takes <strong>polynomial time</strong> if the number of steps is less than or equal to a power of the size of the input, such as constant (<em>n</em><sup>0</sup>), sublinear, linear (<em>n</em><sup>1</sup>), quadratic (<em>n</em><sup>2</sup>), or cubic (<em>n</em><sup>3</sup>).
                    
                </li>
                <li>
                    An algorithm takes <strong>exponential time</strong> if the number of steps is less than or equal to a function like 2<sup><em>n</em></sup>, 10<sup><em>n</em></sup>, etc., which is much slower than any polynomial.
                </li>
            </ul>
        </div>
        <p>In an exponential time algorithm, just <em>adding 1</em> to the input size (<em>n</em>) of a 2<sup><em>n</em></sup> time algorithm <em>doubles</em> the number of steps! So, for example, if the input size is 20, <em>any</em> polynomial time algorithm will be fast enough, but an exponential time algorithm might take many <em>years</em> to finish.</p>
		
        <div class="commentBig">slow down animation, add labels, make exponential graph red, and fix weird hiccups on graphs; image also needs alt-text like what is in commented out text here. --MF, 4/2/19</div>
        <img class="indent noshadow" src="/bjc-r/img/5-algorithms/algorithm-time-graphs.gif" alt="" title="" /><br />
        
        <div class="takeNote">
            <div class="comment">AAP-4.A.6</div>
            It's important to recognize that an exponential time algorithm <strong>still solves a problem correctly</strong>. Exponential time algorithms can sometimes be replaced by <em>heuristics</em>, which are polynomial-time algorithms that don't solve the problem exactly, but give a good enough approximation.
        </div>
        <div class="examFullWidth">
            <ul>
                <li>The term "<strong>reasonable time</strong>" describes any algorithm that runs in polynomial time. Exponential time algorithms are <em>not</em> considered reasonable. </li>
            </ul>
        </div>
        <div class="todo"><div class="endnote">On the Internet, many people use the word exponential to mean "happening very fast", such as clickbait-headline-example-blah or example-bleh. -some nicer version of, now you know better-</div></div>
        
        <!--<img class="indent noshadow" style="height:300px" src="/bjc-r/img/5-algorithms/size-vs-time.png" alt="graph of size vs. time showing a straight line through the origin and up to the right with the points for x=10,000 and x=100,000 marked" title="graph of size vs. time showing a straight line through the origin and up to the right with the points for x=10,000 and x=100,000 marked" />-->
        
        <p>The following optional activity is an example of an exponential time algorithm.</p>
        <div class="ifTime">
			<ol>
				<p>A problem that may be familiar that requires an exponential time algorithm is computing any given element of Pascal's Triangle. In Pascal's Triangle, each number is found by adding the two numbers above it. For example, 4 + 6 = 10 and 15 + 6 = 21 as shown below. The first and last number of each row, which don't have two numbers above them are 1. <br />
                    <img class="indent noshadow" src="/bjc-r/img/5-algorithms/pascals-triangle-numbers.jpg" alt="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1" title="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1" />
                    <img class="indent" src="/bjc-r/img/5-algorithms/pascals-triangle-6-3-reporting.png" alt="pascals triangle, row: (6) position (3) reporting 10" title="pascals triangle, row: (6) position (3) reporting 10" />
                </p>
                <li>
                    Locate the <img class="inline" src="/bjc-r/img/8-recursive-reporters/pascals-triangle.png" alt="pascals triangle, row: () position: ()" title="pascals triangle, row: () position: ()" /> block included in your project, and time it for various inputs.<br />
                    <div class="endnote">If these take too long to run, you can stop your program; just fill in the table as far as the speed of your computer will allow.</div>
                    <table class="bordered center" summary="table showing the number of guesses needed to find the last number in a sorted list for a list of a given length">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Inputs</th>
                            <th scope="col" style="white-space: nowrap;">Pascal's Triangle Time</th>
                        </tr>
                        <tr>
                            <td>5, 2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10, 5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>15, 7</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>20, 10</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>25, 12</td>
                            <td></td>
                        </tr>
                    </table>
                    <div class="endnote">The <var>row</var> value is the input to <code>pascals triangle</code> that matters. (The <var>position</var> input is only given so you get a time for one of the positions near the middle of the row, which take longer to compute.)</div> 
                    <p>These <var>row</var> inputs are very small compared to the input size for the <code>linear search</code>, <code>binary search</code>, and <code>sort</code> algorithms, and yet the time required for <code>pascals triangle</code> is much higher. Your computer probably can't do much past <var>25</var>.</p>
                    <div class="endnote">This algorithm works by adding the two numbers above using the algorithm inside itself recursively, but there are better algorithms that compute the value a number in Pascal's Triangle in linear time.</div>
                </li>
			</ol>
		</div>
        
        <div class="forYouToDo">
			<ol start="6">
                <div class="comment">AAP-4.A (part a only)</div>
                <li>Write a paragraph explaining the difference between algorithms that run in a reasonable time and those that do not.</li>
				<li>
                    This question is similar to those you will see on the AP CSP exam.
                    <!-- Question 1 -->
                    <div class="assessment-data" type="multiplechoice" identifier="Timing of database tasks"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="true">
                        <div class="prompt">
                            The table below shows the computer time it takes to complete various tasks on the data of different sized towns.
                            <p>
                                <table class="bordered" summary="hours required for various data management tasks for towns of various sizes">
                                    <tr>
                                        <th scope="col">Task</th>
                                        <th scope="col">Small Town<br />(population 1,000)</th>
                                        <th scope="col">Mid-sized Town<br />(population 10,000)</th>
                                        <th scope="col">Large Town<br />(population 100,000)</th>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Entering Data</th>
                                        <td>2 hours</td>
                                        <td>20 hours</td>
                                        <td>200 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Backing up Data</th>
                                        <td>0.5 hours</td>
                                        <td>5 hours</td>
                                        <td>50 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Searching through Data</th>
                                        <td>5 hours</td>
                                        <td>15 hours</td>
                                        <td>25 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Sorting Data</th>
                                        <td>0.01 hour</td>
                                        <td>1 hour</td>
                                        <td>100 hours</td>
                                    </tr>
                                </table>
                            </p>
                            Based on the information in the table, which of the following tasks is likely to take the <em><strong>longest</strong></em> amount of time when scaled up for a city of population 1,000,000.
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">Entering data</div>
                            <div class="feedback">
                                <!--Entering data seems to take <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-entering-data.jpg" alt="population/1000" title="population/1000" /> hours, so for a population of 1,000,000, it should take about 2,000 hours.-->
                                As the population size is multiplied by 10, the time needed for entering data is also multiplied by 10, so for a population of 1,000,000, it should take about 10&times;200=2000 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">Backing up data</div>
                            <div class="feedback">
                                <!--Backing up data seems to take about <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-backing-up.jpg" alt="5^((population/1000)-1)" title="5^((population/1000)-1)" /> hours, so for a population of 1,000,000, it should take about 125 hours.-->
                                As the population size is multiplied by 10, time needed for backing up data is multiplied by 10, so for a population of 1,000,000, it should take about 10&times;50=500 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">Searching through data</div>
                            <div class="feedback">
                                Searching through the data seems to go up by about 10 hours each time the population is multiplied by 10, so for a population of 1,000,000, it should take about 35 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">Sorting data</div>
                            <div class="feedback">
                                Correct! <!--Sorting the data seems to go up exponentially as the the population grows. For a population of 1,000,000, it should take about 10,000 hours.-->  As the population size is multiplied by 10, the time needed for the sorting of data is multiplied by 100.  So, for a population of 1,000,000, it should take about 100&times;100=10,000 hours.
                            </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri1">
                            <div class="correctResponse" identifier="c4"></div>
                        </div>
                    </div>
                </li>
			</ol>
		</div>

        <h3>Other Algorithm Categories</h3>
        <p>There are ways of categorizing algorithms that aren't about how long they take. Here are two examples.</p>
        <div class="vocabFullWidth">
            <div class="comment">AAP-4.A.2</div>
            <ul>
                <li>An optimization problem is one with the goal of finding the <em>best</em> solution among many (for example...).</li>
                <li>A decision problem is a problem with a true/false answer (for example, "is 5,825,496,221 a prime number?").</li>
            </ul>
        </div>
        <div class="endnote">
            One reason it's worth learning these categories is to avoid reinventing the wheel. For example, you've learned that if a list is sorted you can search it in sublinear time using binary search. So when you're writing a program that needs to search through a list repeatedly, it's worthwhile to sort the list before searching. Knowing about algorithms that already exist can help you construct new algorithms.
        </div>
                

    </body>
</html>
