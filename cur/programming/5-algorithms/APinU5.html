<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>AP Standards in BJC</title>
		<style>ul li {color:green;} ul li li {color:purple;} .exclusion {color:blue;}</style>
	</head>

	<body>
		<h2>Unit 5: Algorithms and Data</h2>
		<div>
            <p>Here is an update based on our 12/29/15 meeting. --MF</p>
            <ul>
				<!--move to new U4 lab: "Representing Numbers"
                <li>
                    <strong>LO 2.1.2</strong> Explain how binary sequences are used to represent digital data. [P5]
                    <ul>
                        <li>
                        	<strong>EK 2.1.2A</strong> A finite representation is used to model the infinite mathematical concept of a number.
                        	<ul>
                            	<li class="exclusion">EXCLUSION STATEMENT (for EK 2.1.2A): Binary representations of scientific notation are beyond the scope of this course and the AP Exam.</li>
                            </ul>
                        </li>
                        <li>
                        	<strong>EK 2.1.2B</strong> In many programming languages, the fixed number of bits used to represent characters or integers limits the range of integer values and mathematical operations; this limitations can result in overflow or other errors.
                        	<ul>
                            	<li class="exclusion">EXCLUSION STATEMENT (for EK 2.1.2B): Range limitations of any one language, complier, or architecture are beyond the scope of this course and the AP Exam.</li>
                            </ul>
                        </li>
                        <li><strong>EK 2.1.2C</strong> In many programming languages, the fixed number of bits used to represent real numbers (as floating-point numbers) limits the range of floating-point values and mathematical operations; this limitations can result in round off and other errors.</li>
                        <div class="todo">
                            <strong>In this LO, but not suggested for U5 (should go in U1? 2.1.2D is listed in U1 currently, 2.1.2E and 2.1.2F would need to be added.):</strong>
                            <ul>
                                <li><strong>EK 2.1.2D</strong> The interpretation of a binary sequence depends on how it is used.</li>
                                <li><strong>EK 2.1.2E</strong> A sequence of bits may represent instructions or data.</li>
                                <li><strong>EK 2.1.2F</strong> A sequence of bits may represent different types of data in different contexts.</li>
                            </ul>
                        </div>
                    </ul>
                </li>-->
                
				<div class="comment">LO 2.3.1 and 2.3.2 go in Traffic Simulation</div>
                <li>
                	<strong>LO 2.3.1</strong> Use models and simulations to represent phenomena. [P3]
                    <ul>
                        <li><strong>EK 2.3.1A</strong> Models and simulations are simplified representations of more complex objects or phenomena.</li>
                        <li><strong>EK 2.3.1B</strong> Models may use different abstractions or levels of abstraction depending on the objects or phenomena being posed.</li>
                        <li><strong>EK 2.3.1C</strong> Models often omit unnecessary features of the objects or phenomena that are being modeled.</li>
                        <li><strong>EK 2.3.1D</strong> Simulations mimic real-world events without the cost or danger of building and testing the phenomena in the real world.</li>
					</ul>
                </li>
				<li>
                	<strong>LO 2.3.2</strong> Use models and simulations to formulate, refine, and test hypotheses. [P3]
					<ul>
                    	<li><strong>EK 2.3.2A</strong> Models and simulations facilitate the formulation and refinement of hypotheses related to the objects or phenomena under considerations.</li>
                        <li><strong>EK 2.3.2B</strong> Hypotheses are formulated to explain the objects or phenomena being modeled.</li>
                        <li><strong>EK 2.3.2C</strong> Hypotheses are refined by examining the insights that models and simulations provide in the objects or phenomena.</li>
                        <li><strong>EK 2.3.2D</strong> The results of simulations may generate new knowledge and new hypotheses related to the phenomena being modeled.</li>
                        <li><strong>EK 2.3.2E</strong> Simulations allow hypotheses to be tested without the constraints of the real world.</li>
                        <li><strong>EK 2.3.2F</strong> Simulations can facilitate extensive and rapid testing of models.</li>
                        <li><strong>EK 2.3.2G</strong> The time required for simulations is impacted by the level of detail and quality of the models and the software and hardware used for the simulation.</li>
                        <li><strong>EK 2.3.2H</strong> Rapid and extensive testing allows models to be changed to accurately reflect the objects or phenomena being modeled.</li>
					</ul>
                </li>
                
				<div class="comment">LO 3.1.2 goes in Data Processing</div>
                <li>
					<strong>LO 3.1.2</strong> Collaborate when processing information to gain insight and knowledge. [P6]
                    <ul>
                        <li><strong>EK 3.1.2A</strong> Collaboration is an important part of solving data-driven problems.</li>
                        <li><strong>EK 3.1.2B</strong> Collaboration facilitates solving computational problems by applying multiple perspectives, experiences, and skill sets.</li>
                        <li><strong>EK 3.1.2C</strong> Communication between participants working on data-driven problems gives rise to enhanced insights and knowledge.</li>
                        <li><strong>EK 3.1.2D</strong> Collaboration in developing hypotheses and questions, and in testing hypotheses and answering questions, about data helps participants gain insight and knowledge.</li>
                        <li><strong>EK 3.1.2E</strong> Collaborating face-to-face and using online collaborative tools can facilitate processing information to gain insight and knowledge.</li>
                        <li><strong>EK 3.1.2F</strong> Investigating large data sets collaboratively can lead to insight and knowledge not obtained when working alone.</li>
                    </ul>
				</li>
                
                <div class="comment">LO 4.2.1 goes in Timing Experiments</div>
				<li>
                    <strong>LO 4.2.1</strong> Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]
                    <ul>
                        <li class="exclusion">EXCLUSION STATEMENT (for LO 4.2.1): Any discussion of nondeterministic polynomial (NP) is beyond the scope of this course and the AP Exam.</li>
                    </ul>
                    <ul>
                        <li><strong>EK 4.2.1A</strong> Many problems can be solved in a reasonable time.</li>
                        <li><strong>EK 4.2.1B</strong> Reasonable time means that as the input size grows, the number of steps the algorithm takes is proportional to the square (or cube, fourth power, fifth power, etc.) of the size of the input.</li>
                        <li><strong>EK 4.2.1C</strong> Some problems cannot be solved in a reasonable time, even for small input sizes.</li>
                        <li><strong>EK 4.2.1D</strong> Some problems can be solved but not in a reasonable time. In these cases, heuristic approaches may be helpful to find solutions in reasonable time.</li>
					</ul>
                </li>
                
				<div class="comment">LO 4.2.2 and 4.2.3 go in Unsolvable and Undecidable Problems</div>
				<li>
                    <strong>LO 4.2.2</strong> Explain the difference between solvable and unsolvable problems in computer science. [P1]
                    <ul>
                        <li class="exclusion">EXCLUSION STATEMENT (for LO 4.2.2): Determining whether a given problem is solvable or unsolvable is beyond the scope of this course and the AP Exam.</li>
                    </ul>
                    <ul>
                        <li><strong>EK 4.2.2A</strong> A heuristic is a technique that may allow us to find an approximate solution when typical methods fail to find an exact solution.</li>
                        <li>
                        	<strong>EK 4.2.2B</strong> Heuristics may be helpful for finding an approximate solution more quickly when exact methods are too slow.
                        	<ul>
                            	<li class="exclusion">EXCLUSION STATEMENT (for EK 4.2.2B): Specific heuristic solutions are beyond the scope of this course and the AP Exam.</li>
                            </ul>
                        </li>
                        <li><strong>EK 4.2.2C</strong> Some optimization problems such as "find the best" or "find the smallest" cannot be solved in a reasonable time but approximations to the optimal solution can.</li>
                        <li><strong>EK 4.2.2D</strong> Some problems cannot be solved using any algorithm.</li>
                    </ul>
                </li>
                <li>
                	<strong>LO 4.2.3</strong> Explain the existence of undecidable problems in computer science. [P1]
                	<ul>
                        <li><strong>EK 4.2.3A</strong> An undecidable problem may have instances that have an algorithmic solution, but there is not algorithmic solution that solves all instances of the problem.</li>
                        <li><strong>EK 4.2.3B</strong> A decidable problem is one in which an algorithm can be constructed to answer "yes" or "no" for all inputs (e.g., "is the number even?").</li>
                        <li>
                        	<strong>EK 4.2.3C</strong> An undecidable problem is one in which no algorithm can be constructed that always leads to a correct yes-or-no answer.
                        	<ul>
                            	<li class="exclusion">EXCLUSION STATEMENT (for EK 4.2.3C): Determining whether a given problem is undecidable is beyond the scope of this course and the AP Exam.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                
                <div class="comment">LO 4.2.4 goes in Timing Experiments</div>
                <li>
                	<strong>LO 4.2.4</strong> Evaluate algorithms analytically and empirically for efficiency, correctness, and clarity. [P4]
                	<ul>
                        <li><strong>EK 4.2.4A</strong> Determining an algorithm's efficiency is done by reasoning formally or mathematically about the algorithm.</li>
                        <li><strong>EK 4.2.4B</strong> Empirical analysis of an algorithm is done by implementing the algorithm and running it on different inputs.</li>
                        <li>
                            <strong>EK 4.2.4C</strong> The correctness of an algorithm is determined by reasoning formally or mathematically about the algorithm, not by testing an implementation of the algorithm.
                            <ul>
                            	<li class="exclusion">EXCLUSION STATEMENT (for EK 4.2.4C): Formally proving program correctness is beyond the scope of this course and the AP Exam.</li>
                            </ul>
                        </li>
                        <li><strong>EK 4.2.4D</strong> Different correct algorithms for the same problem can have different efficiencies.</li>
                        <li><strong>EK 4.2.4E</strong> Sometimes, more efficient algorithms are more complex.</li>
                        <li><strong>EK 4.2.4F</strong> Finding an efficient algorithm for a problem can help solve larger instances of the problem.</li>
                        <li>
                            <strong>EK 4.2.4G</strong> Efficiency includes both execution time and memory usage.
                            <ul>
                            	<li class="exclusion">EXCLUSION STATEMENT (for EK 4.2.4G): Formal analysis of algorithms (Big-O) and formal reasoning using mathematics formulas are beyond the scope of this course and the AP Exam.</li>
                            </ul>
                        </li>
                        <li><strong>EK 4.2.4H</strong> Linear search can be used when searching for an item in any list; binary search can be used only when the list is sorted.</li>
                    </ul>
                </li>
                
                
                    <div class="comment">5.2 EKs go in Algorithms, Timing Experiments, and Unsolvable and Undecidable Problems</div>
                    <div class="comment">5.3 EKs go in Data Processing</div>
                <li>
                    <h4>EKs from 5.2.1 and 5.3.1 (LOs don't apply in U5)</h4>
                    <ul>
                    <li><strong>EK 5.2.1J</strong> Simple algorithms can solve a large set of problems when automated.</li>
                    <li><strong>EK 5.2.1K</strong> Improvements in algorithms, hardware, and software increase the kinds of problems and the size of problems solvable by programming.</li>
                    <li><strong>EK 5.3.1M</strong> Application program interfaces (APIs) and libraries simplify complex programming tasks.</li>
                    <li><strong>EK 5.3.1N</strong> Documentation for an API/library is an important aspect of programming.</li>
                    <li><strong>EK 5.3.1O</strong> APIs connect software components, allowing them to communicate.</li>
                    </ul>
                </li>
				
                <!-- move to U1/U2 (EKs: 5.2.1H in U1, yellow box; 5.3.1H in U3; 5.3.1J in new U4 lab; 5.3.1 N,O in U4 Weather)
                <li>
                	<strong>LO 5.2.1</strong> Explain how programs implement algorithms. [P3]
                    <ul>
                    	<div class="todo">
                            <strong>In this LO, but not suggested for U5 (should go in U2?):</strong>
                            <ul>
                                <li><strong>EK 5.2.1A</strong> Algorithms are implemented using program instructions that are processed during program execution.</li>
                                <li><strong>EK 5.2.1B</strong> Program instructions are executed sequentially.</li>
                                <li><strong>EK 5.2.1C</strong> Program instructions may involve variables that are initialized and updated, read, and written.</li>
                                <li><strong>EK 5.2.1D</strong> An understanding of instructions processing and program execution is useful for programming.</li>
                                <li><strong>EK 5.2.1E</strong> Program execution automates processes.</li>
                            </ul>
                        </div>
                        <li><strong>EK 5.2.1F</strong> Processes use memory, a central processing unit (CPU), and input and output.</li>
                        <li><strong>EK 5.2.1G</strong> A process may execute by itself or with other processes.</li>
                        <li><strong>EK 5.2.1H</strong> A process may execute on one or several CPUs.</li>
                        <li><strong>EK 5.2.1I</strong> Executable programs increase the scale of problems that can be addressed.</li>
                        <li><strong>EK 5.2.1J</strong> Simple algorithms can solve a large set of problems when automated.</li>
                        <li><strong>EK 5.2.1K</strong> Improvements in algorithms, hardware, and software increase the kinds of problems and the size of problems solvable by programming.</li>
                    </ul>
                </li>
				<li>
                	<strong>LO 5.3.1</strong> Use abstraction to manage complexity in programs. [P3]
                    <ul>
                        <li><strong>EK 5.3.1A</strong> Procedures are reusable programming abstractions.</li>
                        <li><strong>EK 5.3.1B</strong> A procedure is a named grouping of programming instructions.</li>
                        <li><strong>EK 5.3.1C</strong> Procedures reduce the complexity of writing and maintaining programs.</li>
                        <li><strong>EK 5.3.1D</strong> Procedures have names and may have parameters and return values.</li>
                        <li><strong>EK 5.3.1E</strong> Parameterization can generalize a specific solution.</li>
                        <li><strong>EK 5.3.1F</strong> Parameters generalize a solution by allowing a procedure to be used instead of duplicated code.</li>
                        <li><strong>EK 5.3.1G</strong> Parameters provide different values as input to procedures when they are called in a program.</li>
                        <li><strong>EK 5.3.1H</strong> Data abstraction provides a means of separating behavior from implementation.</li>
                        <div class="todo">
                            <strong>In this LO, but covered in U3:</strong>
                            <ul>
                                <li><strong>EK 5.3.1I</strong> Strings and string operations, including concatenation and some form of substring, are common in many programs.</li>
                            </ul>
                        </div>
                        <li><strong>EK 5.3.1J</strong> Integers and floating-point numbers are used in programs without requiring understanding of how they are implemented.</li>
                        <div class="todo">
                            <strong>In this LO, but covered in U3:</strong>
                            <ul>
                                <li><strong>EK 5.3.1K</strong> Lists and list operations, such as add, remove, and search, are common in many programs.</li>
                                <li><strong>EK 5.3.1L</strong> Using lists and procedures as abstractions in programming can result in programs that are easier to develop and maintain.</li>
                            </ul>
                        </div>
                        <li><strong>EK 5.3.1M</strong> Application program interfaces (APIs) and libraries simplify complex programming tasks.</li>
                        <li><strong>EK 5.3.1N</strong> Documentation for an API/library is an important aspect of programming.</li>
                        <li><strong>EK 5.3.1O</strong> APIs connect software components, allowing them to communicate.</li>
                    </ul>
                </li>-->
                
				<!-- move 5.5.1 LO, B, and C to U4 as new Representing Numbers lab (R| infinite and uncoutnable, Q| as pairs of integers)
                	move Booleans to U2L1 creating preicates and U1L5; 
                
                <li>
                    <strong>LO 5.5.1</strong> Employ appropriate mathematical and logical concepts in programming. [P1]
                    <ul>
                        <li>
                            <strong>EK 5.5.1B</strong> Integers may be constrained in the maximum and minimum values that can be represented in a program because of storage limitations.
                            <ul>
                                <li class="exclusion">EXCLUSION STATEMENT (for EK 5.5.1B): Specific range limitations of all programming languages are beyond the scope of this course and the AP Exam.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>EK 5.5.1C</strong> Real numbers are approximated by floating-point representations that do not necessarily have infinite precision.
                            <ul>
                                <li class="exclusion">EXCLUSION STATEMENT (for EK 5.5.1C): Specific sets of values that cannot be exact represented by floating point numbers are beyond the scope of this course and the AP Exam.</li>
                            </ul>
                        </li>
                    </ul>
                    <div class="todo">Other EKs in this LO appear in other units.</div>
                </li>-->
                
				<div class="comment">LO 7.1.2 goes in U5 Data Processing.</div>
                <li>
                    <strong>LO 7.1.2</strong> Explain how people participate in a problem-solving process that scales. [P4]
                    <ul>
                        <li><strong>EK 7.1.2A</strong> Distributed solutions must scale to solve some problems.</li>
                        <li><strong>EK 7.1.2B</strong> Science has been impacted by using scale and "citizen science" to solve scientific problems using home computers in scientific research.</li>
                        <li><strong>EK 7.1.2C</strong> Human computation harnesses contributions from many humans to solve problems related to digital data and the Web.</li>
                        <li><strong>EK 7.1.2D</strong> Human capabilities are enhanced by digitally enabled collaboration.</li>
                        <li><strong>EK 7.1.2E</strong> Some online services use the contributions of many people to benefit both individuals and society.</li>
                        <li><strong>EK 7.1.2F</strong> Crowdsourcing offers new models for collaboration, such as connected people with jobs and businesses with funding.</li>
                        <li><strong>EK 7.1.2G</strong> The move from desktop computers to a proliferation of always-on mobile computers is leading to new applications.</li>
                    </ul>
                </li>
                
				<div class="comment">
                    <p>We need a lab for LO 7.2.1. If not in U5, then where should it go? Only one EK "7.2.1C Computing enables innovation by providing the ability to access and share information" appears in anywhere else in the year so far (<a href="/bjc-r/cur/teaching-guide/U3/old/5-search.html?topic=nyc_bjc%2F3-teaching-guide.topic&course=bjc4nyc_2015-2016_teacher.html&novideo&noassignment">U3L5</a>). --MF</p>
                </div>
				<li>
                    <strong>LO 7.2.1</strong> Explain how computing has impacted innovations in other fields. [P1]
                    <ul>
                        <li><strong>EK 7.2.1A</strong> Machine learning and data mining have enabled innovation in medicine, business, and science.</li>
                        <li><strong>EK 7.2.1B</strong> Scientific computing has enabled innovation in science and business.</li>
                        <li><strong>EK 7.2.1C</strong> Computing enables innovation by providing the ability to access and share information.</li>
                        <li><strong>EK 7.2.1D</strong> Open access and Creative Commons have enabled broad access to digital information.</li>
                        <li><strong>EK 7.2.1E</strong> Open and curated scientific databases have benefited scientific researchers.</li>
                        <li><strong>EK 7.2.1F</strong> Moore's law has encouraged industries that use computers to effectively plan future research and development based on anticipated increases in computing power.</li>
                        <li><strong>EK 7.2.1G</strong> Advances in computing as an enabling technology have generated and increased the creativity in other fields.</li>
                    </ul>
                </li>
            </ul>
        </div>

        
	</body>
</html>