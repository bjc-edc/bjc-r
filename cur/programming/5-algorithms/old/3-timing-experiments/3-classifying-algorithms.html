<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 3: Timing Experiments, Page 3</title>
	</head>


	<body>
		<h2>Classifying Algorithms</h2>
        <div class="todo"><h2>BH and MF: keep page appended to end of 5.1.2 (page 3) with some yellowboxing the whitetext; drop #3-5; keep #7 and 6 in reversed order (need to say "unreasonable <em>for large inputs</em>"</h2></div>
		
		<!--<div class="todo">
            <ul>
                <li><strong>EK 4.1.1G</strong> Knowledge of standard algorithms can help in constructing new algorithms.</li>
                <div class="sidenote">LO 4.2.1 in #7</div>
                <li><strong>LO 4.2.1</strong> Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]</li>
                <li><strong>EK 4.2.1A</strong> Many problems can be solved in a reasonable time.</li>
                <li><strong>EK 4.2.1B</strong> Reasonable time means that the number of steps the algorithm takes is less than or equal to a polynomial function (constant, linear, square, cube, etc.) of the size of the input.</li>
                <li><strong>EK 4.2.1C</strong> Some problems cannot be solved in a reasonable time, even for small input sizes.</li>
                <li><strong>EK 4.2.1D</strong> Some problems can be solved but not in a reasonable time. In these cases, heuristic approaches may be helpful to find solutions in reasonable time.</li>
                <li><strong>EK 4.2.2A</strong> A heuristic is a technique that may allow us to find an approximate solution when typical methods fail to find an exact solution.</li>
                <li><strong>EK 4.2.2B</strong> Heuristics may be helpful for finding an approximate solution more quickly when exact methods are too slow.</li>
				<li><strong>EK 4.2.2C</strong> Some optimization problems such as 'find the best' or 'find the smallest' cannot be solved in a reasonable time, but approximations to the optimal solution can.</li>
                <div class="sidenoteBig">efficiency only: analytically FYTD #4 and empirically FYTD #3<br /> we can do "correctness" on the debugging page. --MF</div>
                <li><strong>LO 4.2.4</strong> Evaluate algorithms analytically and empirically for efficiency, correctness, and clarity. [P4]</li>
                		
			</ul>
		</div>-->
        
        <div class="todo">
            <strong>Brian</strong>, after we review my changes below, we should address both of these:
            <ul>
            	<li>There is a lot of commented-out content on this page. If it's not needed, it should be removed. --MF, 12/20/17</li>
            </ul>
        </div>
        
        <div class="todo">
            <p>PG: Scrap. If AP still requires it, we must, but I'm not in love with this.</p>
            <p>BH: Item 87 of isn't a great example, even though true, because the time depends on how the list was constructed.  Also, add n log n.</p>
            <p>MF: so much text; I think we are overdoing this idea. Much could be yellowboxed.</p>
        </div>
        
        <div class="learn">
        	<p><strong>On this page</strong>, you will learn that some correct algorithms take too long to be practical.</p>
        </div>
		
        <div class="forYouToDo" id="first">
            <ol>
                <li>
                    <div class="todo">This <em>feels</em> repetitive even though the task actually isn't. --MF, 3/11/19</div>
                	If it isn't already open, load the project U5L3-timer from the previous page. You will be experimenting with <code>time function</code> with each of these input functions: 
                	<ul>	
                        <li><img src="/bjc-r/img/3-lists/U3ImageVideoAddendum_img/Graph datapoints.png" height="40" alt="Graph datapoints: ()" title="Graph datapoints: ()"/> (as you saw on <a href="/bjc-r/cur/programming/3-lists/old/4-graphing/2-building-a-grapher.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment" title="Unit 3 Lab 4: Building a Graphing App">Unit 3 Lab 4: Building a Graphing App</a>)</li>
                        <li><img src="/bjc-r/img/5-algorithms/distinctelements.png" alt="are the numbers in () distinct?" title="are the numbers in () distinct?" /> (as you saw on <a href="/bjc-r/cur/programming/5-algorithms/1-searching-lists/7-comparing-search-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic" title="Unit 5 Lab 1: List Processing Algorithms">Unit 5 Lab 1: List Processing Algorithms</a>)</li>
                        <li><img class="" src="/bjc-r/img/5-algorithms/numbers-from-to.png" alt="numbers from () to ()" title="numbers from () to ()" /> (as you saw on <a href="/bjc-r/cur/programming/5-algorithms/old/3-timing-experiments/1-comparing-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic" title="Unit 5 Lab 3: Comparing Algorithms">Unit 5 Lab 3: Comparing Algorithms</a>)</li>
                    </ul>
					For each one, what happens to the running time if you double the size of the input? 
                    <div class="endnote">What does it mean to double the size of the input for <code>numbers from () to ()</code>?</div>
                </li>
            </ol>
        </div> 
        
<!--		
        <p>
            It would be nice to create a data-plot of the average time it takes a reporter to ouput, given a list of inputs. To do this, you'll want to create a list. The reporter <code> make a list of times for a reporter between two inputs </code> creates such a list. Here's how it looks in action:<br />
            <a class="run" href="/bjc-r/prog/5-algorithms/U5L3avtime.xml"><img class="indent" src="/bjc-r/img/5-algorithms/listtimes.png" alt="average alphie" title="average alphie" /></a>
        </p>
        
        <div class="sidenote">You can create the block for yourself. Try it. Or you can click to load a pre-programmed version.</div>
        
        <p>
            What's happened here is that Morgan's reporter (adding the numbers between 1 and some upper limit) was applied to upper limits between  100 and 10000, and <code>average time</code>'d along the way.  The input 2 specifies what "along the way" means:  these special inputs start with 100 and are multiplied by 2 until you get the largest multiple less than 10000:<br />
            <table class="bordered center">
                <tr>
                    <td>100</td>
                    <td>200</td>
                    <td>400</td>
                    <td>800</td>
                    <td>1600</td>
                    <td>3200</td>
                    <td>6400</td>
                </tr>     
            </table>
        </p>
            
        <div class="forYouToDo">
            <ol start="2">
            	<li>Experiment with <code>make a list of times for a reporter between two inputs</code>. Try different reporters that you've built as inputs and vary the other inputs  (for example instead of 2, try 1.5, 1.1, and so on). </li>
            </ol>
        </div>
        
        <div class="takeNote">Because <code>make a list for a reporter between two inputs</code> often takes a long time to compute its output (think about what it's doing) you may want to store   outputs for various reporters in variables so that you can use them later. The reason that the last input multiplies by a factor (rather than making a constant increment) is so that you can get a large range of inputs without having to time the reporter on too many of them.</div>       
        
        <div class="forYouToDo">       
            <p>One way to analyze algorithms is to  use the <code> graph data points</code> package from U5L2 to plot the run time against the size of the input and to classify the reporters by the shape of the plots.</p>
            <ol start="3">
				<img class="imageRight" src="/bjc-r/img/5-algorithms/alphiepict.png" alt="" title="" />
            	<li>Try it.  Create a data plot of the reporters you timed in the problem above: Pick a reporter and make a data-plot for the output of <code>make a list for a reporter between two inputs</code>.</li>
            </ol> 
        </div>
		-->

        <p>You can classify algorithms by the amount of time they take to run.</p>
        <div class="forYouToDo">
            <ol start="2">
                <li>
                   <a class="run" href="/bjc-r/prog/5-algorithms/U5L3-listfrom.xml" target="_blank"><img class="inline" src="/bjc-r/img/icons/load-save.png" alt="Click here to load a starter project. Then save it." title="Click here to load a starter project. Then save it."></a><br />Use the <img src="/bjc-r/img/5-algorithms/listfrom.png" alt="list from () to ()" title="list from () to ()" /> block to build the following two blocks in Snap<em>!</em>. Then, determine which block's algorithm can be executed in a reasonable time, and which cannot.
                    <div class="sidenote">The list of 2-digit numbers goes from 10 to 99. There's a math operations block that can give you powers of 10.</div>
                    <ol>
                        <li><img src="/bjc-r/img/5-algorithms/1000numbers.png" alt="1000 numbers starting from ()" title="1000 numbers starting from ()" /></li>
                        <li><img src="/bjc-r/img/5-algorithms/digitnumbers.png" alt="all () digit numbers" title="all () digit numbers" /></li>
                    </ol>
                </li>
            </ol>
        </div>	


        <div class="todo">
            <p>I want to put the two definitions in vocab box(es) and to yellowbox-hint all the efficiency categories. --MF, 9/26/18</p>
            <p>BH and MF agreed to focus on polynomial vs. exponential and on clarifying what exponential means (since many people get it wrong), and then to say, oh BTW, the college board calls this reasonable and unreasonable. --MF, 3/22/19</p>
        </div>
        <p>
            To classify an algorithm, look at the number of steps it takes to complete the algorithm, compared to the size of the input.
            <ul>
                <li>
                    <strong>Reasonable Time:</strong> If the number of steps is less than or equal to a power of the size of the input, then the algorithm takes <em>polynomial time</em>.
                    <!--<ul>
						<li>Some algorithms always take the same number of steps, even as the input grows. These algorithms take <em>constant time</em>.</li>
                        <li>Some algorithms take a number of steps proportional to the input size. <!--(If you double the size of the input, the number of steps doubles also.)- -> These algorithms take <em>linear time</em>. <!--A linear search of a list is an example.- -></li>
                        <li>Some algorithms take a number of steps more than constant but less than linear. These algorithms take <em>sublinear time</em>. <!--A binary search is an example.- -></li>
                        <li>If the number of steps is less than or equal to a power of the size of the input, then the algorithm takes <em>polynomial time</em>.</li>
                    </ul>-->
                    <p>
                        <em>Polynomial time</em> includes constant (<em>n</em><sup>0</sup>), sublinear, linear (<em>n</em><sup>1</sup>),  quadratic (<em>n</em><sup>2</sup>), cubic (<em>n</em><sup>3</sup>), etc. functions:
                        <!--In constant time algorithms, changing the size of the input does not change the number of steps. In linear time algorithms, changing the size of the input changes the number of steps by the same amount. In quadratic time algorithms, doubling the size of the input quadruples the number of steps, and trippling the size of the input 9-tuples the number of steps.--> 
                        <table class="bordered" summary="list of several reasonable time efficiencies">
                            <tr>
                                <th scope="col" style="width:20%;">algorithm efficiency</th>
                                <th scope="col" style="width:40%;">If you double the size of input,<br />the time... </th>
                                <th scope="col" style="width:40%;">example algorithm</th>
                            </tr>
                            <tr>
                                <td>constant</td>
                                <td>stays the same (multiplies by 2<sup>0</sup> which is 1)</td>
                                <td><code>item (</code><var>87</var><code>) of ()</code></td>
                            </tr>
                            <tr>
                                <td>sublinear</td>
                                <td>multiplies by some number between 1 and 2 (between 2<sup>0</sup> and 2<sup>1</sup>)</td>
                                <td>binary search: <code>position of () in sorted list</code></td>
                            </tr>
                            <tr>
                                <td>linear</td>
                                <td>multiplies by 2 (which is 2<sup>1</sup>)</td>
                                <td>linear search: <code>position of () in unsorted list</code></td>
                            </tr>
                            <tr>
                                <td>quadratic</td>
                                <td>multiplies by 4 (which is 2<sup>2</sup>)</td>
                                <td>some kinds of sorting algorithms</td>
                            </tr>
                            <tr>
                                <td>cubic</td>
                                <td>multiplies by 8 (which is 2<sup>3</sup>)</td>
                                <td>some gene mapping algorithms used in biology</td>
                            </tr>
                        </table>
                    </p>
                    <p>It's rare to find polynomial time algorithms that take more than cubic (<em>n</em><sup>3</sup>) time.</p>
                    <div class="endnote">
                        <p><a href="#hint-between-categories" data-toggle="collapse" title="What if an algorithm takes an amount of time that's between two categories?">What if an algorithm takes an amount of time that's <em>between</em> two categories?</a></p>
                        <div id="hint-between-categories" class="collapse">These categories say that an algorithm takes <em>at most</em> so much time.  So, for example, a constant-time algorithm is also a linear-time algorithm, and also a polynomial-time algorithm<!--, and also an exponential-time algorithm-->.  But <em>usually</em> if someone says an algorithm "takes quadratic time," they mean that it takes <em>more than</em> linear time but <em>not more than</em> quadratic time.</div>
                    </div>
                </li>
                <li>
                    <strong>Unreasonable Time:</strong> If the number of steps is more than any power of the size of the input (that is, more than any polynomial function<!--, such as an <em>exponential</em> function, 2<sup><em>n</em></sup>-->), then the algorithm takes an <em>unreasonable</em> amount of time.
					<div class="endnote">The classic example of an <em>unreasonable time</em> algorithm is one that takes <em>exponential</em> (2<sup><em>n</em></sup>) <em>time</em>. Just <em>adding 1</em> to the input size (<em>n</em>) <em>doubles</em> the number of steps! <!--Examples of exponential time algorithms include climate models or models of molecular physics.--></div>
                    <!--<ul>
                        <li>If the number of steps is an <em>exponential</em> function of the size of the input (or another function larger than any polynomial), we say that the algorithm takes an <em>unreasonable</em> amount of time. For an algorithm that takes 2<sup><em>n</em></sup> time, just <em>adding 1</em> to the input size (<em>n</em>) <em>doubles</em> the number of steps!</li>
                    </ul>-->
			        <p>One kind of problem whose solution often ends up unreasonable is an <em>optimization</em> problem (such as "find the best" or "find the smallest"). </p>
                </li>
            </ul>
        </p>
		<div class="takeNote">
            <div class="todo">This feels more important than we are giving time for. --MF, 3/11/19</div>
            It's important to recognize that an unreasonable-time algorithm <strong>still solves a problem correctly</strong>. Unreasonable-time algorithms can sometimes be replaced by <em>heuristics</em>, which are polynomial-time algorithms that don't solve the problem exactly, but give a good enough approximation.</div>
        <div class="comment">Yellowbox-Hint this too. --MF, 9/26/18</div>
        <p>One reason it's worth learning these categories is that in writing programs, you often need to solve a problem for which there are already established solutions. For example, you've learned that searching for something in an unordered list takes linear time, but if the list is sorted, you can search it faster (in sublinear time).  So when you're writing a program that needs to search through a list repeatedly, you'll know that it's worthwhile to sort the list before the searching. Knowing about standard algorithms that already exist can help you construct new algorithms.</p>
        
        
        <div class="forYouToDo">
            <ol start="3">
                <div class="todo">No one is going to do this. We need more direction. --MF, 3/11/19</div>
            	<li>Look at some algorithms you've built. Determine whether each algorithm runs in constant time, sublinear time, linear time, quadratic time, or unreasonable time.</li>
		    </ol>
        </div>
        
        <div class="ifTime">
            <ol start="4">
                    <div class="todo">Need to decide what to do here since the graphing labs are being replaced. --MF, 3/11/19</div>
                <li>For Morgan's way of adding integers, create a graph with the number of integers on the horizontal and the runtime on the vertical. Generate data for the graph by running <code>time function</code> with large inputs to <code>Morgan's way</code> (say, multiples of 100). Then use the techniques from Lab 2 to plot the graph.</li>
                <li>What information does this graph tell you about Morgan's algorithm? Is it constant time, linear time, other polynomial time, or is it unreasonable time?</li>
            </ol>
        </div>
        <div class="todo">Do we need all the commented out content here and elsewhere on this page? --MF, 9/26/18</div>
<!--
            	<li>
                	The plot is not a line. There are several ways this can happen:
                	<ol>
                    	                       
                        <li>The plot looks close to the graph of a polynomial function (roughly like the graph of <span class="katex">y = x^n</span> for some positive integer <span class="katex">n</span>). This is called <em>polynomial time</em>.</li>
                        <li>The plot looks close to the graph of an exponential function, like <span class="katex">x \rightarrow 2^x</span> Guess what this kind of timing behavior is called. 
                        </li>
                        <li>There's  another kind of run-time that comes up often&#8212;you saw it when you looked at binary searches (like the guessing game). You'll analyze this type of reporter later in this lab. <div class="comment">Put a link here to page U5L1P2</div></li>
                    </ol>
                </li>
            </ul>
        </p>
        -->
        <div class="forYouToDo">
			<ol start="6">
                <div class="todo">I suggest swapping the order of these two problems so that the paragraph writing isn't lost and also so that idea is closer to the content about it (rather than having a big block of slightly less conected content in between. --MF, 3/11/19</div>
				<li>
                    This question is similar to those you will see on the AP CSP exam.
                    <!-- Question 1 -->
                    <div class="assessment-data" type="multiplechoice" identifier="Timing of database tasks"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="true">
                        <div class="prompt">
                            The table below shows the computer time it takes to complete various tasks on the data of different sized towns.
                            <p>
                                <table class="bordered" summary="hours required for various data management tasks for towns of various sizes">
                                    <tr>
                                        <th scope="col">Task</th>
                                        <th scope="col">Small Town<br />(population 1,000)</th>
                                        <th scope="col">Mid-sized Town<br />(population 10,000)</th>
                                        <th scope="col">Large Town<br />(population 100,000)</th>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Entering Data</th>
                                        <td>2 hours</td>
                                        <td>20 hours</td>
                                        <td>200 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Backing up Data</th>
                                        <td>0.5 hours</td>
                                        <td>5 hours</td>
                                        <td>50 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Searching through Data</th>
                                        <td>5 hours</td>
                                        <td>15 hours</td>
                                        <td>25 hours</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Sorting Data</th>
                                        <td>0.01 hour</td>
                                        <td>1 hour</td>
                                        <td>100 hours</td>
                                    </tr>
                                </table>
                            </p>
                            Based on the information in the table, which of the following tasks is likely to take the <em><strong>longest</strong></em> amount of time when scaled up for a city of population 1,000,000.
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">Entering data</div>
                            <div class="feedback">
                                <!--Entering data seems to take <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-entering-data.jpg" alt="population/1000" title="population/1000" /> hours, so for a population of 1,000,000, it should take about 2,000 hours.-->
                                As the population size is multiplied by 10, the time needed for entering data is also multiplied by 10, so for a population of 1,000,000, it should take about 10&times;200=2000 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">Backing up data</div>
                            <div class="feedback">
                                <!--Backing up data seems to take about <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-backing-up.jpg" alt="5^((population/1000)-1)" title="5^((population/1000)-1)" /> hours, so for a population of 1,000,000, it should take about 125 hours.-->
                                As the population size is multiplied by 10, time needed for backing up data is multiplied by 10, so for a population of 1,000,000, it should take about 10&times;50=500 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">Searching through data</div>
                            <div class="feedback">
                                Searching through the data seems to go up by about 10 hours each time the population is multiplied by 10, so for a population of 1,000,000, it should take about 35 hours.
                            </div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">Sorting data</div>
                            <div class="feedback">
                                Correct! <!--Sorting the data seems to go up exponentially as the the population grows. For a population of 1,000,000, it should take about 10,000 hours.-->  As the population size is multiplied by 10, the time needed for the sorting of data is multiplied by 100.  So, for a population of 1,000,000, it should take about 100&times;100=10,000 hours.
                            </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri1">
                            <div class="correctResponse" identifier="c4"></div>
                        </div>
                    </div>
                </li>
                <li>Write a paragraph explaining the difference between algorithms that run in a reasonable time and algorithms that require unreasonable time to run.</li>
			</ol>
		</div>
		

	</body>
</html>