<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 4: Unsolvable and Undecidable Problems, Page 2</title>
	</head>

	<body>
		<h2>An Undecidable Problem</h2>

    <img class="imageRight" src="/bjc-r/img/5-algorithms/turing.jpg" alt="Alan Turing">
    <p>Alan Turing
	(1912-1954) was one of the founders of computer science. He is known today mainly for two achievements. First, he made a massive contribution to winnng World War II, by inventing a mathematical theory and its implementation in actual hardware to break the secret coded messages generated by the German Enigma coding machine. From 1939 to the end of the war, he was the leader of a secret team at Bletchley Park, England, devoted to breaking Enigma and other German codes. The knowledge of German plans that this gave England was crucial to the Allied victory.
    <p>But in this unit it's his second achievement that matters to us. Turing, along with his colleague Alonzo Church, was the founder of <em>theoretical</em> computer science: proving things about how computers <em>must</em> work, regardless of advances in technology.  He proved that there are computations that can <em>never</em> be done, no matter how big and fast the computers get.    
    <h3>The Halting Theorem</h3>
    <p>Keep in mind that when Turing did this work, there were no programmable computers; people had to rewire the parts of the physical machine in order to solve a new problem. Today, with high level programming languages, you can see and understand the essence of Turing's proof much more easily than he could work it out.</p>
    <p>By this point in the course you've experienced the frustration of debugging a program. Wouldn't it be great if there were a general-purpose debuging program that could read your code and find all the bugs? Turing proved that this can't be done. In particular, it's not possible to find all <em>infinite loops</em> in a program&mdash;situations in which you call a function with a particular input, and the function runs forever, without reporting a value.</p>
    <p>Turing used a <em>proof by contradiction,</em> just like Alphie, Betsy, and Gamal on the previous page. They proved that Eve has to be a Truth-teller by assuming the opposite, that she's a False-teller, and showing that that leads to a contradiction.</p>
    <p>Similarly, Turing started by assuming he had a predicate function</p>
    <p><img src="/bjc-r/img/5-algorithms/halts.png" alt="halts? (function) (input)"></p>
    <p>that takes two inputs, a function and an input value for that function, and reports <code>True</code> if the function would report a value, or <code>False</code> if the function would run forever. (Note that <code>halts?</code> itself can't run forever! We are assuming that it always works, reporting an answer in a finite amount of time.)</p>
    <p>Turing then defined this function:</p>
    <p><img src="/bjc-r/img/5-algorithms/tester-halting.png" alt="tester(function)"></p>
    <p>Look at the <code>halts?</code> block in the definition. Turing is asking what happens if we call some function with <em>iteself</em> as its input.  This is similar to Betsy making a statement about &quot;this statement&quot; (namely, &quot;this statement is false&quot;). This is easy to do in Snap<em>!</em> because it allows functions as inputs to other functions, as you saw in Unit 3.  It wasn't easy for Turing, who had to invent the idea of a computer <em>program</em> that can itself be represented as data inside the computer.
<p>Turing then asked a question that makes the situation <em>exactly</em> like what Betsy said; he calls tester on <em>itself:</em>    
    <p><img src="/bjc-r/img/5-algorithms/testertester.png" alt="teter(tester)">
    
    <p>If <code>halts?</code> says that <code>tester</code> halts, <code>tester</code> makes sure not to halt! But if <code>halts?</code> says that <code>tester</code> <em>doesn't</em> halt, then <code>tester</code> immediately reports <code>True</code>. (It doesn't actually matter what value <code>tester</code> reports in this case; what's important is that it doesn't loop forever.)
    <p>So whatever <code>halts?</code> reported must be wrong.  But it's never supposed to make mistakes. So the assumption that we can write <code>halts?</code> has to be wrong! Turing's &quot;halting problem&quot; has been proven to be impossible.
    <p>This proof is of practical importance; because of it, nobody tries to write a perfect infinite loop checker. But that's not what mattered to Turing. He just used this example to prove something more general, namely, <strong>there are functions that can't be computed.</strong>
This isn't just a claim about the particular computers that existed in Turing's time, or today. Even when they invent magic quantum hyperspace computers (I have no idea what that phrase would even mean), they <em>still</em> won't be able to solve the halting problem.
	</body>
</html>
