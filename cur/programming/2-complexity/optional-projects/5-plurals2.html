<!DOCTYPE html>
<html lang="en">
    <head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <title>Unit 2 Optional Projects, Page 5</title>
    </head>

    <body>
		<h2>Modeling Language: Plurals, Part 2</h2>
        <div class="todo">Need to redo KEEP images. --MF, 6/27/20</div>
        <div class="todo">
            <ul>
                <li>REVISION NOTE: Students EXTEND their  <strong>list</strong> of nouns as needed. At each testing stage, have them <strong>map</strong> their &quot;specialist block&quot; or their <strong>plural </strong>block over the entire list and note which words are and aren't correctly pluralized.</li>
                <li>Rebuild the images without white backgrounds. --MF</li>
            </ul>
		</div>
        <div class="todo">
            <p>BH: Add a TIF in which they use a list of suffixes and expressions and then do a FOR EACH ITEM…</p>
            <p>MF: Need to revise to follow Modeling Langauge in U1</p>
        </div>
        
        <p>You can improve <code>plural</code> to work correctly with more words. If the project is not already open, please reload it. (The suggested file name was <code>U2-Plural</code>.)  </p>
           
        <div class="forYouToDo" id="first">
			<ol>      
				<li> 
                    <strong>Abstraction: </strong> Make a <img src="/bjc-r/img/2-complexity/plural_h.png" alt="plural-h" title="plural-h"> block that "specializes" on just one category, words that end with the letter <strong>h</strong>.
                    <ul>
                    	<li>Start with a <code>list</code> of the words you want it to work for.</li>
                        <li>This specialist block should work correctly for words that fit its specialty <img src="/bjc-r/img/2-complexity/plural_h-crutch-with-result.png" alt="plural (for words ending with h) with correct  result for the word crutch" title="plural (for words ending with h) with correct  result for the word crutch"> <img src="/bjc-r/img/2-complexity/plural_h-moth-with-result.png" alt="suffix s (for words ending in h) with result for moth" title="suffix s (for words ending in h) with result for moth">, <img src="/bjc-r/img/2-complexity/plural_h-bush-with-result.png" alt="plural (for words ending in h) with result" title="plural (for words ending in h) with result">. It can be completely wrong about words that <em>don't</em> fit its specialty <img src="/bjc-r/img/2-complexity/plural_h-mouse-with-(wrong)result.png" alt="plural (for words ending with h) with wrong result for mouse (wrong input)" title="plural (for words ending with h) with wrong result for mouse (wrong input)"> because the <code>plural</code> block should never give words to <code>plural-h</code> unless those words end with <strong>h</strong>. </li>
                        <li>Test <img src="/bjc-r/img/2-complexity/plural_h.png" alt="plural-h" title="plural-h" > with a variety of words to make sure it works the way you want. Then use <code>map</code> to test it on the entire <code>list</code> you made earlier.</li>
                    </ul>
                   
                </li>
                <div class="takeNote">
                	<p><strong>Abstraction: </strong> Language often has special cases. In English, the plurals ofsome nouns add  <em>s</em>;  some   add  <em>es</em>;  nouns like <em>calf</em> and <em>fly</em> become <em>calves</em> and <em>flies</em>, changing their final letters before adding <em>es</em>. And more. For a programming task this complex, it's (generally) best to break it into parts, handle each part separately with its own procedure (its own block), and then have the "top-level" block—in this case, <code>plural</code>, itself—use those specialists. That is, instead of coding every little detail directly in <code>plural</code>, it is cleaner and clearer to make <code>plural</code> look something like this.</p>
                   <p><img class="indent noshadow" src="/bjc-r/img/2-complexity/plural-abstract-definition.png" alt="abstract definition of plural: if h = last letter of word, report h-case plural; if y = last letter of word, report y-case plural; if some other case, use a block that specializes in that case; etc.; else report join word s" title="abstract definition of plural: if h = last letter of word, report h-case plural; if y = last letter of word, report y-case plural; if some other case, use a block that specializes in that case; etc.; else report join word s"></p>
                    <p>Showing<a name="abstraction" class="anchor">&nbsp;</a>the <em>structure</em> of the method—just the overall strategy—in the "top-level" block and leaving the details to  separate blocks is one part of an important computer science idea called <strong>abstraction</strong>. Abstraction keeps your code clear, readable, and more easily debugged. It will also help your code be more flexible. </p>
				</div>
				<li> When you trust your new specialist block, edit <code> plural</code> to use the specialist. Test (you can use <code>map</code>) to make sure <code>plural</code> still works for all the words it used to work for, as well as the new ones.</li>
				<li> Create <code>plural-y</code> to handle words like 
					<img src="/bjc-r/img/2-complexity/plural_y-tray-with-result.png"  alt="plural_y-tray-with-result" title="plural_y-tray-with-result"> and
					<img src="/bjc-r/img/2-complexity/plural_y-sky-with-result.png" alt="plural_y-sky-with-result" title="plural_y-sky-with-result">
				</li>
				<p>Remember, any specialist can make mistakes if it's asked to do a job that isn't its  specialty. <img src="/bjc-r/img/2-complexity/plural_y-mouse-with-(wrong)result.png" alt="plural_y-mouse-with-(wrong)result" title="plural_y-mouse-with-(wrong)result"> </p>
				<p>Make sure  <code>plural</code> gives it only the job it knows how to handle correctly.</p>
		        <img class="imageRight" src="/bjc-r/img/icons/save-now.png" alt="Save your work" title="Save your work" />
			</ol>
</div>
    
    
        <div class="takeItFurther">
	    <div class="comment">I'm not thrilled with the way this pushes a particular
		implementation for a reason that's hidden until they get
		there, and doesn't make sense on its own.  bh</div>
            <ol type="A"> 
                <li>Because you know what  <img src="/bjc-r/img/2-complexity/keep-items-such-that-(last-letter-of-(input)-equals-h)-from-test-list.png" alt="keep-items-such-that-(last-letter-of-(input)-equals-h)-from-test-list" title="keep-items-such-that-(last-letter-of-(input)-equals-h)-from-test-list"> does, you can, if you like, use just <em>that</em> specialized list as input to a test of plural or plural-h, this way.<img src="/bjc-r/img/2-complexity/map-plural(with-input)-over-(keep-items-such-that-(last-letter-of-(input)-equals-h)-from-test-list).png" alt="map-plural(with-input)-over-(keep-items-such-that-(last-letter-of-(input)-equals-h)-from-test-list)" title="map-plural(with-input)-over-(keep-items-such-that-(last-letter-of-(input)-equals-h)-from-test-list)"></li>
                <li>Extend <code>plural</code> to handle another special case. Use a special-purpose block for your special case to  keep <code>plural</code> from becoming cluttered.</li>
                <li>Right now, if <code>plural</code> is given a word with a space at the end, it leaves that space in the plural, like this: <img src="/bjc-r/img/2-complexity/plural-bulldog[space]-with-result(bulldog[space]s).png" alt="plural of bulldog with space at the end, and result with space before s" title="plural of bulldog with space at the end, and result with space before s">. Figure out how to handle this special case and edit <code>plural</code> so that the result is <img src="/bjc-r/img/2-complexity/plural-bulldog[space]-with-result(bulldogs).png" alt="plural of bulldog with space at the end, and correct result, no space before s" title="plural of bulldog with space at the end, and correct result, no space before s">. You  already have a block that <em>specializes</em> in making plurals of words that <em>don't</em> have a space at the end. <em>Use</em> it.</li>
                <li><strong>Surprise!</strong> Once <code>plural</code> works for a single space at the end of a word, try giving it <img src="/bjc-r/img/2-complexity/plural-bulldog[four-spaces].png" alt="plural of bulldog with four spaces at the end" title="plural of bulldog with four spaces at the end">. That works too! But why?</li>
		<li>Does your <code>plurals</code> block still feel cluttered, even though the details about how to handle each possible last letter are abstracted into <code>plural-</code><em>letter</em> blocks?  One way to improve on this situation is to use another kind of abstraction called <em>data-directed programming.</em>
		<ul>
		  <li>Start by making a list of <em>key-value pairs</em>, with last letters as the keys and specialist procedures as the values:<br />
		    <img src="/bjc-r/img/2-complexity/plural-specialists-list.png" alt="set (plural-specialists) to (list (list (h) (ringed plural-h ( ) block)) (list (y) (ringed plural-y ( ) block)) (list (f) (ringed plural-f ( ) block)) (list (x) (ringed (join ( ) (es)) block)) (list (...) (...)))" title="set (plural-specialists) to (list (list (h) (ringed plural-h ( ) block)) (list (y) (ringed plural-y ( ) block)) (list (f) (ringed plural-f ( ) block)) (list (x) (ringed (join ( ) (es)) block)) (list (...) (...)))" /><br />
		  To make the second item of each small list, find the block you want, put it in the second input to <code>list</code>, then right-click on the block and choose "ringify."  As the <code>x</code> example shows, it doesn't have to be a block named <code>plural-</code>something.  It just has to have an empty input slot where you want the word to go.</li>
		  <li>Then in your <code>plural</code> procedure you can replace most of the <code>if</code> blocks with<br />
		  <img src="/bjc-r/img/2-complexity/plural-specialist-dispatch.png" alt="script variables (pair); set (pair) to (find first item (ringed ((item (1) of ( )) = (last letter of (word)))) in (plural specialists)); if (is (pair) a (list)?) {report (call (item (2) of (pair)) with inputs (word))}" title="script variables (pair); set (pair) to (find first item (ringed ((item (1) of ( )) = (last letter of (word)))) in (plural specialists)); if (is (pair) a (list)?) {report (call (item (2) of (pair)) with inputs (word))}" /><br />
		  The <code>call</code> block in the palette doesn't include the "<code>with inputs</code>" in the picture; when you click on its right arrowhead, those words will appear along with an input slot.  The <code>call</code> block's first input slot is the empty gray ring, which means that <code>call</code> wants a block in that input slot.  When you drag <code>item 2 of </code><var>pair</var> into that slot, the ring remains around it.  That's usually what we want when using <code>call</code>, but not this time.  Right-click on the <code>item</code> block and choose "unringify" from the menu.  Use this code in your <code>plural</code> block, replacing all of the last-letter tests.  Isn't that better?  Experiment with <code>call</code> to see what else you can do with it.  What happens if you don't unringify the <code>item</code> block?  What happens if you leave out the "with inputs" input to <code>call</code>?</li>
		  <li>There's no reason the keys have to be single letters.  Modify the code in <code>plural</code> so that it tests all <em>trailing substrings</em> of the word against the specialist list.  That is, if the word is "ditch,"  you'd look in the specialist list for "ditch," then for "itch," then "tch," "ch," and finally, if nothing else is found, "h."  You'd put<br />
		   <img src="/bjc-r/img/2-complexity/ch-dispatch.png" alt="list (ch) (ringed block (join ( ) (es)))" title="list (ch) (ringed block (join ( ) (es)))" /><br />
		  in the list, and then words ending "ch" would have "es" added.  This mechanism is very general; it works even for special cases such as<br />
		  <img src="/bjc-r/img/2-complexity/child-dispatch.png" alt="list (child) (ringified (word (children)))" title="list (child) (ringified (word (children)))" /><br />
		  (You'll have to define the <code>word</code> function that just reports its input; it's needed because you can't type letters directly into a ring.)  <em>Now</em> you have a <em>really</em> uncluttered <code>plural</code> block.  And it'll even work for a language other than English, if you make a different specialist list.</li>
		  <li>If you modify the trailing-substring test so that instead of giving up if it can't find the last letter of the word as a key, it goes one step further and looks for an <em>empty</em> key in the specialist list, and you add<br />
		  <img src="/bjc-r/img/2-complexity/default-dispatch.png" alt="(item ( ) (ringed (join ( ) (s))))" title="(item ( ) (ringed (join ( ) (s))))" /><br />
		  to the list, you can be sure that every possible word will match that, if nothing else, so you don't need the <code>if</code> any more.  Your <code>plural</code> block can now be a one-liner, <code>report (call (item 2 of (longest trailing substring ...</code>.</li>
		  <li>Still up for more?  Modify your trailing-substring test so that a plus sign in the key matches any vowel, so you can do this:<br />
		  <img src="/bjc-r/img/2-complexity/match-vowels.png" alt="list (...) (list (+y) (ringed (join ( ) (s)))) (list (y) (ringed (join (all but last letter of ( )) (ies)))) (...)" title="list (...) (list (+y) (ringed (join ( ) (s)))) (list (y) (ringed (join (all but last letter of ( )) (ies)))) (...)" /></li>
	      </ul>
            </ol>
			<img class="inline" src="/bjc-r/img/icons/save-now.png" alt="Save your work" title="Save your work" />
		</div>
       
        
    </body>
</html>



