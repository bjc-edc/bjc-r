<!DOCTYPE html>
<html lang="es">
	<head>
		<meta charset="utf-8">
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unidad 8 Proyecto opcional: Ordenar, Página 1</title>
	</head>

    <body>
        <h2>Ordenar una lista</h2>
        <div class="sidenote">Estos eran los 8 nombres de niña más frequentes en los EE. UU. en el 2014.</div>
        <p>
        	Supongamos que tenemos una lista de nombres que queremos <strong>ordenar</strong> alfabéticamente (ascendente):<br />
	        <div class="sidenoteBig">Estos pueden ser números en lugar de nombres o cualquier cosa que se pueda comparar y ordenar. A menudo es necesario ordenar números y palabras en una misma lista.</div>
        	<img class="indent" src="/bjc-r/img/8-recursive-reporters/unsortednames.png" alt="ocho nombres" title="ocho nombres" />
            <span class="big">&rarr;</span>
            <img src="/bjc-r/img/8-recursive-reporters/sortednames.png" alt="ocho nombres, ordenado" title="ocho nombres, ordenado" />
		</p>
        <div class="forYouToDo" id="first">
            <ol>
                <div class="sidenote"> Intenta describir el algoritmo con suficiente detalle para que otra persona pueda usar tu descripción para ordenar una lista.</div>
                <li>
                    <strong>Diseña</strong> un algoritmo <em>recursivo</em> para ordenar los nombres.
                    <ul>
                        <li>Primero considera tu estrategia general; cómo <em>tú</em> clasificarías un grupo de nombres, paso a paso.</li>
                        <li>Luego considera cómo le dirías a <em>una computadora</em>, que no es tan inteligente como tú y solo puede realizar procedimientos específicos, cómo ordenar una lista.</li>
                    </ul>
                </li>
                <li>Ahora <strong>construye</strong> tu algoritmo: una <code>ordenación reportera</code> toma una lista como entrada y genera una nueva lista de los mismos elementos en orden alfabético. Prueba tu algoritmo usando nombres y números.</li>
                <div class="endnote">
                    La comparación de números y cadenas se puede hacer usando los mismos bloques, por lo que tu algoritmo de clasificación debería funcionar igualmente bien para nombres y números.<br />
                    <!-- TODO: Translate image's boolean statements?
                    </div> -->
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/abigailava.png" alt="(Abigail)<(Ava) reporta verdadero"  title="(Abigail)<(Ava) reporta verdadero"  />
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/num-lessthan.png" alt="(7)<(3) reporta falso"  title="(7)<(3) reporta falso" />
                </div>
				<li>Comparte tus algoritmos de clasificación. Describe algunas similaraciones y diferencias entre los diferentes algoritmos de clasificación.</li>
            </ol>
		</div>

<p>Hay muchos algoritmos diferentes para ordenar una lista. Los algoritmos de clasificación dan el mismo resultado, pero el código y la eficiencia pueden variar mucho de un algoritmo a otro. Las siguientes dos páginas destacan dos algoritmos de clasificación usados frecuentemente.</p>

<!--
17m
        <p>There are many different sorting algorithms. But the best one for recursively generated lists, and probably the most elegant, is called <em>mergesort. </em>Here's the idea in a nutshell: Divide the list in half; recursively sort each half; then merge the two sorted sublists. The base case is that an empty list or a one-item list is already sorted.</p>
        <p>The easiest way to divide a list in half turns out to be putting the odd-numbered items in one half and the even-numbered items in the other. You do this with a recursion that skips over an item each time:</p>
        <p><img src="/bjc-r/img/7-recursive-reporters/odds.es.png" alt="odd items" /></p>
        <p><img src="/bjc-r/img/7-recursive-reporters/evenitems.es.png" alt="even items" /></p>
        <p>All the work here, basically, is done by the <img src="/bjc-r/img/7-recursive-reporters/bfbf.es.png" alt="all but first of all but first of" /> in <code>odd numbered items</code>. This skips the second item and makes the recursive call on items 3 through the end of the list. Note that <code>even numbered items</code> is not <em>directly </em>recursive; it calls <code>odd numbered items</code>, not itself.</p>
        <div class="forYouToDo">
            <ol start="4"><li>Why does <code>odd numbered items</code> need two base cases?</li>
                <li>Write a version of <code>even numbered items</code> that calls itself recursively instead of using <code>odd numbered items</code>.</li>
                <li>Can you write a version of <code>odd numbered items</code> that uses (the original) <code>even numbered items</code> instead of calling itself recursively? That program structure (A calls B, B calls A) is called <em><strong>mutual recursion</strong>.</em></li>
            </ol>
        </div> -->
    </body>
</html>
