<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <title>Unit 8 Optional Project: Sorting, Page 3</title>
    </head>

    <body>
        <h2>Partition Sort</h2>
        <div class="todo">
            <p>PG: Scrap. Scrap all. Two reasons. (1) While sorting algorithms is an important and traditional CS topic, it's not obvious to me why they have any important role in an attract-them-in course. These are TiF for interested kids. (2) If our reason for this unit is to teach recursion, sorting is a distraction, and harder than we need to be. If anything at all, it's a culmination, not a start. I'd be happier showing kids how to march down a list and act on it. With HoFs or recursion. Power and utility. That's currently in Lab 4. Maybe earlier even than this unit?</p>
            <p>BH: Definitely replace with mergesort.  Partition sort isn't guaranteed O(n log n); its analysis was awarded a PhD at Stanford.  Mergesort is straightforward.</p>
            <p>MF: I said keep, but I find these pages to be almost to much, and I want to review them. Also, I want to think about whether it would make sense to revisit timing and efficiency here.</p>
        </div>

        <p>
            Another commonly used sort is called a <strong>partition sort</strong>. Here's how it works:
            <ul>
                <li><strong>Step 1.</strong> In an unsorted list, select the first item in the list (<em>which probably won't be the item that should appear first after sorting</em>). This item is called a <strong>pivot</strong>.</li>
                <li><div class="sidenote">An item is "with the pivot" only if it has the same value as the pivot.</div><strong>Step 2.</strong> For each item in the list, decide if it comes before the pivot, with the pivot, or after the pivot.
                    <div class="todo">BH: About step 2 and its yellow box:  This handwaves away the deep issue, which is that sometimes the sort key is smaller than the sort record, so two records may sort alike but not be equal.  I'm not sure if this has to be addressed but maybe it should be mentioned in the TG. BK: I didn't understand what this comment means, sorry.</div>
                </li>
                <li><strong>Step 3.</strong> Partition the data into three categories: items before the pivot, with the pivot, after the pivot. The lists before and after the pivot are unsorted.</li>
                <li><strong>Step 4.</strong> If there are items before the pivot, use a partition sort to put them in order. If there are items after the pivot, use a partition sort to put them in order.</li>
				<li><strong>Step 5.</strong>The sorted list is made from appending the three result lists together.</li>
            </ul>
        </p>

		<div class="takeNote">Names aren't sorted while placing them before or after a pivot. For <img src="/bjc-r/img/8-recursive-reporters/eightnames.png" alt="list{Emma, Olivia, Sophia, Isabella, Ava, Mia, Emily, Abigail}" title="list{Emma, Olivia, Sophia, Isabella, Ava, Mia, Emily, Abigail}"/>, this is the status after the first split via pivoting: the <strong>pivot</strong> is Emma, the list before the pivot is <var>{Ava, Abigail}</var>, and the list after the pivot is <var>{Olivia, Sophia, Isabella, Mia, Emily}</var>. The sorting process then continues on these two smaller unsorted lists.</div>

        <div class="forYouToDo" id="first">
            <ol>
                <li>Explore the partition sort before writing any code. With your class, stand up and form a line. Then, follow the partition sort process to put everyone in sorted order, low to high, by the number of their home address.</li>
                <li>How is a partition sort an example of recursion? What is the base case?</li>
            </ol>
        </div>

<!--        <div class="sidenote">The name <strong>quicksort</strong> can refer to many different algorithms, all with the same goal: sort, quick! This page describes a standard partition sort.</div> -->
<!--        <p>A video of one version of partition sort can be found <a href="http://www.youtube.com/watch?v=aQiWF4E8flQ">here.</a> There are minor differences: the video uses the last item as pivot, and calls the algorithm "quick sort".</p> -->
<div class="todo">We may want to make our own video to show this in action. The linked video is not quite right and has been killed off.</div>
        <p>To write a <code>partition sort</code> block in Snap<em>!</em>, you'll need code for a base case, and code that follows the steps of the partition sort.</p>

        <div class="forYouToDo">
            <div class="todo"> Obsolete
                <span class="li">
                     <a class="run" href="/bjc-r/prog/8-recursive-reporters/appendblock.xml"><img class="inline" src="/bjc-r/img/icons/load-save.png" alt="Click here to load a starter project. Then save it." title="Click here to load a starter project. Then save it."></a><br />  Examine this new project containing the <code>append</code> block (Variables menu).
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/appendblock.png" alt="append(list{Ava, Abigail})(list{Emma})(list{Olivia, Sophia, Isabella, Mia, Emily})" title="append(list{Ava, Abigail})(list{Emma})(list{Olivia, Sophia, Isabella, Mia, Emily})" />
                </span>
                <span class="li">Describe what the <code>append</code> block does.</span>
            </div>
            <ol start="3">
                <li><div class="sidenoteBig">You'll need to figure out how to place the items into the three categories, and how to create one final list to output.</div>Build the recursive reporter <code>partition sort</code>. Its output, for any list, should be the same as the output for <code>selection sort</code>.</li>
            </ol>
        </div>

		<div class="sidenoteBig">
            <a href="#hint-1" data-toggle="collapse" class="collapsed" title="Example">Reveal an example.</a>
            <div id="hint-1" class="collapse">
            	For example, let's say yesterday you had a big sorted list, and today you add a few new items, so you need to re-sort the list. A general-purpose sorting algorithm won't take advantage of the almost-in-order character of its input. But <em>insertion sort,</em> an algorithm that's slow in general, handles this special case quickly.
            </div>
        </div>
		<p>Why are there different sorting algorithms? Some sorting algorithms  take longer than others to run, but even an algorithm that's slow in general may be useful in special cases.</p>

        <div class="ifTime">
            <ol start="4">
                <li>
                    <div class="sidenote">You could also use a long list of names here.</div>
                    Make a 500-item list of random numbers, and then sort the list using the three sorting algorithms you built in this lab. Keep track of the timings:<br />
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/compare-time.png" alt="set(biglist) to (Empty list); repeat(500){add(pick random(1) to (2000) to (biglist)}; reset timer; say(sort(biglist)); set(time) to (timer)" title="set(biglist) to (Empty list); repeat(500){add(pick random(1) to (2000) to (biglist)}; reset timer; say(sort(biglist)); set(time) to (timer)" />
                </li>
                <li>Which algorithm was fastest? Why might this type of algorithm run faster?</li>
                <!--<p>In that script we've renamed <code>sort</code> to <code>merge&nbsp;sort</code>, and used the name <code>your&nbsp;sort</code> for the one you wrote earlier.  <code>Biglist</code>, <code>your-time</code>, and <code>merge-time</code> are global variables.</p>
                <p>Most likely, mergesort will take less than four seconds, while the one you wrote earlier will take more than 15 seconds. That's because we're betting your earlier one positions one number at a time in the sorted list, whereas mergesort cuts the list into two half-size lists and sorts them separately, which is inherently more efficient. If you make the input list ten times as long, a one-at-a-time sort will take 100 times as long to compute the result, whereas mergesort will only take about 30 times as long.</p> -->
            </ol>
        </div>

    </body>
</html>
