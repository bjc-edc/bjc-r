<!DOCTYPE html>
<html lang="es">
	<head>
		<meta charset="utf-8">
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unidad 8 Laboratorio 3: Subconjuntos, Página 2</title>
	</head>
	
    <body>
        <h2>Enumerar los subconjuntos</h2>
		<div class="learn">
			<p><strong>En esta página</strong>, aprenderás cómo generalizar la solución de helado para enumerar los subconjuntos de <em>cualquier</em> conjunto.</p>
		</div>

		<p>Dado un conjunto de cosas, un <em>subconjunto</em> contiene cero o más de sus elementos, sin duplicados. Como ocurría con los tazones de helado, el orden no importa.</p>
		<div class="sidenote">{Banana, Manzana} es el mismo subconjunto que {Banana, Manzana}.</div>

		<p>Por ejemplo, dado el conjunto {Banana, Naranja, Banana}, hay subconjuntos de un elemento como {Banana} y subconjuntos de dos elementos como {Manzana, Banana}. El conjunto original {Manzana, Naranja, Banana} cuenta, al igual que el <em>conjunto vacío </em>{} con cero elementos.</p>
		<div class="forYouToDo" id="first">
            <ol>
                <li>Escribe todos los subconjuntos de {manzana, naranja, plátano}. ¿Cuántos hay?</li>
                <li>Escribe todos los subconjuntos de {Pretzel, Manzana, Naranja, Banana}. Trate de hacer esto con el menor trabajo posible.</li>
                <li>
                    Ahora crea un bloque <code>subsets</code> que toma una lista como entrada y reporta una <em>lista de listas</em> en la que cada elemento es un subconjunto de la lista de entrada original. El orden en que aparecen los subconjuntos en la lista de salida no importa, pero cada subconjunto debe aparecer exactamente una vez. El resultado podría verse así:<br />
                    <img class="indent noshadow" src="/bjc-r/img/8-recursive-reporters/subset-example.es.png" alt="subconjuntos(lista{Manzana, Naranja, Banana}) reporta {{},{Banana}, {Naranja}, {Banana, Naranja},{Manzana}, {Manzana, Banana}, {Manzana, Naranja}, {Manzana, Naranja, Banana}}" title="subconjuntos(lista{Manzana, Naranja, Banana}) reporta {{},{Banana}, {Naranja}, {Banana, Naranja},{Manzana}, {Manzana, Banana}, {Manzana, Naranja}, {Manzana, Naranja, Banana}}" />
                    <div class="endnote">
                        <p>Si estás atascado después de probar tantas ideas que se te ocurran, <a href="#hint-subsets" data-toggle="collapse" title="haz clic aquí para obtener ayuda para crear subconjuntos">haz clic aquí para obtener un poco de ayuda</a>.</p>
                         <div id="hint-subsets" class="collapse">
                            <ul>
                                <li>¿Cuántos subconjuntos tiene el conjunto vacío {}?</li>
                                <li>¿Qué deberían informar los <code>subconjuntos</code> en el caso base? ¡Esta es una parte difícil de hacer bien!</li>
                                <li>¿Cuántos subconjuntos de {Pretzel, Manzana, Naranja, Banana} contienen Pretzel? ¿Cuántos no?</li>
                                <li>Describa "los subconjuntos de {Pretzel, Manzana, Naranja, Banana} que no contienen Pretzel" sin usar las palabras "no contienen".</li>
                                <li>
                                    Esta es una versión de cómo se vería el código, con muchos espacios para llenar&hellip;<br />
                                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/subsets-framework.png" alt="subconjuntos(conjunto){si(){reportar()}sino{...; reportar(anexar()())}}" title="subconjuntos(conjunto){si(){reportar()}sino{...; reportar(anexar()())}}"/>
                                </li>
                            </ul>
                        </div>
                    </div>
                </li>
            </ol>
        </div>

        <h3>Subconjuntos y eficiencia</h3>
        <p>
            <a href="#hint-solution" data-toggle="collapse" title="Aquí hay una solución para el bloque subconjuntos">Aquí hay una solución para el bloque <code>subconjuntos</code>.</a>
            <div id="hint-solution" class="collapse">
                <img class="indent" src="/bjc-r/img/8-recursive-reporters/subset-slow.es.png" alt="subconjuntos(conjunto){si(¿vacío?(conjunto)){reportar(lista{})}sino{reportar(anexar(subconjuntos(todos menos el primero (conjunto)))(mapear(elemento(1) de (conjunto) delante de ()) sobre(subconjuntos(todos menos el primero(conjunto)))))}}" title="subconjuntos(conjunto){si(¿vacío?(conjunto)){reportar(lista{})}sino{reportar(anexar(subconjuntos(todos menos el primero (conjunto)))(mapear(elemento(1) de (conjunto) delante de ()) sobre(subconjuntos(todos menos el primero(conjunto)))))}}" />
            </div>
        </p>

        <p>Esta solución para <code>subconjuntos</code> realiza la misma llamada recursiva dos veces, una ineficiencia que se puede corregir.</p>
        <div class="forYouToDo">
            <ol start="4">
                <li>Usar una variable <code>conteo</code> para contar cuántas llamadas recursivas se realizan para encontrar los 64 subconjuntos de una lista de seis elementos.</li>
                <li>Averigua cómo reducir la cantidad de llamadas recursivas evitando llamadas redundantes.</li>
            </ol>
        </div>
    </body>
</html>
