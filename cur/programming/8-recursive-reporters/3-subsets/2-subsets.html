<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <title>Unit 8 Lab 3: Subsets, Page 2</title>
    </head>

    <body>
    	<h2>Listing the Subsets</h2>
        <div class="todo">
            <p>BH: Merge the hints page.</p>
            <p>MF:  There is a hints page; if we want them, they should be yellowboxed on the page.</p>
        </div>
        <div class="todo">BH agreed to combine with next page but with solution hinted. --MF, 6/17/20</div>

        
        <div class="learn">
            <p><strong>On this page,</strong> you will learn how to generalize the ice cream solution to list the subsets of any set.</p>
        </div>
        
        
		<p>Given a set of things, a <em>subset </em> contains zero or more of its elements, without duplicates. As was true for ice cream bowls, order doesn't matter.</p>
        
        <div class="sidenote">{Banana, Apple} is the same subset as {Apple, Banana}.</div>
        
        <p>For example, given the set {Apple, Orange, Banana} there are one-element subsets like {Banana} and two-element subsets like {Apple, Banana}. The original set {Apple, Orange, Banana} counts, and so does the <em>empty set </em>{} with zero elements.</p>
    <div class="forYouToDo" id="first">
        <ol>
            <li>Write down all the subsets of {Apple, Orange, Banana}. How many are there?</li>
            <li>Write down all the subsets of {Pretzel, Apple, Orange, Banana}. Try to do this with as little work as possible.</li>
            <div class="todo">Add a question that gets at how 2 is just an aumentation of 1. --MF, 6/17/20
            <img class="imageRight" src="/bjc-r/img/icons/talk-with-your-partner.png" alt="Talk with Your Partner" title="Talk with Your Partner" />Describe how you did it.</div>

            <li>
            	<div class="todo">MARY Note to self: this is hard. for example, in base case (subsets of empty list), you have to report a list containing the empty list. Add a question that gets at the base case. </div>
Now create a <code>subsets</code> block that takes a list as input and reports a <em>list of lists</em> in which each item is a subset of the original input list. The order in which the subsets appear in the output list doesn't matter, but each subset must appear exactly once. The result might look like this:<br />
            	<img class="indent" src="/bjc-r/img/8-recursive-reporters/subset-example.png" alt="subsets(list{Apple, Orange, Banana}) reporting {{},{Banana}, {Orange}, {Banana, Orange},{Apple}, {Apple, Banana}, {Apple, Orange}, {Apple, Orange, Banana}}" title="subsets(list{Apple, Orange, Banana}) reporting {{},{Banana}, {Orange}, {Banana, Orange},{Apple}, {Apple, Banana}, {Apple, Orange}, {Apple, Orange, Banana}}" />
            	<p>If you're stuck after trying as many ideas as you can think of, go to <a href="/bjc-r/cur/programming/8-recursive-reporters/5-pascals-triangle/extras/6-subsets-hint.html" title="Subsets Hints">Subset Hints page</a> for some help.</p>
                <div class="endnote">integrate hints page onto the page. --MF, 6/17/20</div>
            </li>
        </ol>
    </div>
    
        <div class="todo">The following is all from a second page and needs to be properly integrated by Mary. --MF, 6/17/20</div>
        
        
        <h2>Subsets and Efficiency</h2>
        <div class="todo">
            <p>MF: Scrap. Fold into the Subsets OP at the end.</p>
        </div>
        <div class="todo">Pages or lab needs renaming so they aren't duplicative. --MF, 6/15/20</div>
        
        <p>
            Here is one solution for the <code>subsets</code> block:<br />
            <img class="indent" src="/bjc-r/img/8-recursive-reporters/subset-slow.png" alt="subsets(set){if(empty?(set)){report(list{})}else{report(append(subsets(all but first of(set)))(map(item(1) of (set) in front of ()) over(subsets(all but first of(set)))))}}" title="subsets(set){if(empty?(set)){report(list{})}else{report(append(subsets(all but first of(set)))(map(item(1) of (set) in front of ()) over(subsets(all but first of(set)))))}}" />
        </p>
        
        <p>This solution should remind you of the <code>pascal</code> block you have seen in <a href="/bjc-r/cur/programming/8-recursive-reporters/5-pascals-triangle/2-pascal-efficiency.html?topic=nyc_bjc%2F8-recursive-reporters.topic&course=bjc4nyc.html&novideo&noassignment" title="Pascal's Triangle and Efficiency">Unit 8 Lab 3 Page 2: Pascal's Triangle and Efficiency</a>, which makes two recursive calls and adds the results. The <code>pascal</code> block makes two recursive calls <em>with different inputs</em>. This version of <code>subsets</code> makes <em>the same</em> recursive call twice, an inefficiency that can be corrected.</p>
        <div class="forYouToDo">
            <ol>
                <li>Using a <code>count</code> variable, as you did for the <code>pascal</code> block, count how many recursive calls are made to find the 64 subsets of a six-element list.</li>
                <li>Figure out how to reduce the number of recursive calls by avoiding redundant calls.</li>
            </ol>
        </div>
    </body>
</html>
