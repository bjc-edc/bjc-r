<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <title>Unidad 8 Práctica de laboratorio 2: Conversión de bases, Página 2</title>
    </head>
    
    <body>
        <h2>Base Conversion</h2>
        <div class="todo">
            <p>MF: I want to review/revise. (potentially into a 1-page lab? maybe not...)</p>
			<p>Pages or lab needs renaming so they aren't duplicative. --MF, 6/15/20</p>
		</div>
		<div class="learn">
            <p><strong>En esta página,</strong> generalizará desde la conversión base con binario a la conversión con <em>cualquier</em> base.</p>
        </div>
     

        <p>Aquí hay una solución para la conversión binaria de enteros no negativos:</p>
        <p><img class="indent" src="/bjc-r/img/8-recursive-reporters/tobinary.es.png" alt="decimal->binary(number){if(number<2){report(number)}else{report(join(decimal->binary(floor(number/2)))(number mod 2))}}" title="decimal->binary(number){if(number<2){report(number)}else{report(join(decimal->binary(floor(number/2)))(number mod 2))}}"/></p>
        <p>Si un número se puede representar con un solo dígito, lo usamos como caso base. Para el binario, los únicos números que se pueden representar con un solo dígito son el 0 y el 1, por lo que probamos para ver si el número es menor que 2. Si es así, lo reportamos.</p>
        <p><div class="sidenote">Puede sorprender que no usemos un combinador aritmético, pero el resultado deseado es un <em>numeral</em>, una cadena de texto. Es por eso que el combinador es una operación de cadena.</div>En el caso recursivo, el dígito binario más a la derecha es el resto al dividir el número por 2. Los otros dígitos provienen de una llamada recursiva al cociente al dividir por 2. El combinador es <code>join</code> porque queremos unir los dígitos.</p>

        <div class="forYouToDo" id="first">
           <div class="todo">Images should be redone so they are the same size (zoom 1.5). --MF</div>
           <ol>
                <li>
                    Escribe el bloque <code>base 7</code>, que muestra un número en base 7.<br />
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base7example.es.png" alt="base7( 9827), reporting 40436" title="base7( 9827), reporting 40436" />
                </li>
                <li>
                    Generaliza el patrón con un bloque <code>base</code> que toma la base como una segunda entrada:<br />
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base2.es.png" alt="(9827)base(2), reporting 10011001100011" title="(9827)base(2), reporting 10011001100011" />
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base7.es.png" alt="(9827)base(7), reporting 40436" title="(9827)base(7), reporting 40436" /><br />
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base8.es.png" alt="(9827)base(8), reporting 23143" title="(9827)base(8), reporting 23143" />
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base10.es.png" alt="(9827)base(10), reporting 9827" title="(9827)base(10), reporting 9827" /><br />
                    
                </li>
                <li>
                    <div class="sidenote">Snap<em>!</em> mostrará este número en decimal, pero lo estás convirtiendo a un <em>número</em>, no a una cadena de dígitos.</div>Escribe la función inversa <code>de base</code> que toma una cadena (de texto) de dígitos y una base como entradas, y reporta el número correspondiente.<br />
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/frombase.es.png" alt="(23143)from base(8) reporting 9827" title="(23143)from base(8) reporting 9827" />
                </li>
            </ol>
        </div>

        <div class="ifTime">
            <ol start="4">
                <li>Mejore el bloque <code>base</code> para que pueda subir a la base 36 usando las letras <code>a</code>‒<code>z</code> como dígitos con valores 10‒35.<br />
                <img class="indent" src="/bjc-r/img/8-recursive-reporters/common.es.png" alt="(32562)base(15), reporting 99ac" title="(32562)base(15), reporting 99ac" />
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/w00zy.es.png" alt="(53749006)base(36) reporting w00zy" title="(53749006)base(36) reporting w00zy" />
                </li>
                <li>Mejore el bloque <code>desda la base</code> para admitir bases hasta 36 de la misma manera.</li>
            </ol>
        </div>

<!--        <div class="takeItFurther" id="first">
		
       <p> 	Long ago, when computer circuits were very unreliable, some computers used a representation called <em>biquinary,</em> which used decimal digits, each of which was represented using five bits, of which exactly two had to be 1, and the other three had to be 0.  The five bits represented the values 0, 1, 2, 4, and 7. (Yes, that's a strange set of bit values.  Bear with us.)</p>
            <div class="comment">GH feedback 8/2/15: I don't understand the question being asked in "Take It Further" #6. It's unclear. (It's letter B, now. --MF)</div>
            <ol style="list-style:upper-alpha;">
            	<li>Check that each of the values from 1 to 9 can be represented as the sum of two of those bit values in exactly one way.</li>
				<li>There's exactly one more possible set of two of those five bit values; that one represents zero.  What are those two bits?</li>
				<li>How does this help solve the problem of unreliable circuits?</li>
			</ol>
		</div> -->
    
    
    </body>
</html>
            