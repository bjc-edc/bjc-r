<!DOCTYPE html>
<html lang="es">
	<head>
		<meta charset="utf-8">
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unidad 8 Laboratorio 4: Construir funciones de orden superior, Página 3</title>
	</head>

	<body>
		<h2>Números pares y <code>mantener</code></h2>
		<div class="learn">
            <p><strong>En esta página</strong>, construirás otras dos funciones de orden superior que aprendiste en este curso: <code>mantener</code> y <code>combinar</code>.</p>
        </div>
		<p>Queremos un bloque que tome una lista de números como entrada y reporte una lista de solo los números <strong>pares</strong> de la entrada.</p>
		<p>
			Ya sabes cómo escribir este bloque usando la función de orden superior <code>mantener</code>, pero veamos cómo se ve usando la recursividad:<br />
			<img class="indent" src="/bjc-r/img/8-recursive-reporters/evens.png" alt="pares (números){si(¿vacío? (números)){devolver(lista vacía)} sino{si((elemento(1) de (números)) módulo (2)=0){reportar(elemento(1) de (números) delante de (pares (todos menos el primero (números))))} sino{reportar(pares(todos menos el primero (números)))}}}" title="pares (números){si(¿vacío? (números)){devolver(lista vacía)} sino{si((elemento(1) de (números)) módulo (2)=0){reportar(elemento(1) de (números) delante de (pares (todos menos el primero (números))))} sino{reportar(pares(todos menos el primero (números)))}}}" />
		</p>
		<p>Aquí hay <em>tres </em>casos posibles a considerar, no solo el caso base habitual o el caso recursivo. Todavía hay un caso base, a saber, una lista de entrada vacía, en cuyo caso informamos una lista vacía. Pero hay <em>dos</em>casos recursivos, dependiendo de si el primer elemento de la lista es par o no. (Tiene que haber un primer elemento, si no estamos en el caso base). Los bloques de Operadores verdes arriba toman el resto al dividir el primer número por 2, y ven si ese resto es 0, en cuyo caso el número es incluso.</p>
		<p>Si el primer número es par, entonces queremos incluir ese número en el resultado. Entonces reportamos ese número <code>delante de</code> la llamada recursiva en el resto de los números. Si el primer número no es par, entonces <em>no </em>queremos incluirlo en el resultado, así que simplemente informamos el valor informado por la llamada recursiva.</p>

		<div class="takeNote">Al igual que <code>plurales</code>, el código <code>pares</code> es un ejemplo de un <strong>patrón</strong> de código. No hay nada especial acerca de los números pares aquí. El mismo patrón podría usarse para hacer una lista de números impares, o números que terminen en 7, o nombres que comiencen con Z.</div>

		<div class="forYouToDo" id="first">
			<p><strong>Haz los siguientes ejercicios usando recursividad, no funciones de orden superior. </strong></p>
			<ol>
				<div class="sidenote">Intenta modificar el código de <code>evens</code>.</div>
				<li>
					Escriba un bloque <code>termina en-a</code> que tome una lista de palabras como entrada y reporte una lista de esas palabras de la entrada cuya última letra es <em>a</em>.<br />
					<img class="indent" src="/bjc-r/img/8-recursive-reporters/endse-ex.png"
						alt="termina en-a(lista{la, lluvia, en, España, es, en, Europa}), reporta {la, lluvia, Europa}"
						title="termina en-a(lista{la, lluvia, en, España, es, en, Europa}), reporta {la, lluvia, Europa}" />
				</li>
				<li>
					Escribe un bloque <code>números</code> que tome una lista de palabras y números mixtos como entrada y reporte una lista de solo los números de la lista de entrada.<br />
					<img class="indent" src="/bjc-r/img/8-recursive-reporters/numbers-ex.png"
						alt="números(lista{el, 1, después, 909}), reporta {1, 909}"
						title="números(lista{el, 1, después, 909}), reporta {1, 909}" />
				</li>
				<li>Generaliza el patrón para hacer un bloque <code>mantener</code>.</li>
				<li>Escribe el bloque <code>combinar</code>. <strong>Nota:</strong> El caso base será una lista con un elemento, no una lista vacía.</li>
			</ol>
		</div>

		<div class="takeNote">Crear <code>mapear</code>, <code>mantener</code> y <code>combinar</code> es un gran logro. Sin embargo, cada uno de estos bloques solo generaliza un patrón simple. Algunas personas piensan ni siquiera aprender a <em>usar</em> las funciones de orden superior son en la universidad, ni mucho menos a construirlasn.  🎉 ¡Enhorabuena! 👏 ¡Completaste <em>La belleza y alegría de la Informática</em> (BJC)! 🏆</p>
		</div>

		<div class="takeItFurther">
			<ol type="A">
				<li>Haz <a href="/bjc-r/cur/programming/8-recursive-reporters/optional-project-sorting/1-sorting-a-list.html?topic=nyc_bjc%2F8-recursive-reporters.topic&course=bjc4nyc.html&novideo&noassignment" title="Unidad 8 Proyecto opcional: Ordenar" target="_blank">Unidad 8 Proyecto opcional: Ordenar</a>.</li>
				<li>
					Modifica cualquier algoritmo <code>ordenar</code> que hayas escrito anteriormente en el Proyecto opcioanl para tomar un predicado de comparación como entrada, para que puedas decir<br />
					<img class="indent" src="/bjc-r/img/8-recursive-reporters/sortusing.png" alt="ordenar(algunos-valores) usando (()>()) para comparar" title=" ordenar (algunos valores) usando (()>()) para comparar" /><br />
					para ordenar con el elemento <em>más grande</em> primero.
				</li>
			</ol>
		</div>
	</body>

</html>
