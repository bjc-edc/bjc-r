<!DOCTYPE html>
<html lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
    <title>Unit 7 Lab 2: Sorting, Page 3</title>
    </head>
    
    <body>
        <h2>Partition Sort</h2>
        <p>
            Another commonly used sort is called a <strong>partition sort</strong>. Here's how it works:
            <ul>
                <li><strong>Step 1.</strong> In an unsorted list, select the first item in the list (<em>which probably won't be the item that should appear first after sorting</em>). This item is called a <strong>pivot</strong>.</li>
<div class="todo">BH: About step 2 and its yellow box:  This handwaves away the deep issue, which is that sometimes the sort key is smaller than the sort record, so two records may sort alike but not be equal.  I'm not sure if this has to be addressed but maybe it should be mentioned in the TG. BK: I didn't understand what this comment means, sorry.</div>
                <li><div class="sidenote">An item is "with the pivot" only if it has the same value as the pivot.</div><strong>Step 2.</strong> For each item in the list, decide if it comes before the pivot, with the pivot, or after the pivot.</li>
                <li><strong>Step 3.</strong> Partition the data into three categories: items before the pivot, with the pivot, after the pivot. The lists before and after the pivot are unsorted.</li>
                <li><strong>Step 4.</strong> If there are items before the pivot, use a partition sort to put them in order. If there are items after the pivot, use a partition sort to put them in order.</li>
				<li><strong>Step 5.</strong>The sorted list is made from appending the three result lists together.</li>
            </ul>
        </p>

		<div class="takeNote">Names aren't sorted while placing them before or after a pivot. For <img src="/bjc-r/img/7-recursive-reporters/eightnames.png" alt="Eight names" />, the <strong>pivot</strong> is Emma, the list before the pivot is <var>{Ava, Abigail}</var>, and the list after the pivot is <var>{Olivia, Sophia, Isabella, Mia, Emily}</var>. The sorting process then continues on these two smaller lists.</div>

        <div class="forYouToDo" id="first">
            <ol>
                <li>Let's explore the partition sort before writing any code. With your class, stand up and form a line. Then, follow the partition sort process to put everyone in sorted order, low to high, by the number of their home address.</li>
                <li>How is a partition sort an example of recursion? What is the base case?</li>
            </ol>
        </div>

<!--        <div class="sidenote">The name <strong>quicksort</strong> can refer to many different algorithms, all with the same goal: sort, quick! This page describes a standard partition sort.</div> -->
<!--        <p>A video of one version of partition sort can be found <a href="http://www.youtube.com/watch?v=aQiWF4E8flQ">here.</a> There are minor differences: the video uses the last item as pivot, and calls the algorithm "quick sort".</p> -->
<div class="todo">We may want to make our own video to show this in action. The linked video is not quite right and has been killed off.</div>
        <p>To write a <code>partition sort</code> block in Snap<em>!</em>, you'll need code for a base case, and code that follows the steps of the partition sort.</p>

        <div class="forYouToDo">
            <ol start="3">
                <li>
                    Open this new project containing the <code>append</code> block. <a class="run" href="/bjc-r/prog/7-recursive-reporters/appendblock.xml"></a><br />
                    <img class="indent" src="/bjc-r/img/7-recursive-reporters/appendblock.png" alt="Append block" title="Append block" />
                </li>
                <li>Describe what the <code>append</code> block does.</li>
                <li><div class="sidenote">You'll need to figure out how to place the items into the three categories, and how to create one final list to output.</div>Build the recursive reporter <code>partition sort</code>. Its output, for any list, should be the same as the output for <code>selection sort</code>.</li>
            </ol>
        </div>

<div class="todo">BH: The white text below FYTD 5 is an extreme simplification.  If efficiency were the only issue, we wouldn't teach the n^2 sorts.  There are /many/ sorting algorithms, and most of them are used in special cases.  For example, in certain cases of partial sorting (the paradigmatic example is sorting addresses by zip code), the n log n barrier can be breached because non-comparison-based algorithms can be used -- for zip codes, you use *bucket* sort, in which you just toss the envelopes into buckets, one per zip code.  Linear time.  Also, general purpose sorts are chosen partly to be /stable/ -- items that compare equal remain in their original order.  The very fastest sorts aren't stable.
Again, I'm not sure whether we should address any of this, but I feel bad about implying something that's not really true.  And that will lead smart kids who are paying attention to say "why not just use the fastest one, then?" BK: For what it's worth, I think the text below came from the original BJC.</div>

		<p>Why are there different sorting algorithms? Computer programs are judged not only by what they do; they are also judged by how long it takes them to do it, especially as the size of the inputs grows. Different sorting algorithms can have different efficiencies.</p>

        <div class="ifTime">
            <ol start="6">
                <li>
                <div class="sidenote">You could also use a long list of names here.</div>
                Make a 500-item list of random numbers, and then sort the list using the three sorting algorithms you built in this lab. Keep track of the timings:<br />
                <img class="indent" src="/bjc-r/img/7-recursive-reporters/compare-time.png" alt="script to compare timings" title="script to compare timings" />
                </li>
                <li>Which algorithm was fastest? Why might this type of algorithm run faster?</li>
                <!--<p>In that script we've renamed <code>sort</code> to <code>merge&nbsp;sort</code>, and used the name <code>your&nbsp;sort</code> for the one you wrote earlier.  <code>Biglist</code>, <code>your-time</code>, and <code>merge-time</code> are global variables.</p>
                <p>Most likely, mergesort will take less than four seconds, while the one you wrote earlier will take more than 15 seconds. That's because we're betting your earlier one positions one number at a time in the sorted list, whereas mergesort cuts the list into two half-size lists and sorts them separately, which is inherently more efficient. If you make the input list ten times as long, a one-at-a-time sort will take 100 times as long to compute the result, whereas mergesort will only take about 30 times as long.</p> -->
            </ol>
        </div>

    </body>
</html>
