<!DOCTYPE html>
<html>
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script src="/bjc-r/llab/loader.js"></script>
    <title>Sorting</title>
    </head>
    
    <body>
        <h2>Sorting a List</h2>
        <div class="todo">
            <ul>
                <li>GH Feedback 8/3/15: Why is the easiest way to split the data in half to collect odd and even numbers? Could you explain that rationale? It seems like it would be easier to just divide the list in two...</li>
            </ul>
    	</div>
        <p>Suppose we have a list of numbers like this:</p>
        <p><img src="/bjc-r/img/7-recursive-reporters/unsortlist.png" alt="7, 8, 1, 9, 8, 2, 7" /></p>
        <p>What we want is a list of the same numbers, in ascending order:</p>
        <p><img src="../../../../img/7-recursive-reporters/sortlist.png" alt="1, 2, 7, 7, 8, 8, 9" /></p>
        <p>(There's no reason the items have to be numbers, as long as we have some way to order them, like the <code>&lt;</code> operator for numbers. But numbers are easiest to talk about in this context.)</p>
        <div class="forYouToDo" id="first">
            <ol>
                <li>Invent an algorithm for this problem.  Feel free to work in larger groups for this.  Try to describe the algorithm in enough detail so that someone could code it in Snap<em>!</em>.</li>
                <li>Now implement your algorithm!  Work in pairs for this part.</li>
            </ol>
        </div>
        <p>There are many different sorting algorithms. But the best one for recursively generated lists, and probably the most elegant, is called <em>mergesort. </em>Here's the idea in a nutshell: Divide the list in half; recursively sort each half; then merge the two sorted sublists. The base case is that an empty list or a one-item list is already sorted.</p>
        <p>The easiest way to divide a list in half turns out to be putting the odd-numbered items in one half and the even-numbered items in the other. You do this with a recursion that skips over an item each time:</p>
        <p><img src="../../../../img/7-recursive-reporters/odds.png" alt="odd items" /></p>
        <p><img src="../../../../img/7-recursive-reporters/evenitems.png" alt="even items" /></p>
        <p>All the work here, basically, is done by the <img src="../../../../img/7-recursive-reporters/bfbf.png" alt="all but first of all but first of" /> in <code>odd numbered items</code>. This skips the second item and makes the recursive call on items 3 through the end of the list. Note that <code>even numbered items</code> is not <em>directly </em>recursive; it calls <code>odd numbered items</code>, not itself.</p>
        <div class="forYouToDo">
            <ol start="4"><li>Why does <code>odd numbered items</code> need two base cases?</li>
                <li>Write a version of <code>even numbered items</code> that calls itself recursively instead of using <code>odd numbered items</code>.</li>
                <li>Can you write a version of <code>odd numbered items</code> that uses (the original) <code>even numbered items</code> instead of calling itself recursively? That program structure (A calls B, B calls A) is called <em><strong>mutual recursion</strong>.</em></li>
            </ol>
        </div>
    </body>
</html>
