		<div class="takeNote"><em>Important:</em> as this example shows there can be huge benefits to using our own custom blocks.  The process in this exercise is aptly referred to as functional decomposition, whereby we break a larger function into smaller pieces and then reassemble the original function. This is one important way that we can build abstractions as the larger function (valid-date?) doesn't need to know what the functions that compose it do, it can just assume that they work.</div>
./3.5-T1PP/projects/valid-date.html
		<p> A human brick-layer  would  understand exactly how to build such a wall. A computer doesn't know, so you must fill in the details. This means going from the abstract (draw a brick wall) to the concrete (pardon the pun). This involves <strong>problem decomposition</strong>.</p>
./2-complexity/4-abstraction/old/1-abstraction-brick-wall.html
            Getting there involves <strong>problem decomposition</strong>: breaking the problem into smaller pieces.
./2-complexity/4-abstraction/3-brick-wall.html
            <p><strong>In this lab,</strong> you will create tools for drawing complex designs from lists of points. To do this, you will use problem decomposition&mdash;breaking down the problem into smaller pieces. </p>
./2-complexity/2-data-structures-art/1-the-for-each-block.html
            <p><strong>Problem decomposition</strong> is the process of solving a complex problem by building small tools and combining them to make bigger ones. </p>
./2-complexity/2-data-structures-art/4-mandala.html
            <p>PG: This /has/ a learning purpose. It's lost in "optional." The learning purpose is couched in machine generation of language, but the content/programming goals are also practice of old, learning new, and foreshadowing. The important "new" is the essential element of problem decomposition and abstraction: this problem is too difficult /without/ decomposing it, but perfectly tractable /with/ decomposition. And then, perfectly extensible to Spanish or...</p>
./2-complexity/optional-projects/4-plurals1.html
                	A great way to approach this problem is by using <strong>problem decomposition</strong>: breaking the problem into smaller pieces. For example, you might choose to first build a <code>last letter of</code> reporter that reports the last letter of an inputted word. Then you could solve the problem more easily, like this:<br />
./2-complexity/3-predicates/3-solving-word-puzzle.html
            In this activity you will be drawing this same brick wall.  Remember to use functional decomposition
./old-labs/abstraction/brick-wall-hard.html
			If you were to ask a mason to make a brick wall with ten rows, he would surely understand your meaning and make it happen. A computer, however, doesn't know what that means, so you have to fill in the details. This means going from the abstract (draw a brick wall) to the concrete (pardon the pun), which involves problem decomposition.
./old-labs/abstraction/brick-wall.html
which involves problem decomposition.
./old-labs/abstraction/another-brick-wall.html
            referred to as functional decomposition, whereby we break a larger function into smaller pieces and then reassemble the original function.
./old-labs/conditionals/valid-date.html
