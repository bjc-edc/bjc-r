<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 6 Lab 1: Software Domain—Programming Languages, Page 4</title>
	</head>
    <body>
        <div class="todo">
            <p>Why this?  This page is about the two levels of abstraction above the program abstraction, from the chart on page 1.</p>
            <p>Why here?  There will be three pages, including this one, about the parts of the abstraction hierarchy separated by the two major abstraction barriers, going from top to bottom.</p>
            <p>2.1.2B In many programming languages, the fixed number of bits used to represent characters or integers limits the range of integer values and mathematical operations; this limitation can result in overflow or other errors.<br />
            2.1.2C In many programming languages, the fixed number of bits used to represent real numbers (as floating point numbers) limits the range of floating point values and mathematical operations; this limitation can result in roundoff errors<br />
            2.2.3A Different programming languages offer different levels of abstraction.<br />
            2.2.3B High level programming languages provide more abstractions for the programmer and make it easier for people to read and write a program.<br />
            2.2.3C Code in a programming language is often translated into code in another (lowerlevel) language to be executed on a computer.<br />
            5.5.1B Integers may be constrained in the maximum and minimum values that can be represented in a program because of storage limitations.</p>
        </div>
        
        <h2>The Software Domain: Programming Languages</h2>
        
        
        <p>Javascript, Python, Snap<em>!</em>, C++, Java, Scheme, Prolog... Why are there so many programming languages? Why don't they just pick the best one, or design a new best one, and stick with that?</p>
        <p>In one sense, all these languages are the same: If an algorithm can be expressed in one language, it can be expressed in all of them. The differences are about how <em>convenient</em> it is to write a particular program, and about how <em>safe against bugs</em> the resulting program will be.</p>
        <p>Some languages have very narrow purposes. For example, Microsoft Word has a programming language built into it called &quot;Word macros&quot; that's just for generating data and formatting in a document. But the languages you've probably heard about are meant to be <em>general-purpose</em> programming languages, and the differences among languages are mostly about <em>levels of abstraction.</em></p>
    <h4><strong>High and Low Level Languages</strong></h4>
        <p>A <em>high level language</em>  includes many abstractions that make it easier to focus on the problem you want to solve rather than on how  computer hardware works. (The sprite abstraction is one example.) A <em>low level language</em> has few abstractions, requiring you to know a lot about  your computer's architecture to write a program.</p>
    <p>High level languages can produce <em>safer</em> programs—ones that are less likely to have bugs. To take one example, older, low level languages required the programmer to manage the use of the computer's memory with instructions saying &quot;get me a block of memory big enough to hold 100 numbers&quot; and other instructions saying &quot;okay, I'm finished using this block of memory; it can be allocated for some other purpose.&quot; This is a nuisance to have to think about, and (maybe for that reason) human programmers are really, really bad at it. In low level languages, a very common bug is for one part of a program to say &quot;I'm done with this block of memory&quot; while another part of the program is still using it. High level languages take care of this for us, using a technique called <em>garbage collection</em> that puts the computer in charge of knowing when a block of memory is really no longer in use.</p>
        <p>High level languages can also make programming much more convenient. One example is <em>higher order functions;</em> it's much easier to write<br />
        <img src="/bjc-r/img/6-computers/map-s.png" alt="map (join _ s) over (words)"><br />
        than to write<br />
<img src="/bjc-r/img/6-computers/hard-way.png" alt="script variables (resul) (index); set result to (list); set index to 0; repeat (length of (words)): change index by 1; add (join (item index of words) s) to (result); report result"></p>        
        <p>Both high and low level languages are used by <em>people</em> to write computer programs. Computer hardware understands a sort of ultra-low level language, called <em>machine language.</em> Special programs called <em>compilers</em> and <em>interpreters</em> are used to translate programming languages into machine language.</p>
      <div class="endnote">
            <a href="#hint-compilers" data-toggle="collapse">Click to learn more about compilers and interpreters.</a>
      <div id="hint-compilers" class="collapse">
        <p>A <em>compiler</em> is a program that takes a high or low level language program (the <em>source code</em>) as input, and produces a machine language program (the <em>object code</em>) as its output. Once produced, the machine language program can be run repeatedly without needing to be compiled again.</p>
        <p>An <em>interpreter</em> is a program that takes a high or low level program as input, and carries out machine language instructions as needed to run the program. It does not produce a stand-alone machine language program as output.</p>
        <p>Does that mean compilers are better? It <em>would</em> mean that, except that the process of writing a program includes <em>debugging.</em> During the debugging, an interpreter can help by providing information about the progress of the program, like the visual stepping feature in Snap<em>!</em>, and allowing small changes in the source program without having to run a compiler repeatedly. For example, in Snap<em>!</em> you can drag a block into a script while it's running; a compiler couldn't allow that.</p>
        <p>For professional programmers, the best arrangement is to have both an interpreter and a compiler for the same language. You write and debug the program using an interpreter, and once you're sure it works, you compile it. Then the compiler can run slowly, putting a lot of effort into <em>optimizing</em> the machine language code, so you get the very fastest possible compiled program. (Doesn't slowing down the compiler undo the benefit of speeding up the object code? No, because the program is compiled only once, but it may be run thousands or millions of times, especially if it's an application that millions of people use.)</p>
        <!-- <p>Sometimes there are reasons to use a more complicated development process. For example, a high level language might be compiled into a lower level language, and then that <em>intermediate</em> program would be compiled into machine language. Or the intermediate program might be interpreted rather than compiled.</p> -->
      </div></div>
    <p>So why would anyone ever want to use a low level language? The best answer is "in order to write an operating system." (Operating systems are discussed two pages later.)</p>
        <div class="endnote">
        	<a href="#hint-low-level-lang" data-toggle="collapse">There are also less-good reasons.</a>
			<div id="hint-low-level-lang" class="collapse">
            	<p>Application programmers don't  decide "I'm going to write this program in a low level language." They may simply not realize that higher levels of abstraction are possible. For example,  a  computer's hardware limits the size of numbers that its arithmetic unit can add in a single step. Four billion—about ten digits—is a common size limit for integers. Programmers who use Java, Javascript, Python, C or C++ may think that this limit is unavoidable. But programmers who use <em>really</em> high level languages, such as Scheme or Common Lisp, know that they can do arithmetic on numbers with millions or billions of digits, limited only by the size of the computer's memory. As you will see later, Snap<em>!</em> has a <strong>library</strong> that lets it do this, too.</p>
        		<p><em>Programmers may think that abstraction is too slow.</em> Programmers of 3-D video games  need all the speed they can get; their programs strain the speed of modern computers. So they often write part of their programs, the part that actually puts pictures on the screen, in machine language, just for speed. But most programmers  write applications that don't strain computers at all. When you send an email or text message, the limiting factor  is how fast you can type, not how fast your computer can run programs.</p>
        		<p>Sometimes an abstraction gets a reputation for slowness because 50 years ago, when the abstraction was first invented by  researchers, it really did strain the computers of the day; old programmers may continue to tell young programmers how slow it is, even though today's computers are millions of times as fast. For example, automatic garbage collection for program safety was introduced in the programming language Lisp in 1958. (Lisp is the second oldest programming language still in use, after Fortran.) But it wasn't until the introduction of Java in 1995 (37 years later) that &quot;real world&quot; programmers admitted that it's a good idea.</p>
            	<p>People often say that different programming languages are good for different kinds of programs, but except for 3-D video processing, it's hard to imagine an application that would be <em>harmed</em> by things like garbage collection or higher order functions. Occasionally there are <em>security</em> reasons to make languages less powerful on purpose. For example, Javascript is used in browsers to run software (for example, Snap<em>!</em>) downloaded from a web site. Browsers don't allow Javascript programs to read or write files on your computer's disk unless the user explicitly asks to do that. But this isn't really a <em>language</em> limitation; it's a limitation in the library that the browser provides for reading and writing files.</p>
            </div>
        </div>
      </body>
</html>
