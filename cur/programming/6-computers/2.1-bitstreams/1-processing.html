<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Lab 2: Data Representation and Bits, Page 1</title>
	</head>

	<body>
		<h2>Data and Bits</h2>
        <div class="learn">
        	<p><strong>In this lab,</strong> you will explore how different kinds of information are represented in a computer.</p>
        	<p><strong>On this page,</strong> you will meet the central ideas of <em>bits</em> and <em>bit sequences.</em></p> 
        </div>
        
        <h3>One Bit</h3>
        <p>As you know, information travels over wires inside the computer, and because of the digital abstraction, each wire is either <em>on</em> or <em>off,</em> with no intermediate states allowed.  This small piece of information is called a <strong>bit</strong>, the smallest possible unit of information in the digital domain.</p>

        <div class="vocabFullWidth">
            <strong>: Bit</strong>
            <p>A <strong>bit</strong> is a single unit of data that can only have one of two values. We generally represent the two values as &quot;0&quot; and &quot;1.&quot;</p></div>

<p>What does a bit <em>mean?</em> By convention, the two states of a bit are labelled 0 and 1, but don't think that that means they have to represent numbers. A single bit can represent:
<ul><li>False and True.</li>
<li>Off and On, simulating a light switch.</li>
<li>Red and Green, simulating a traffic light.</li>
<li>... and many more.</li></ul>
<p>But what if the traffic light also has a yellow value?  It's tempting to say that, for example, 0 volts on the wire means red, 1 volt means yellow, and 2 volts means green.  But then we would have all the problems of electrical noise that the digital abstraction was designed to avoid.
<p>Instead, we use <em>more than one bit</em> if we need to represent more than two possible values.  So, for the traffic light, we could use two bits:
<table width="40%" align="center" border="4" cellspacing="8">
  <tr>
    <th scope="col"><div align="right">first bit</div></th>
    <th scope="col"><div align="left">second bit</div></th>
    <th scope="col"><div align="left">meaning</div></th>
  </tr>
  <tr>
    <td align="right">0&nbsp;</td>
    <td>&nbsp;0</td>
    <td>&nbsp;red</td>
  </tr>
  <tr>
    <td align="right">0&nbsp;</td>
    <td>&nbsp;1</td>
    <td>&nbsp;yellow</td>
  </tr>
  <tr>
    <td align="right">1&nbsp;</td>
    <td>&nbsp;0</td>
    <td>&nbsp;green</td>
  </tr>
  <tr>
    <td align="right">1&nbsp;</td>
    <td>&nbsp;1</td>
    <td>&nbsp;&nbsp;&nbsp;(unused)</td>
  </tr>
</table>
<p>There are four possible combinations of two bits, so with two bits we can represent up to four different values, although we needed only three for the traffic light.</p>

<div class="forYouToDo">
<ol><li>Convince yourself that there aren't any more combinations of two bits.</li>
<li>Write down all the possible combinations of <em>three</em> bits.  How many are there?</li>
<li>How many combinations of <em>four</em> bits are there?</li></ol></div>
<p>Each added bit <em>doubles</em> the number of values you can represent. This means that representing complex situations doesn't cost a lot of hardware; ten bits is enough to represent over 1000 distinct values.</p>

<div class="forYouToDo">
<ol start="4">
  <li>How many values, exactly?</li>
  <li>How many bits do you need to represent the days of the week?</li>
  <li>How many bits do you need to represent one decimal digit?</li>
</ol>
</div>
<p>Bits aren't expensive, but what <em>is</em>  expensive is circuitry to let the programmer use exactly the smallest number of bits for a particular problem. </p>

        <div class="endnote">
            <p><a href="#hint-ldb" data-toggle="collapse">Some old computers did allow that.</a>
          <div id="hint-ldb" class="collapse">The PDP-10, that big blue computer you saw in Lab 1, had
          <code>ldb</code>
(Load Byte) and
<code>dpb</code>
(Deposit Byte) machine language instructions that included operands (inputs, essentially) for the width of the desired byte (how many bits) as well as location operands for the exact memory position of those bits.</p>
            <p>This much control over the use of memory was great for a machine that would largely be programmed at the machine language level, the lowest possible level of abstraction in the software domain. As higher level languages grew in popularity, computer architecture designers learned that <em>compilers,</em> the programs that translate a high level language into the machine language that the computer can actually run, could generate more efficient translations if the machine language was as simple as possible, doing a few things really quickly rather than doing a lot of things at varying speeds.</p></div></div>
            
<p>Modern computers generally allow memory allocation in two sizes: the <strong>byte</strong>, which is standardized at eight bits, and the <strong>word</strong>, which can be 32 bits or 64 bits wide.</p>
<div class="vocabFullWidth">
<p>A <strong>byte</strong> is eight bits.</p>
<p>A <strong>word</strong> is 32 or 64 bits.</div>
<div class="takeNote">
  <p>How many distinct values can be represented in 32 bits? You shouldn't have to memorize the answer, because you can quickly figure out an approximation to the answer. The trick depends on the fact that 2<sup><small>10</small></sup> = 1024, which is about 1000. So every ten bits of width multiplies the number of values by 1000. So 10 bits is  a thousand values, 20 bits is a million values, 30 bits is a billion values, and 32 bits is four billion, because the extra two bits can represent four values. The exact answer is 4,294,967,296 so this approximation is pretty close.</p></div>  
  <p>Four billion values sounds like it ought to be enough for anybody, but it's not if you're an astronomer or a banker, or Google or Facebook.  And you learned in Unit 4 that 32 bits are not enough to give every computer an Internet address.  That's why we now have 64-bit computers. </p>
  <div class="endnote">It's also not enough to count all the different orders into which a deck of cards can be shuffled.  Some early Internet gambling sites had trouble with math hackers who'd keep winning because, knowing the order of the first half of the deck, they could predict the order of the rest of the deck.</div>
  <div class="forYouToDo">
<ol start="7"><li>About how many different values can be represented in a 64-bit word?</li></ol></div>

  <p>The main use of eight-bit bytes is to represent characters of text.  

<div class="forYouToDo">
<ol start="8">
  <li>How many bits do you need to represent the 26 letters in English, the 10 digits, and a few punctuation characters?</li></ol></div> 

    <div class="endnote">
            <p><a href="#hint-ascii" data-toggle="collapse">Click for some history about character representation.</a>
      <div id="hint-ascii" class="collapse">
        <p>So, in a pinch you could use a six-bit-wide character code, and computers did that for many years. But if you want both <em>UPPER CASE</em> and <em>lower case</em> letters, you need seven bits. The first officially recognized character encoding was the seven bit ASCII (American Standard Code for Information Interchange). It included an optional eighth bit for error detection.</p>
  <p>Note the word &quot;American&quot; in the name of ASCII. In the early days of computers, most of them were in the United States, where we speak a language with a very small alphabet. Speakers of Spanish, French, German, and some other European languages use basically the same Latin alphabet, but with accented characters, as in the name of the main developer of Snap<em>!</em>, Jens MÃ¶nig. (The closest English sound is the &quot;u&quot; in &quot;lunch.&quot;) So European computer users took over the eighth bit to double the number of characters, to include the ones they needed.</p>
  <p>The widespread use of eight-bit ASCII is the main historical reason why the eight-bit byte became standard. (Another reason is that computer circuitry can most easily deal with widths that are powers of two.)</p>
  </div></p></div>

<p>Eight bits per character was enough space for most American and European languages, but as the use of computers and the Internet spread around the world, people naturally wanted to be able to write Chinese or Japanese or Arabic or Kabyle  or Russian or Tamil or... The <em>Unicode</em> character set supports about 1900 languages, using 32 modern alphabets and 107 historical alphabets that are no longer in living use.  The complete character set includes 136,755 characters. (This does not include 52 semi-standardized unofficial alphabets, including Klingon and Elvish.)</p>

<div class="forYouToDo">
<ol start="9"><li>What's the minimum number of bits needed to represent any Unicode character?</li></ol></div>

    <div class="endnote">
            <p><a href="#hint-unicode" data-toggle="collapse">The actual computer representation of Unicode is complicated.</a>
      <div id="hint-unicode" class="collapse"><p>The most straightforward representation of Unicode uses one 32-bit word per character, which is more than enough. But program developers consider that an inefficient use of computer memory, and also, a lot of old software still in use was written when eight bits per character was standard. So Unicode characters are generally represented in a <em>multi-byte</em> representation in which the original 128 ASCII characters occupy one byte, while other characters may require up to four bytes. (It's also possible in this representation to use a multi-byte sequence to tell your word processing software that until further notice you want one-byte codes to represent a specific non-Latin alphabet.)</p></div></p></div>


<h3>Larger Bit Sequences</h3>

<table><tr><td>        <img  src="/bjc-r/img/6-computers/Hardware_img/RAM.jpg" height="200" alt="RAM (Random Access Memory), short-term memory" title="RAM (Random Access Memory), short-term memory" /><br />
<small><i>computer memory</i></small></td>

<td>        <img src="/bjc-r/img/6-computers/Hardware_img/HardDiskDrive.gif" height="200" alt="Hard Drive, long-term memory" title="Hard Drive, long-term memory" /><br />
<small><i>disk drive (case opened)</i></small></td></tr></table>

    <p>So far we've been working with small chunks of data, from Boolean values (one bit) to characters (eight bits). But of course some information in your computer or smartphone is much bigger than that.</p>
    <p>For starters, characters aren't generally used one at a time; they're used in <em>text strings</em> such as &quot;<code>Welcome to the Beauty and Joy of Computing.</code>&quot; These 43 characters occupy 43 bytes of computer memory. (In many programming languages there's a convention that every text string ends with a <em>null</em> byte, in which all eight bits are zero, a code that's reserved for this purpose. So our string might actually occupy 44 bytes.)</p>
    <p>But the real champion users of space are media files: pictures, sounds (mostly music), and video. For example, the spinning disk drive picture above takes up about 16Mb â 16 million bytes.</p>
<!--        <p>When we write, we often symbolize <em>off</em> as 0 and <em>on</em> as 1, but the memory is not storing zeros and ones. Bits are electric signals; they are either <em>on</em> or <em>off</em>. When we test a bit to see if it's on, the test returns a Boolean value: if the bit is <em>on</em>, it returns <code>true</code>; otherwise, it returns <code>false</code>.</p>
       
   <div class="endnote">
        	 That's why this happens:<br />
            <p class="center"><img src="/bjc-r/img/6-computers/true+true=2.png" alt="true + true = 2" title="true + true = 2"/></p>
        </div>
        <p>We also use 1 and 0 and in place of <code>True</code> and <code>False</code> as a convenient shorthand. -->
        <p>If we could see inside the memoryâs bits and we wrote it as zeros and ones, a section of the memory might look something like this:</p>
        <div class="blockquote">
        	<code class="break">01000001001000000111001101101101011000010111001001110100001000000111000001101000011011110110111001100101001011000010000001101100011010010110101101100101001000000111100101101111011101010111001000100000011011000110000101110000011101000110111101110000001000000110111101110010001000000110010001100101011100110110101101110100011011110111000000100000011000110110111101101101011100000111010101110100011001010111001000101100001000000110001101100001011011100010000001110011011101000110111101110010011001010010000001101110011101010110110101100010011001010111001001110011001011000010000001110000011010010110001101110100011101010111001001100101011100110010110000100000011101000110010101111000011101000010110000100000011011010111010101110011011010010110001100101100001000000110000101101100011011000010000001101011011010010110111001100100011100110010000001101111011001100010000001110100011010000110100101101110011001110111001100101110001000000100001001110101011101000010000001110100011010000110010100100000011110100110100101101100011011000110100101101111011011100010000001101100011011110110001101100001011101000110100101101111011011100111001100100000011010010110111001110011011010010110010001100101001000000110100101110100011100110010000001101101011001010110110101101111011100100111100100100000011001000110111101101110001001110111010000100000011000110110111101101110011101000110000101101001011011100010000001110000011010010110001101110100011101010111001001100101011100110010000001101111011100100010000001100101011101100110010101101110001000000110111001110101011011010110001001100101011100100111001100101110001000000100010101100001011000110110100000100000011011000110111101100011011000010111010001101001011011110110111000100000011010000110111101101100011001000111001100100000011000010010000001100010011010010111010000100000011011110110011000100000011101000110100001100001011101000010000001101001011011100110011001101111011100100110110101100001011101000110100101101111011011100010110000100000011000010111000001110000011100100110111101110000011100100110100101100001011101000110010101101100011110010010000001100011011000010110110001101100011001010110010000100000011000010010000000100010011000100110100101110100001011000010001000100000011101110110100001101001011000110110100000100000011010010111001100100000011010100111010101110011011101000010000000100010010011110110111000100010001000000</code>
        </div>
        <div class="vocabBig">
        	<strong>: binary sequence</strong><p>A binary sequence (also called a <em>bitstream</em>) is a collection of bits, in a particular order. </p></div>       
             <p>That shows just 2369 bits. A 16GB cell phone has sixteen gigabytes (about 16 billion bytes) of storage, each byte containing 8 bits. That's 128,000,000,000 bits. Printed on paper as ones and zeros, the 16 GB phoneâs memory would take nearly 40,000,000 pages! The information in storageâwhether it is a text message, a photograph, a song, a computer program, or a list of phone numbersâlooks just the same, a sequence of bits that are either On or Off (one or zero). A sequence of these bits is a binary sequence. So if pictures, music, and words all look the same in memoryâall binary sequencesâhow can the computer tell what any chunk of memory actually is? For example, should the sequence 01000001 be interpreted as the number 65, the letter A, a rather dark shade of red, or something else?</p>

<div class="todo">I'm assuming that the next three paragraphs are meant to satisfy some requirement, but it's not clear to me what EKs are involved.  For example, does the discussion of high level languages in the second paragraph below give us something not in the earlier discussion on 6.1.3? -bh</div>
		<p>When your phoneâs camera stores a picture in memory, your phone translates that picture, pixel by pixel, into a long binary sequence and then adds extra information (also a binary sequence, of course, because thatâs the only way information exists in a computerâs memory) saying how much information (how many bytes) to read in order to reproduce the whole picture, and how those bytes are to be interpreted. In the case of a picture, bytes are interpreted as shades of a color. If the information stored is the name of the state capital, each byte might be interpreted as a letter.</p>
        <p>Many designers are involved in building a device like the smart phone. Some work with high level languages (like Snap<em>!</em>) that let them specify how things should workâlike where icons or buttons should appear on the screen and what should happen when they are touchedâwithout also having to think about how all the information is stored inside the machine. Working with a high level language at a high level of abstraction allows them to think about the overall logic, without worrying about low level details.</p>
        <p>But someone in the design team for the phone does have to tell the phoneâs camera-program how to translate pictures (or text or sound) into a form the memory can store, and how to generate the extra information that says how much data to retrieve for that picture, and that each byte of that data is to be interpreted as color information, not something else.</p>

<h3>Sizes</h3>
<p>Do words such as &quot;gigabyte&quot; feel familiar to you? If you live anywhere but the United States, you're accustomed to buying a kilogram of meat or a 10-milligram dose of some medicine. But in the US, you may have heard of these units only in science classes. Here are a few rough examples of what kind of data would fit in how much memory:</p>
        <div class="endnote">
            <table class="byte indent">
                <tr>
                    <td><strong>measure</strong></td>
                    <td style="width:300px;"><strong>amount</strong></td>
                    <td style="width:300px;"><strong>example</strong></td>
                </tr>
                <tr>
                    <td>bit</td>
                    <td>either a 1 or a 0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>byte</td>
                    <td>8 bits</td>
                    <td>11011001</td>
                </tr>
                <tr>
                    <td>kilobyte</td>
                    <td>2<sup>10</sup> (1,024) bytes</td>
                    <td>a couple of paragraphs</td>
                </tr>
                <tr>
                    <td>megabyte</td>
                    <td>2<sup>20</sup> (1,048,576) bytes</td>
                    <td>about 1 book</td>
                </tr>
                <tr>
                    <td>gigabyte</td>
                    <td>2<sup>30</sup> (1,073,741,824) bytes</td>
                    <td>a little more than 1 CD</td>
                </tr>
                <tr>
                    <td>terabyte</td>
                    <td>2<sup>40</sup> (1,099,511,627,776) bytes</td>
                    <td>about 1,500 CDs</td>
                </tr>
                <tr>
                    <td>petabyte</td>
                    <td>2<sup>50</sup> (1,125,899,906,842,624) bytes</td>
					<td>about 20 million filing cabinets of text</td>
                </tr>
            </table>
        </div>

<p>When you write a big number such as 1,234,567,890 you put commas every three digits (counting from the right). Each group of three has a name: thousand, million, billion, and so on. So that number is pronounced &quot;one billion, 234 million, 567 thousand, 890.&quot; Those group names (&quot;thousand&quot; and so on) also have prefix names used in metric measurements:</p>
<table width="54%" border="4" cellspacing="8">
  <tr>
    <th width="50%" scope="col">prefix</th>
    <th width="50%" scope="col">amount</th>
  </tr>
  <tr>
    <td>kilo-</td>
    <td><p>thousand</p></td>
  </tr>
  <tr>
    <td>mega-</td>
    <td>million</td>
  </tr>
  <tr>
    <td>giga-</td>
    <td>billion</td>
  </tr>
  <tr>
    <td>tera-</td>
    <td>trillion</td>
  </tr>
  <tr>
    <td>peta-</td>
    <td><p>quadrillion</p></td>
  </tr>
  <tr>
    <td>exa-</td>
    <td>quintillion</td>
  </tr>
  <tr>
    <td><em>milli-</em></td>
    <td><em>thousandth</em></td>
  </tr>
  <tr>
    <td><em>micro-</em></td>
    <td><em>millionth</em></td>
  </tr>
  <tr>
    <td><em>nano-</em></td>
    <td><em>billionth</em></td>
  </tr>
  <tr>
    <td><em>pico-</em></td>
    <td><em>trillionth</em></td>
  </tr>
  <tr>
    <td><em>femto-</em></td>
    <td><em>quadrillionth</em></td>
  </tr>
  <tr>
    <td><em>atto-</em></td>
    <td><em>quintillionth</em></td>
  </tr>
</table>
<p>(The lines in <em>italics</em> in the table represent fractions: 1/1000, 1/1000000, etc.)</p>
<p>As we write this in 2017, it's common to have a terabyte disk drive on your desk. Web services deal with petabytes or exabytes of data. The fractional names are used to measure times in the computer, such as a nanosecond memory access time, or distances between wires on a chip, which are measured in nanometers.</p>
<p>Exactly how much data fits on a terabyte disk? If it were a terabyte of main memory inside the computer, it would be 2<sup>40</sup>or 1,099,511,627,776 bytes (about 1.1 trillion). But disk drive manufacturers measure sizes in powers of ten, not powers of two, so a terabyte of <em>disk</em> is exactly one trillion bytes â 10% smaller than the same amount of memory.</p>

    <div class="endnote">
            <p><a href="#hint-disks" data-toggle="collapse">Do you find that annoying?</a>
      <div id="hint-disks" class="collapse">
      <p>You're not the only one.</p>
      <p>To make things worse, some operating systems measure the capacity of a disk in powers of two, so what the manufacturer calls a 1TB disk will be displayed in file listings as 909.5GB.</p>
      <p>Yet another standards group, the International Electrotechnical Commission, has established a different set of prefixes for things measured in powers of two. Each of these is the first two letters of a metric prefix, followed by &quot;bi&quot; for binary. So, instead of &quot;kilo&quot; for 10<sup>3</sup>, we're supposed to say &quot;kibi&quot; for 2<sup>10</sup>. Similarly, &quot;mega&quot; (10<sup>6</sup>) becomes &quot;mebi&quot; (2<sup>20</sup>), &quot;giga&quot; becomes &quot;gibi,&quot; and so on.  So the memory size generally called 4GB (gigabytes) should officially be called 4GiB (gibibytes).</p>
      <p>These names are starting to appear in operating system software, but so far, nobody actually uses them in conversation (other than our colleague, Berkeley Professor Dan Garcia, who's very into them). For example, if you look very closely at the memory boards pictured above, you'll see that each of them is labelled as 512MB, not 512MiB.</p>
      </div></p></div>
<div class="todo">Can we please move the following to Unit 4?  It just doesn't fit here.

		<div class="vocabFullWidth">
            <ul>
                <li><strong>bit rate</strong> &ndash; the amount of data (measured in bits) that can be sent in a specific amount of time</li>
                <li><strong>bandwidth</strong> &ndash; the transmission capacity of a system (measured by bit rate)</li>
                <li><strong>latency</strong> &ndash; time between the transmission and the receipt of a message</li>
            </ul>
        </div>
<h3>Cloud Storage</h3>

Locally (on your computer), the binary sequences that make up data are temporarily stored in RAM and are stored long-term on your hard drive, but they can also be stored in the cloud. "The cloud" just means "somewhere on the Internet but you don't really know where." You have been using the cloud throughout this whole course. All of your Snap<em>!</em> projects are stored in the cloud; they aren't on your local computer. That's why you have to log in to access your projects. Similarly, if you use Google Drive or Dropbox, all of those files are stored in the cloud. And if you use a web-based email service (such as Gmail or Yahoo), your emails are stored in the cloud.       
      
    </body>
</html>