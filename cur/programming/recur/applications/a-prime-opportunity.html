<!DOCTYPE html>
<html><head><!-- put the following in exactly --><script type="text/javascript" src="/bjc-r/llab/loader.js"></script><title>Background</title><!--ORIGINAL NAME: A Prime Opportunity--></head><body>A <a href="http://en.wikipedia.org/wiki/Prime_numbers">prime number</a> is defined as a natural number that has exactly two distinct natural number divisors (1 and itself). They have a number of mathematical uses, and are also very important to modern encryption techniques.<br><br><div style="text-align: center;"><span style="font-weight: bold;">The First 16 Primes:</span><br></div><br><table border="1" align="middle" width="100%"><tbody><tr><td width="25%" valign="top">2<br></td>
    <td width="25%" valign="top">3<br></td>
    <td width="25%" valign="top">5<br></td>
    <td width="25%" valign="top">7<br></td>
  </tr><tr><td width="25%" valign="top">11<br></td>
    <td width="25%" valign="top">13<br></td>
    <td width="25%" valign="top">17<br></td>
    <td width="25%" valign="top">19<br></td>
  </tr><tr><td width="25%" valign="top">23<br></td>
    <td width="25%" valign="top">29<br></td>
    <td width="25%" valign="top">31<br></td>
    <td width="25%" valign="top">37<br></td>
  </tr><tr><td width="25%" valign="top">41<br></td>
    <td width="25%" valign="top">43<br></td>
    <td width="25%" valign="top">47<br></td>
    <td width="25%" valign="top">53<br></td>
  </tr></tbody></table><br>How can we find prime numbers computationally? The most obvious solution might be to test individual numbers to determine if they are prime by finding the number of factors that they have. Why would this be a non-ideal approach?<br><br>A Greek mathematician named Eratosthenes came up with a more effective technique long before computers were around. He developed a technique, now called the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> (SoE), around 200 BC. Variations of this technique still rank as one of the most computationally efficient means of generating reasonably small prime numbers. Conveniently for us today, the SoE can be efficiently implemented using recursion!<br><h2>The Sieve of Eratosthenes</h2>
<p>The Sieve of Eratosthenes is actually a very simple technique from a mathematical standpoint; it approaches the problem of finding factors from the <span style="font-style: italic;">opposite direction</span> than what may seem natural. Instead of finding factors of each individual number, it finds products of individual factors and rules them out as being non-prime numbers. It starts at the smallest prime number, 2, rules out all of the numbers that it divides into evenly (4, 6, 8, 10, etc) and continues up the list of possibilities until all of the non-prime numbers have been removed. Wikipedia has an excellent illustration:<br></p>
<p style="text-align: center;"><img border="0" src="/bjc-r/img/sys/sieve-of-eratosthenes.gif" alt="Sieve of Eratosthenes Animation" title="Sieve of Eratosthenes Animation" origsrc="http://veritas.eecs.berkeley.edu/courses/file.php/17/Animation_Sieve_of_Eratosthenes.gif"><br></p>
<p>Wikipedia also <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm">outlines the algorithm</a> itself, where <span style="font-style: italic;">n</span> is the highest number under consideration (120 in Wikipedia's illustration) and <span style="font-style: italic;">p</span> is the current prime number (initially 2):</p>
<p style="margin-left: 40px;">To find all the prime numbers less than or equal to a given integer <i>n</i> by Eratosthenes' method:</p>
<ol style="margin-left: 40px;"><li>Create a list of consecutive integers from two to <i>n</i>: (2, 3, 4, ..., <i>n</i>).</li>
  <li>Initially, let <i>p</i> equal 2, the first prime number.</li>
  <li>Strike from the list all multiples of <i>p</i> less than or equal to <i>n</i>. (<i>2p, 3p, 4p, etc.</i>)</li>
  <li>Find the first number remaining on the list after <i>p</i> (this number is the next prime); replace <i>p</i> with this number.</li>
  <li>Repeat steps 3 and 4 until <i>p</i><sup>2</sup> is greater than <i>n</i>.</li>
  <li>All the remaining numbers in the list are prime.</li>
</ol><h2>Goal</h2>Implement a block labeled "find all prime numbers between X and Y." Here are some important guidelines and rules:
<ul><li>You will need to create multiple types of blocks, including a couple of recursive blocks!</li>
  <li>The resulting numbers should be stored in a list and displayed on the stage.<br></li>
</ul>This can be an intimidating problem if tackled as a whole. Try breaking it up into multiple sub-problems (one potential sub-problem: filling a list with the numbers from 2 to Y) and solving those individually. Some things to consider:<br><ul><li>Use a list to hold all of the numbers that haven't been ruled out as you process them. Start off by adding all of the numbers between 2 and Y to this list. <br></li>
  <li>The sieve technique will only allow you to determine primes between 2 and Y -- you cannot adjust the lower boundary directly. You will have to do this as an additional step.</li>
  <li>Not <span style="font-style: italic;">every</span> block has to be recursive.<br></li>
</ul></body></html>
