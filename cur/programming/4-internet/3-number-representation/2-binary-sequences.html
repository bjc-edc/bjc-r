<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <title>Unit 4 Lab 3: Number Representation, Page 2</title>
	</head>

	<body>
		<h2>Binary Sequences</h2>
        <div class="todo">
        	GH Feedback 1/16/16 (from Dan??):
            <ul>
                <li>big wall of text, this could very easily be split into a few discrete chunks.</li>
                <li>Sci notation: This should be more optional / review focused. Sci Notation, I believe is common core 8th grade math.</li>
                <li>unless required by the AP spec, floating point details clearly need to be labeled as optional, or at the very least "this is tricky"
                  <ul>
                    <li>No. The AP is not the standard of what's optional or not in BJC. BJC isn't a CS Principles course; it's a serious computer science course that also happens to prepare you for the CS Principles exam. --bh</li>
                  </ul>
                </li>
                <li>bit context: deserves it's own page, perhaps with simple multiple choice questions</li>
                <li>though an important sentence, that highlight is terrible, distracting and confusing. If we want it emphasized, make it a heading and repeat it 2-3 times.</li>
            </ul>
            More GH Feedback:
            <ul>
            	<li>Not sure this much "good" and "bad" is really necessary. Students should learn to enjoy each language for their different strengths.</li>
                <li>Also the example, while it should be told, should be about testing not about good and bad.</li>
			</ul>
        </div>
        
        <div class="forYouToDo" id="first">
			<ol>
				<li>
                    The <em>factorial</em> of a positive integer <em>n </em>(written "<em>n</em>&thinsp;!") is the product of all the integers from 1 to <em>n</em>. For example:<br /> 
                    <span class="katex-block">5! = 1 \times 2 \times 3 \times 4 \times 5 = 120</span>
                    Load <a class="run" href="/bjc-r/prog/4-internet/U4L3-BigNumbers.xml">this project</a>, and try out these inputs:<br />
                    <img class="indent" src="/bjc-r/img/4-internet/bang10.png" alt="(10) ! reporting 3628800"  title="(10) ! reporting 3628800" /><br />
                    <img class="indent" src="/bjc-r/img/4-internet/bang20.png" alt="(20) ! reporting 2432902008176640000" title="(20) ! reporting 2432902008176640000" /><br />
                    <img class="indent" src="/bjc-r/img/4-internet/bang30.png" alt="(30) ! reporting 2.6525285981219103e+32" title="(30) ! reporting 2.6525285981219103e+32" />
                </li>			   
			</ol>
        </div>
        
        <img class="imageLeft" src="/bjc-r/img/icons/take-turns-speaking-mini.gif" alt="Take turns speaking" title="Take turns speaking">
        <p>
            Take a closer look at the result of <code>30!</code> It's in scientific notation; the "e" means "times ten to the power," so the reported number is:
          <span class="katex-block">2.6525285981219103 \times 10^{32} = 265252859812191030000000000000000</span>
        </p>
        <p><strong>Why did Snap<em>!</em> display <code>20!</code> in ordinary, whole number representation but <code>30!</code> in scientific notation?</strong> As you know, computers use bits to store information, including numbers. Every computer model is designed with a certain "<strong>width</strong>"&mdash;the number of bits that the processor reads from or writes into memory at a time. That number of bits is called a "<strong>word</strong>." So, on a 64-bit computer: the processor width is 64, so it can read/write 64 bits at a time; and 64 bits is considered one "word."</p>
        <p>As of 2016, most new computers are 64 bits wide, but there are still a lot of 32-bit computers around. (If you got an answer in scientific notation for 20!, you're using a 32-bit computer.) The first commercially available microprocessor, the Intel 4004, first sold in 1971, was only 4 bits wide!</p>
		<div class="endnote">Processor widths don't have to be a power of two; there have been 12-bit, 36-bit, and 60-bit computers (these were not personal computers but computers like those you see in old movies <em>that filled a large room</em>). Modern personal computers started at 8 bits and the widths have been doubling with each new generation.</div>
		<div class="sidenote">The largest representable positive integer is actually one less than 2<sup>63</sup> because zero takes up one of the positive integer digits.</div>
        <p>On a 64-bit computer, if you want to represent both positive and negative integers, you can fit 2<sup>63</sup> = 9223372036854775808 of each. (2<sup>63</sup> positive numbers and 2<sup>63</sup> negative numbers makes 2<sup>63</sup> + 2<sup>63</sup> = 2 × 2<sup>63</sup> = 2<sup>64</sup>.) The number 2<sup>63</sup> is about 9 quintillion, 9×10<sup>18</sup>, so 19-digits. That means that the 19-digit value of 20! just fits in a word on a 64-bit computer, but the 33-digit value of 30! does not.</p>
        
        <div class="forYouToDo">
        	<ol start="2">
                <li>What's the first integer whose factorial doesn't fit in a word (on your computer)?</li>
            </ol>
        </div>
        
        <p>All computers have a finite (limited) amount of memory. But even for a 64-bit computer, that limit is way more than 64 bits; your computer probably has 137 <em>billion</em> or more bits of memory. <strong>So, why can't programming languages just use more than one word if necessary to represent an integer?</strong></p>
        <div class="sidenote">A language interpreter translates code into instructions for the computer. Every programming language as one running underneath.</div>
        <p>They can. It's just that computers can add two words in a single machine instruction, whereas the programmer of the language interpreter has to work harder to do arithmetic on multiple-word values. (A multiple-word integer value is called a "<strong>bignum</strong>.") Some programming languages do that; bignum languages can work with <em>any</em> number that isn't so impossibly large that it fills up all of the available memory on the whole computer. And that's great! The whole point of computer science is abstraction, and one important kind of abstraction is protecting the user from having to know about hardware limitations. However, many programming languages limit integer values to what fits in one word.</p>
        <div class="takeItFurther"><img class="imageRight" src="/bjc-r/img/icons/tough-stuff-mini.png" alt="Tough Stuff" title="Tough Stuff" /><p>An excellent example of a language that handles multiple-word integer values (e.g. bignums) is <a href="http://groups.csail.mit.edu/mac/projects/scheme/index.html" target="_blank">Scheme</a>. You can learn it from <a href="https://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank">Structure and Interpretation of Computer Programs</a>, one of the best computer science books ever written.</p></div>
        
        <!--<div class="endnote">This business about good and bad languages isn't just a question of taste; it can be a matter of life and death.  Between 1985 and 1987, a therapeutic X-ray machine called the Therac-25 killed four patients and seriously injured two more because of several bugs in its software; one of the bugs was that a usage counter kept in an 8-bit-wide variable would reach its maximum value of 127 and then <em>overflow</em> to 0 instead of 128.  When the variable was 0, an important safety check was not performed.  This would not have happened if the Therac software had been written in a good programming language.</div>-->
        
        <h3>Bignums</h3>
        <div class="forYouToDo">
            <ol start="3">
                <li>
                    Locate the <code>use bignums</code> block, drag it into the scripting area, drag <code>true</code> into the input slot, and run the script:<br />
                    <img class="indent" src="/bjc-r/img/4-internet/bignums-true.png" alt="use bignums (true)" title="use bignums (true)" /> 
                </li>
                <li>
                    Now try <code>30!</code> again.<br />
                    <img class="indent" src="/bjc-r/img/4-internet/bang30-bignum.png" alt="(30) ! reporting 265252859812191058636308480000000" title="(30) ! reporting 265252859812191058636308480000000"/><br />
                    <div class="endnote">Note that this (exactly correct) value is different from the (rounded off) <em>floating point</em> value you got before. (More about floating point values in a moment.)</div>
                </li>
                <li>
                    Try <code>200!</code>. The resulting speech balloon won't fit on your screen, but you can view it this way:
                    <img class="imageRight" src="/bjc-r/img/4-internet/script-pic.jpg" alt="script pic drop down menu" title="script pic drop down menu" />
                    <ol type="a">
                        <li>Hold down the shift key and right-click or control-click the <code>200!</code> block.</li>
                        <li>In the menu that appears, click on the red "script pic with result" item.</li>
                        <li>You'll see a new browser tab with a small picture. Click on the picture and it should expand to readable size with a scroll bar at the bottom of the screen.</li>
                    </ol>
                </li>
                <li>How many digits are there in 200!&thinsp;? Hint: Don't count by hand; use Snap<em>!</em></li>
                <li>
                    Turn bignums off by setting the input to <code>use bignums</code> to <code>false</code>, and try 200! again.<br />
                    <img class="indent" src="/bjc-r/img/4-internet/200bang-fixnum.png" alt="(200) ! reporting infinity" title="(200) ! reporting infinity"/>
                </li>
            </ol>
        </div>
   
        <p>What's going on here? The number 200!, although it's very large, isn't infinite, and computers are perfectly capable of handling it. This is also the result of a size limitation. The <em>floating point</em> representation that computers use for non-integers (and, in a non-bignum language, integers that are too big for the integer representation) can only represent numbers up to about 10<sup>308</sup>. But 200! is about 8×10<sup>374</sup> (as you saw in problem 8), so the non-bignum version of Snap<em>!</em> can't handle it. If the result of a computation is bigger than 10<sup>308</sup>, then floating point hardware returns a special code that represents infinity, but that's not a <em>real</em> infinity like the number of real numbers.</p>
        
        <h3>Floating Point Values</h3>
        <p>Floating point is essentially a binary version of scientific notation.</p>
        <p>
            Here's the binary representation of 20! in 64-bit integer format:
            <span class="katex-block">0010000111000011011001110111110001000010101101000000000000000000</span>
            As an integer, that pattern of bits represents 243290200817664000. But floating point representation, <em>that same pattern of bits</em> represents
            <span class="katex-block">4.85611351839403586987046017196 \times 10^{-146}</span>
        </p>
        <p> 
        	A 64-bit floating point value has a <strong>sign bit</strong> that's 0 for a positive number or 1 for a negative number; an 11-bit <strong>exponent</strong> part representing the range from 2<sup>-127</sup> to 2<sup>127</sup>; and a 52-bit <strong>fraction</strong> or <strong>significand</strong> part representing the actual digits of the number. 
            <table class="bordered">
                <tr>
                    <td>representation</td>
                    <td>sign bit</td>
                    <td>exponent</td>
                    <td>significand</td>
                </tr>
                <tr>
                    <td>binary</td>
                    <td>0</td>
                    <td>01000011100</td>
                    <td>0011011001110111110001000010101101000000000000000000</td>
                </tr>        
                <tr>
                    <td>decimal</td>
                    <td>positive</td>
                    <td>540</td>
                    <td>958208322830336</td>
                </tr>
            </table>
        </p>
        <p>There are special codes for infinity, -infinity (smaller than any finite value), and "Not a Number," the result of illegal computations such as <span class="katex">\frac00</span>.</p>
        
        <div class="takeNote">The same pattern of bits may <em>also</em> represent an instruction in the machine language of whatever computer you're using. This is very important: <strong>The meaning of a sequence of bits depends on the context in which it is used.</strong></div>
        <p>What exactly do we mean by "context"? How does a programming language know whether to interpret a bit sequence as an integer, a float, a string of characters, an instruction, or something else? Here, too, there is a distinction between good and bad programming languages. In both cases, there's <em>another</em> bit sequence somewhere that encodes the <strong>data type</strong> of the bit sequence. In good languages, that data type code is attached to the value itself. In bad languages, when you make a variable, you have to say what type of value it will contain, and the data type is attached to the <em>variable</em>, so you can't change your mind later. So instead of seeing</p>
        <p><img src="/bjc-r/img/4-internet/varfoo.png" alt="script variables (foo)"></p>
        <p>you see things like</p>
        <p><img src="/bjc-r/img/4-internet/intfoo.png" alt="integer (foo)"></p>
        <p>(We're telling you all these things about bad programming languages not just because it's fun, but also because it's very likely that your <em>next</em> year's computer science class will use a bad language. For example, if you take the AP Computer Science A course, it'll use Java. So you should understand what to expect.)</p>
        <div class="takeNote">All through this page we've been talking about numbers, but don't forget that, at the lowest level of software abstraction, <em>everything</em> in a computer is represented as a binary sequence. A Boolean value is a single bit, 0 for <code>false</code> and 1 for <code>true</code>.
        A character string is a sequence of <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/2-script-variables/2-script-variable-projects.html#secretcode">Unicode character codes</a>, each of which is a small integer&mdash;a sequence of bits. Lists and procedures, too, are binary sequences.</div>
        
        
        
        
        <p>Not only are there infinitely many real numbers, but there are infinitely many of them between any two consecutive integers&mdash;between 2 and 3, for example, there are infinitely many numbers. This means that <em>most</em> real numbers, not just especially large ones, are not exactly representable in this format. Think about the decimal representation of <span class="katex">\frac13</span>, 0.33333... It has infinitely many digits, so the closest you can come in floating point isn't <em>exactly</em> <span class="katex">\frac13</span>. That's why even good programming languages set a limit to the number of digits representable in floating point notation.</p>
        
        <div class="forYouToDo">
            <p>On the other hand, fractions such as <span class="katex">\frac13</span> <em>can</em> be represented exactly using a pair of integers, one for the numerator and one for the denominator.</p>
            <ol start="8">
            	<li>Try<img src="/bjc-r/img/4-internet/one-third.png" alt="1 / 3"> with bignums off and with bignums on.</li>
            </ol>
        </div>

        <div class="takeNote">Computer arithmetic on integers is straightforward.  Either you get an exactly correct result or, if the correct result wouldn't fit in the representation you're using, you get an <strong>overflow error</strong> and the result is, usually, converted to floating point representation.  <!--By contrast, computer arithmetic on floating point real numbers is very, very hard to get exactly right.  Prior to 1985, every model of computer had a slightly different floating point format, and all of them got wrong answers to certain problems.  This situation was resolved by the <strong>IEEE 754</strong> floating point standard, designed by &#x263a; University of California, Berkeley Professor William Kahan, a mathematician and computer scientist who did the first truly adequate analysis of what's required to get answers to floating point computations that are as correct as possible given a limited number of bits.  Today every computer manufacturer uses Professor Kahan's standard (which has been improved several times since 1985).--></div>
        
        
        
	</body>
</html>