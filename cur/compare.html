<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <title>Beauty and Joy of Computing</title>
    </head>
    
    <body>
        <h2>Comparison with CSP Framework</h2>
        <div style="float:right; padding:20px;">
        	<a href="/bjc-r/course/bjc4nyc.html" class="blbtn">BJC Curriculum</a>
        </div>
        <p>Computer programming can be immensely satisfying. You get to be inventive and creative. Programming gives you a kind of authorship and <em>control</em> that's quite beyond what people mostly can get in other activities. It's what Seymour Papert called "hard fun," fun precisely <em>because</em> it is mind-stretching but still under your own control. And, because you can judge correctness yourself—your program either works the way you want or it doesn't—you become the judge, not the judged. If the program doesn't work, it's not a failure but a work in progress; you fix it, alone or with ideas from others. If it does work, you may still want to embellish it with new ideas or more elegant structure. That view of learning—that one can always fix what needs fixing and improve what's already good—and the sense of authority that one gains by being a creator are known to be valuable to kids (and adults). And, of course, the skills and ideas behind programming—the computer <em>science</em> of it—are valuable. Programming <em>is</em> a game of skill, like chess but without the competitive aspect, and with useful results beyond the act of programming itself. These reasons, alone, are enough to make us want <strong>all kids</strong> to have the opportunity to experience the joy of programming.</p>
        <p>Given the chance to learn, programming can also be accessible to many students who have not had success in areas they associate with computers and mathematics and science, or who do not picture themselves as programmers. Precisely <em>because</em> you can see for yourself how your program is behaving, you are in a better position to know what steps to take to improve it than you are in most other subjects.</p>
        <p>And, increasingly, computer science and the ways of thinking and opportunities to create that it opens up, are also a matter of equity. Learning to program doesn't guarantee a job but it certainly widens the field of choices a student can make.</p>
        <p>The designers of BJC also think that computer programs, and not just the pictures and apps that programs can produce, can be things of beauty. Programmers, like mathematicians and writers and engineers, develop a sense of esthetics. This is one reason why we decided to include some topics—in particular <em>recursion</em>—that go beyond the CSP requirements. A recursive program can generate a complex, intricate computing process from a very small piece of code. For many of us who learned to program, that was the revelation that stands out as the moment when we discovered the beauty of programs.</p>
        <p>Preserving the beauty and joy for your students takes thought. Too much scaffolding in a project and the joy and sense of creative power is gone; too little scaffolding and the student can feel helpless and incompetent. We tried to strike a good balance in <a href="/bjc-r/course/bjc4nyc.html">the student materials</a> but you will, of course, need to make your own sensitive decisions. Each page of the student materials and teacher guide has a feedback link to let you help us make the curriculum work better for you.</p>
        
        <div class="CSPpeach">
            <h3>Computer Science Principles</h3>
            <p>
                The College Board <a href="https://advancesinap.collegeboard.org/stem/computer-science-principles" target="_blank">AP CS Principles</a> curriculum framework is organized around seven "Big Ideas" (things to learn) and six "Computational Thinking Practices" (things to do):
                <img class="noshadow" src="/bjc-r/img/compare/pies_new.png" alt="comparison of BJC to CSP Frameworks" title="comparison of BJC to CSP Frameworks" />
            </p>
            <p>Every conforming curriculum must teach all of these, but curricula may differ in the amount of emphasis given to each. (The slices in the pies aren't really quantitative, just a suggestive snapshot of how BJC stands out.)</p>
            <p>There is much overlap between the Ideas and the Practices. Creativity is an Idea, but Creating is a Practice; Abstraction is an Idea, but Abstracting is a Practice. Think of the first pie as representing text in the curriculum materials and the second pie as representing how we expect students to spend their time. The circles at the center of each pie indicate that the idea of Programming and the practice of Creating are at the center of BJC, and intersect with all the others.</p>
            <p>First, the Big Ideas. BJC is proudly <strong><em>Programming</em></strong>-heavy. Snap<em>!</em>, the programming language we use, combines the ease of use of visual programming with expressive power previously found only in the most sophisticated text-based languages. (More on this <a href="#visual">below</a>.) We believe that this combination helps to make programming and powerful ideas inviting and accessible to a diverse audience of beginners, who may initially not think they're interested in programming. BJC goes well beyond the CS Principles requirements, featuring the advanced techniques of recursion and higher order functions.</p>
            <p>We view <strong><em>Abstraction</em></strong> as the central idea of computer science. We emphasize the use of abstraction in the context of programming. This includes both control abstraction to generalize programming patterns and data abstraction to isolate the implementation of an abstract data type from its use.</p>
            <p>Our secondary emphasis is on <strong><em>Global Impact</em></strong>, the social implications of computing. Every unit of BJC uses readings and classroom discussion to explore various aspects of this topic. Details of the topics and teaching goals are <a href="#social">below</a>.</p>
            <p>Two of the remaining four topics are more implicit than explicit in our approach. Students <em>exercise</em> <strong><em>Creativity</em></strong> in their programming projects, but we don't <em>talk about</em> it to the same extent as the other topics. Similarly, students <em>develop</em> <strong><em>Algorithms</em></strong> as they program, but we don't often treat algorithms as a separate topic, except when we are teaching about analysis of algorithms and asymptotic orders of growth.</p>
            <p>The final category of topics, <strong><em>Data</em></strong> and <strong><em>the Internet</em></strong>, are important and are covered thoroughly, but where possible our coverage takes the form of programming activities rather than, for example, using commercial database software.</p>
            <p>Now, about the Practices: The phrase "Computational Artifacts" is meant to encompass videos, slide decks, blogs, programs, music, spreadsheets—anything you can create with a computer. We treat creating as the most important of the Practices. And we see computer programs as the most important artifact students will create because, when a student writes a program, two acts of creation happen at once. The student is interested in the product—a game, for example—and displays creativity in the design of that product. But she creates the game by creating a program, and <em>also</em> displays creativity in the design of the program structure. The latter is the real computer science.</p>
            <p>Just as the idea of abstraction is central to, and inseparable from, the idea of programming, the <em>practice</em> of abstraction is central to programming. We constantly encourage students to use layers of abstraction to structure a programming project.</p>
            <p>"Connecting computing" can mean connecting it to hobbies, or connecting it to industry, or to science. But most importantly, for us, students connect computing to its social implications, our other main focus.</p>
            <p>Almost as important is the practice of analyzing programs: debugging, predicting the behavior of someone else's code, and thinking about efficiency. But we would emphasize that this skill is not an end in itself; it serves the ultimate goal of creating programs that work.</p>
            <p>The two remaining practices—communicating and collaborating—are important precisely because they are <em>not</em> unique to computer science. Like most CSP curricula, we use pair programming, so students are constantly talking with their partners and sharing the work. At the beginning of the course we teach the process of pair programming, and in the discussion of social implications of computing students have to communicate their ideas. Students are constantly <em>engaging</em> in these practices, but BJC doesn't <em>talk</em> about them very much.</p>
        </div>
        
        <h2>Visual Programming<a name="visual">&nbsp;</a></h2>
        
        <div class="visualgreen">
            <p><a href="http://snap.berkeley.edu/" target="_blank">Snap<em>!</em></a>, the programming language designed to support this course, uses the <a href="http://scratch.mit.edu/" target="_blank">Scratch</a> design of drag-and-drop blocks but adds power that is essential for developing advanced ideas and programs.</p>
            <p>
            The visual metaphors of the Scratch design give it a very low entry threshold, which is why it is routinely learned by self-taught eight-year-olds. The  shapes and colors remind users of the block categories.<br />
                <img class="indent" src="/bjc-r/img/compare/flagsquare.png" alt="when greenflag clicked, pen down, repeat (4) (move (100) steps, turn CW (90) degrees)" title="when greenflag clicked, pen down, repeat (4) (move (100) steps, turn CW (90) degrees)" />
            </p>
          <p>The C-shaped block is a loop, and visually encloses the code that should be repeated. Green blocks are about drawing; blue blocks are about motion.</p>
            <p>But because Scratch was designed to be usable by eight-year-olds, its designers left out some key capabilities for teaching computer science. Snap<em>!</em> adds the needed abstraction capabilities, while preserving the  carefully designed visual metaphors to aid understanding:</p>
        </div>
        
        <div class="visualcyan">
            <p>
            	For control abstraction, Snap<em>!</em> users can build their own blocks, including functions as well as action scripts.<br />
                <img src="/bjc-r/img/compare/makeablock.png" alt="'Make  Block' dialog" title="'Make  Block' dialog" />&nbsp;&nbsp;&nbsp;
                <img src="/bjc-r/img/compare/blockeditor.png" alt="Block editor" title="Block editor" />&nbsp;&nbsp;&nbsp;
                <img src="/bjc-r/img/compare/scriptwithblock.png" alt="when greenflag clicked, pen down, square (100)" title="when greenflag clicked, pen down, square (100)" />
            </p>
            <p>This capability is essential to the Abstraction big idea, but it also lets us teach recursion, through which a small program can have a very complex result:</p>
            <p><img src="/bjc-r/img/compare/tree-and-branch-for-demo-page.png" width="500" alt="tree and branch scripts">&nbsp;&nbsp;&nbsp;
            <img src="/bjc-r/img/compare/demo-tree-growing.gif" width="300" alt="growing tree animation"></p>
        </div>
        
        <div class="visualpurple">
            <p>
            	Because Snap<em>!</em> blocks can take other blocks or scripts as inputs, and because of the very simple notation used for anonymous functions, we can teach the even more powerful control abstraction of higher order functions:<br />
				<img class="indent" src="/bjc-r/img/compare/plusfour.png" alt="map (( ) + (4)) over {7, 8, 1} reporting {11, 12, 5}" title="map (( ) + (4)) over {7, 8, 1} reporting {11, 12, 5}" />
            </p>
            <p>
                This capability, first class procedures, makes Snap<em>!</em> more powerful and expressive than most text-based programming languages. The visual representation makes procedure as data seem concrete to students, as in this <em>list of procedures:</em><br />
                <img class="indent" src="/bjc-r/img/compare/blocks.png" alt="list of blocks" title="list of blocks" />
            </p>
        </div>
        
        <div class="visualyellow">
            <p>
            	Finally, because lists are first class data in Snap<em>!</em>, we can build abstract data types and use them in larger data structures, such as this triangle:<br />
				<img src="/bjc-r/img/compare/pointlist.png" alt="'point' data type" title="'point' data type" />
            </p>
        </div>
        
        <div class="visualsalmon">
            <p>
            	Snap<em>!</em> also provides access to the Javascript environment in which it is implemented. <br />
				<img class="indent" src="/bjc-r/img/compare/speakblock.png" alt="speak block definition using Javascript" title="speak block definition using Javascript" />
  </p>
            <p>(The picture shows a one-liner, but there is no limit to the length or complexity of the Javascript function defined by the block.) With this capability we can have our cake and eat it too, with respect to the (pointless, we think) argument about block languages vs. text languages. We don't teach Javascript in BJC, but it's available as an enrichment activity if desired.</p>
        </div>
        
        <div class="visualsalmon">
            <p>Also, because Snap<em>!</em> runs in any modern browser, students can make mobile apps for iOS or Android by putting a shortcut to the project's URL on the device's desktop. From the browser we can't access phone-specific information such as contact list or GPS position (standalone versions are in the works), but things like video game projects work fine.</p>
        </div>
        
        <div class="visualsalmon">
            <p>Snap<em>!</em> also connects with several robots and sensors (Finch, Hummingbird, Sphero, Lego NXT, Wiimote, LEAP Motion, Arduino, etc.) by way of small applications installed on the local computer.</p>
        </div>
        
        <div class="socialorange">
            <h2>Social Implications of Computers<a name="social">&nbsp;</a></h2>
            <p>
            Here are the topics included in the BJC units:
            <table width="100%">
                <tbody>
                    <tr>
                        <td>
                            <ul class="tight">
                                <li>Privacy and Search Engines</li>
                                <li>Video Games and Violence</li>
                                <li>Owning Ideas (Copyrights and Patents)</li>
                                <li>Encryption</li>
                                <li>Innovation</li>
                                <li>
                                    Computers and Community
                                    <ul>
                                        <li>social networks</li>
                                        <li>cyberbullying</li>
                                    </ul>
                                </li>
                                <li>Computers and War</li>
                                <li>Computers and Work</li>
                            </ul>
                        </td>
                        <td>
                        	<a href="http://bitsbook.com/" target="_blank"><img src="/bjc-r/img/compare/book-bits.png" height="250px" alt="Blown to Bits" title="Blown to Bits" /></a>
                        </td>
                    </tr>
                </tbody>
            </table>
            </p>
            <p>We take the stand that <em>any</em> technology has risks and benefits, and that <em>people</em>  decide how to minimize risks and maximize benefits. Therefore, in each topic,  we have students evaluate alternate points of view. For example, rather than shut down debate on the downloading of copyrighted works (e.g., music), which many students do, we try to open the issue by eliciting honest perspectives on both  the value and harm in it, and whether there are ways to protect the value and remedy the harm (e.g., by considering alternate ways to support artists and writers). Both student pages and the Teachers' Guide point to provocative readings on each topic.</p>
<p>In general, we hope to leave students feeling optimistic about the benefits of technology, but also ready to think critically about any <em>specific</em> technology. We also remind them that the decisions about how a new technology is used are made by human beings, including themselves if they pursue a career in computer science, so they shouldn't feel helpless in the face of a supposed technological imperative.</p>
            <p>We use the excellent <a href="http://bitsbook.com/" target="_blank"><em>Blown to Bits</em></a> as the textbook for this part of the course. (There is no textbook for the technical parts of the course, beyond the online materials we provide.) The book is aimed at adult readers, and will be difficult especially for ESL students, so we use short excerpts and discuss alternative presentations in the Teachers' Guide. Like the rest of the course materials, this book is avaliable free online, with a Creative Commons BY-NC-SA license.</p>
            <p>The book is a few years old now, so we supplement it with current readings, looking for topics that will be relevant to students. Students choose their own topics to study in more depth; this is one way we appeal to a diverse audience. We start class meetings with "Computing in the News," presenting items from that morning's newspaper, one generally positive and one problematic. After some teacher-chosen examples to illustrate the idea, we encourage teachers to assign the selection of articles to students in rotation.</p>
        </div>
               
    
    </body>
</html>