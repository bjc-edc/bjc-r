<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 7 Teacher Guide</title>
	</head>

	<body>
		<h2>Programming Lab 2: Sorting</h2>
		<p>In this lab, students develop their own sorting algorithm, then investigate two common sorting algorithms, selection sort and partition sort, built on recursion. A discussion at the end, along with a Take It Further, address the concept that one sort can be significantly faster than another on large data sets.</p> 
		

		<h3>Pacing:</h3>
		<div>
			The 3 lab pages could be split across 3 or 4 days (130-200 minutes). Expected times to complete follow:
			<ul>
				<li>40-60 minutes (1 class period) on <a href="/bjc-r/cur/programming/7-recursive-reporters/2-sorting/1-sorting-a-list.html?topic=nyc_bjc%2F7-recursive-reporters.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Sorting a List</a></li>
				<li>40-60 minutes (1 class period) on <a href="/bjc-r/cur/programming/7-recursive-reporters/2-sorting/2-selection-sort.html?topic=nyc_bjc%2F7-recursive-reporters.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Selection Sort</a></li>
				<li>50-80 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/7-recursive-reporters/2-sorting/3-partition-sort.html?topic=nyc_bjc%2F7-recursive-reporters.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Partition Sort</a></li>
			</ul>
		</div>




		<h3>Students will:</h3>
		<div class="sidenoteBig">
			<strong>Looking Ahead</strong>
			<ul>
				<li>Students' work on recursive algorithms, notably understanding the need and use of base cases, will guide their work in Lab 3.</li>
			</ul>
		</div>
		<div>
			<ul>
			<li>Work with recursive reporters.</li>
				<li>Build their own sorting algorithm, then implement it in Snap<em>!</em>.</li>
				<li>Compare and contrast the selection and partition sorts.</li>
			</ul>
		</div> 
			  
		
		<h3>As a Class:</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Sorting a List.</strong>
					<ul>
						<li>
							Discussion: What makes a sorting algorithm work?
							<ul>
								<li>What useful operations could a computer perform in a sorting algorithm?</li>
								<li>How is sorting using a computer program different from sorting "by hand"?</li>
								<li>How could you tell if a list is completely sorted?</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					<strong>Page 2: Selection Sort.</strong>
					<ul>
						<li>
							Discussion: How does recursion work in a selection sort?
							<ul>
								<li>What is the base case, and why is it necessary?</li>
								<li>How can you be sure a selection sort will always get to a base case?</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					<strong>Page 3: Partition Sort.</strong>
					<ul>
						<li>
							Discussion: How does recursion work in a partition sort?
							<ul>
								<li>What is the base case, and why is it necessary?</li>
								<li>How can you be sure a partition sort will always get to a base case?</li>
								<li>In what ways is the recursion in the partition sort different from the recursion in a selection sort?</li>
							</ul>
						<li>
							Discussion: What differences are there between selection and partition sorts?
							<ul>
							<li>How could you tell which sort is more efficient?</li>
							<li>How long does it take these algorithms to sort twice as many items?</li>
							</ul>

						</li>
					</ul>
				</li>
			</ul>
		</div>
			
		<h3>Tips:</h3>
		<div>
            <ul>
            	<li>
                	<strong>Page 1: Sorting a List.</strong>
                    <ul>
						<li>Some students may have trouble translating their algorithms to computer code; this typically means the student does not have a clear picture of their own algorithm. Ask them to write the algorithm in sentences or pseudocode, or even just describe it verbally to another student.</li>
						<li>Don't worry if some students write a non-recursive sort. The next two pages will focus on recursive sorting algorithms. If there is time, look for an opportunity to find, present, and compare two very similar algorithms, one recursive and one not.</li>
						<li>If students are having trouble dealing with strings, allow them to use lists of numbers in their work. They should find that their algorithm automatically works with strings.</li>
						<li>Sometimes, a student will build an algorithm that sorts in reverse order. This is a good opportunity for discussion, if it occurs, about how to edit an algorithm for another purpose. In Lab 4, students will have an opportunity to redesign <code>sort</code> to take any comparison function as an input, which allows it to support sorting in either order.</li>
                    </ul>
                </li>
            	<li>
                	<strong>Page 2: Selection Sort.</strong>
                    <ul>
					<li>When students are doing the "live" sort, don't let them cheat! Make them follow the algorithm precisely, so they can understand how it works. You might also want to stand in a position that moves, separating the sorted portion of the list from the remaining unsorted portion.</li>
						<li>If students have trouble with the <code>earliest in</code> block, work with numbers: students should notice this is the same algorithm as finding the <strong>minimum</strong> of the list.</li>
						<li>There's more than algorithm for finding the location of the <code>earliest in</code> result, but the simplest is to just run across the list until you find the first match. Ask students why there must be a match. Some students will build their own block for this, but it is not necessary.</li>
						<li>When possible, stress the importance of the base case.</li>
						<li>You can challenge students to write this algorithm without "deleting" an item, by either exchanging two items or moving an item to the front through swaps. For large lists this can be an efficient algorithm since the list never change size.</li>
                    </ul>
                </li>
            	<li>
                	<strong>Page 3: Partition Sort.</strong>
                    <ul>
					<li>Like before, when students are doing the "live" sort, don't let them cheat! Make them follow the algorithm precisely, so they can understand how it works. You might want to stand with the "pivot" at the time of sorting. After the first sort, go to the front half and sort it completely, using as many levels of recursion as needed, then do the same for the back half. When possible, stress that you are doing the same thing to a smaller list, which is why the algorithm eventually succeeds.</li>
					<li>Some students will want to skillfully select a "pivot" in an attempt to make the two halves roughly equal, but this is not how the algorithm works. Time spent trying to skillfully select the pivot has a serious impact on the speed of the overall sort.</li>
					<li>Discuss the base case again, and note the differences between partition sort, where the base case is arrived at multiple times, and selection sort, where the base case is only seen once.</li>
					<li>Advanced groups may be interested in a deeper dive into computing time. While the Take It Further establishes that partition sort is faster for large lists, significantly more so the larger the lists get, you can choose to introduce the O(<em>n</em><sup>2</sup>) and O(<em>n</em> log <em>n</em>) notations for these two sorts. There is an explanation of this notation <a href="http://www.crsr.net/Notes/BigO.html">here</a>.</li>
                    </ul>
                </li>
            </ul>
        </div>

			
		<!--<h3>Solutions</h3>
		<div><ul><li>...</li></ul></div>-->
			
<!--			
		<h3>Correlation with AP CS Principles Framework<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<h4>Essential Understandings:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul>
			<h4>Learning Objectives:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul>
		</div>			
-->

	</body>
</html>
