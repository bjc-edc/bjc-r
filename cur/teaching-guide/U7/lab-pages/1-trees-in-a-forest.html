<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 7 Lab 1 Teacher Guide</title>
	</head>

	<body>
		<h2>Programming Lab 1: Trees in a Forest</h2>
        <p>Recursion is the use of a procedure within itself. The definition is simple, but learning to <em>use recursion</em> takes opportunity and practice; learning it well requires care in the order in which ideas are presented.</p>
        <p><img class="imageRight noshadow" src="/bjc-r/img/6-recursion/recursive-tree.gif" alt="fractal tree" title="fractal tree" />Unit 7 introduces recursion in the context of fractal graphics, i.e., pictures that include smaller versions of themselves.  The canonical example is the fractal tree, in which each branch is a smaller sub-tree with branches of its own.</p>
        <div class="endnote">A note on terminology: Technically, no picture of a fractal <em>is</em> a fractal; the picture is just an <em>approximation</em>. A fractal is a limit, so a picture would have to have infinitely many levels.  You might want to say this once but, as with any geometric figure, a good approximation shows us enough to picture the limit.</div>
<p>The work on trees walks students through steps that help them overcome the feeling that a recursive call is "cheating" because it uses a block that hasn't been fully written yet. To avoid this confusion, we start with a sequence of simpler (non-recursive) tree blocks, each of which calls the one before it (e.g., <code>tree 2</code> calls <code>tree 1</code>; <code>tree 3</code> calls <code>tre e2</code>; and so on.)  A few students will want to jump immediately to the recursive version. Unless they are already quite comfortable with recursion from some other learning, it's worth going through this level-by-level once to feel the structure; starting on the next page they'll write recursive procedures directly.</p>
		<p>The reason why we do not start with <em>tail recursion,</em> in which the sole recursive call comes at the tail end, like this</p>
		<img class="indent" src="/bjc-r/img/6-recursion/tail-countdown.png" alt="to countdown(num): if num=0 say &quot;Blastoff!&quot; else say num for 1 secs, countdown(num-1)" title="to countdown(num): if num=0 say &quot;Blastoff!&quot; else say num for 1 secs, countdown(num-1)" />
        <p>is that students often misunderstand the recursive call at the end to mean "go back to the beginning." This wrong mental model  works for tail recursive blocks, but fails when students confront (or must design) a recursive call that can't be at the end of the definition. Embedded recursion, in which the recursive call <em>isn't</em> the last thing in the script, provides a more resilient introduction.</p>
        <p>The repetition on page 1 of is deliberate: the tactile experience of building almost the same script repeatedly helps students notice its structure, and helps them see the virtue of combining them into a single script using recursion. Resist the temptation to teach them shortcuts, like duplicating scripts and adjusting them.)</p> 

		<h3>Pacing:</h3>
		<div>
			The 5 lab pages could be split across 2 or 3 days (<strong>75-140 minutes</strong>). Expected times to complete follow:
			<ul>
				<li>30-50 minutes (~1 day) on <a href="/bjc-r/cur/programming/7-recursion/1-trees/1-recursive-tree.html?topic=nyc_bjc%2F7-recursion-trees-fractals.topic&course=bjc4nyc.html&novideo&noassignment">Recursive Tree</a></li>
				<li>30-50 minutes (~1 day) on <a href="/bjc-r/cur/programming/7-recursion/1-trees/2-base-case.html?topic=nyc_bjc%2F7-recursion-trees-fractals.topic&course=bjc4nyc.html&novideo&noassignment">The Base Case</a></li>
                <li>about 15 minutes (&lt;1 day) on <a href="/bjc-r/cur/programming/7-recursion/1-trees/3-tree-input-self-check.html?topic=nyc_bjc%2F7-recursion-trees-fractals.topic&course=bjc4nyc.html&novideo&noassignment">Self-Check: <code>Tree</code> Input</a></li>
                <li>about 15 minutes (&lt;1 day) on <a href="/bjc-r/cur/programming/7-recursion/1-trees/4-tree-variations-self-check.html?topic=nyc_bjc%2F7-recursion-trees-fractals.topic&course=bjc4nyc.html&novideo&noassignment">Self-Check: <code>Tree</code> Variations</a></li>
                <li>5-40 minutes (&lt;1 day) on <a href="/bjc-r/cur/programming/7-recursion/1-trees/5-vary-your-tree.html?topic=nyc_bjc%2F7-recursion-trees-fractals.topic&course=bjc4nyc.html&novideo&noassignment">Vary Your Tree</a> (depending on which problems are undertaken)</li>
			</ul>
		</div>


		<!--<h3>Prepare:</h3>
		<div>
			<ul>
				<li></li>
			</ul>
		</div>-->


		<h3>Students will:</h3>
		<!--<div class="sidenoteBig">
			<strong>Looking Ahead</strong>
			<ul>
				<li></li>
			</ul>
		</div>-->
		<div>
			<ul>
				<li>Get a collective introduction to recursion through the <code>Vee</code> project, which selects blocks to draw from a list of shape blocks that includes the <code>vee</code> block itself.</li> 
                <li>Revisit the idea of state transparency.</li>
                <li>Develop a recursive program by first creating the program with several non-recursive blocks and then combining them into one recursive block to perform the same function.</li>
                <li>Learn the basic ideas and terms of recursion including base case, recursive case, and infinite loop.</li>
                <li>Explore and develop variations of the fractal tree.</li>
			</ul>
		</div> 
			  
	
		<img class="imageRight noshadow" src="/bjc-r/img/6-recursion/vee-complex2.png" alt="vee calling vee" title="vee calling vee" />
		<h3>As<a name="vee" class="anchor">&nbsp;</a>a Class:</h3>
		<div>
            <ul>
                <li>
                    <strong>Before starting the lab pages:</strong>
                	<p>This unit begins with a teacher demonstration because the collective gasp when the first complex picture appears is unforgettable. <code>Vee</code> is a great introduction to recursion because its use of randomness lets you ignore completely the annoying detail of base cases in recursive code. Students who've seen the demo, therefore, aren't ready to write their own recursive programs, but they're motivated to work through the first lab.</p>
                    <ul>
                    	<li>
                            Before students get started, project Snap<em>!</em>, choose "Open..." from the File menu, and select "Vee" from the list of example projects.<br />
                            <img class="indent" src="/bjc-r/img/6-recursion/example-projects.png" alt="Open... example projects, Vee" title="Open... example projects, Vee">
                        </li>
                    	<li>At this point, the list of shapes does <em>not</em> include Vee itself.</li>
                        <li>Click the green flag several times and ask students to <strong>describe what the <code>vee</code> procedure does</strong>. Type the space key to show the block definition and discuss how the steps of the procedure generate the images that appear. <em>Do not</em> call students' attention to the fact that <code>shapes</code> is a list of blocks; if a student asks about it, just acknowledge that that's what it is.</li>
                        <li>Then ask students, "<strong>What will happen if we add <code>vee</code> to the list of shapes?</strong>" Type the uparrow key to do this. You will likely hear answers such as "We'll  sometimes get another v-shape on one of the ends."</li>
                    	<img class="imageRight noshadow" src="/bjc-r/img/6-recursion/list-of-shape-blocks.jpg" alt="list of shape blocks" title="list of shape blocks" />
                        <li>Then  click the green flag a few more times, stopping after the first significantly complex image appears. Ask students, "<strong>What happened when the <code>vee</code> block called itself?</strong>" Don't worry about getting to a precise answer here; the idea is just to instill a sense of the power behind the simple process of calling a procedure from within itself.</li>
                    </ul>
                    <p>Note that the <em>list of blocks</em> in the corner of the stage (shown right)	 is something the students won't have seen before, but resist the temptation to talk about it. Students will come to understand it by themselves because they've seen lists before and they've seen blocks before.</p>
                </li>
                <li>
                    <strong>Page 1: Recursive Tree.</strong>
                    <ul>
                        <li>
                        	Discussion Questions:
                            <ul>
                                <li>What is <strong>state transparency</strong>? Why is it important? Have you run into issues with state transparency before? What happened and how did you resolve it? Students may remember <a href="/bjc-r/cur/programming/1-introduction/4-grids-for-games/1-building-tic-tac-toe.html?topic=nyc_bjc%2F1-intro-loops.topic&course=bjc4nyc.html&novideo&noassignment">Debugging Blocks within Blocks in Unit 1</a>, where a script intended to draw five blocks in a row by using a <code>draw square</code> block five times fails because the <code>draw square</code> block leaves the sprite in a different orientation than it started.</li>
                                <li>Project the <code>tree 2</code> block definition together with an image of the result and ask students to describe the role of each block on the resulting drawing. Do the same for <code>tree 3</code>.</li>
                                <li>
                                    These questions encourage students to attend  closely to the details of how the trees are drawn and which aspects are essential to the structure and which are simply aesthetic choices:
                                    <ul>
                                        <li>Why are we multiplying size by 0.65 and 0.85? What if we used other values?</li>
                                        <li>Why are we multiplying size by -1? What if we used a different value?</li>
                                        <li>Why are we turning 25&deg; CCW and then 25&deg; CW and then 35&deg; CW and then 35&deg; CCW? What does that do? How could we simplify the code?</li>
                                        <li>Why do we subtract 1 from the level in <code>tree</code>?</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                	<strong>Page 2: The Base Case.</strong>
                    <ul>
                        <li>
                        	Discussion Questions:
                            <ul>
                                <img class="imageRight" src="/bjc-r/img/6-recursion/tree.png" alt="correct tree block definition" title="correct tree block definition" />
                                <li>Have students describe <strong>recursion</strong> in their own words.</li>
                                <li>Have students share their work on the last "For You To Do" problem, identifying the <strong>base case</strong> and <strong>recursive case</strong> in the final (corrected) <code>tree</code> script and describing how recursion works in this script.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Page 3: Self-Check: <code>Tree</code> Input</strong> and <strong>Page 4: Self-Check: <code>Tree</code> Variations.</strong>
                    <ul>
                        <li>Students can work on these pages at their own pace.</li>
                        <li>The first self check asks students to consider the impact of various changes to the value in the <code>tree</code> <var>level</var> input slot.</li>
                        <li>The second asks students to consider what changes to the script would have created several variations on <code>tree</code>.</li>
                    </ul>
                </li>
                <li>
                    <strong>Page 5: Vary Your Tree.</strong>
                    <ul>
                        <li>Discussion: <em>After students work through the lab page</em>, you may wish to have students share their favorite creations and the code behind them.</li>
						<li>Debugging: <a href="https://docs.google.com/document/d/1UiveZpSSNUtYTwxZ8HzbZ_eTaGAp3LCKDaJVVvboyi8/edit?usp=sharing" target="_blank">Random Tree</a></li>
                    </ul>
                </li>
                
			</ul>
    </div>


		<!--<h3>Assignments:</h3>
		<div><ul><li>...</li></ul></div>

			
		<!--<h3>Look For:</h3>
		<div><ul><li>...</li></ul></div>-->

			
		<h3>Related Resources:</h3>
		<div>
            <p>These resources spend a lot of time with examples that could be done iteratively. They are provided as additional reading for teachers but not recommended for students.</p>
            <ul>
                <li><a href="http://interactivepython.org/runestone/static/thinkcspy/Recursion/TheThreeLawsofRecursion.html" target="_blank">The Three Laws of Recursion</a> article from "How To Think Like a Computer Scientist"</li>
                <li><a href="http://interactivepython.org/runestone/static/thinkcspy/Recursion/intro-VisualizingRecursion.html" target="_blank">Visualizing Recursion</a> article from "How To Think Like a Computer Scientist"</li>
                <li><a href="https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/recursion" target="_blank">Recursive Algorithms on Khan Academy</a></li>
            </ul>
        </div>

			
		<!--<h3>Tips:</h3>
		<div><ul><li>...</li></ul></div>-->

			
		<!--<h3>Solutions</h3>
		<div><ul><li>...</li></ul></div>-->
			
			
		<h3>Correlation with AP CS Principles Framework:<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul>-->
			<h4>Essential Understandings:</h4>
			<ul>
				<li><strong>EU 2.2</strong> Multiple levels of abstraction are used to write programs or create other computational artifacts.</li>
                <li><strong>EU 5.3</strong> Programming is facilitated by appropriate abstractions.</li>
			</ul>
			<h4>Learning Objectives:</h4>
			<ul>
				<li><strong>LO 2.2.2</strong> Use multiple levels of abstraction to write programs. [P3]</li>
				<li><strong>LO 4.2.1</strong> Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]</li>
                <li><strong>LO 5.3.1</strong> Use abstraction to manage complexity in programs. [P3]</li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<ul>
				<li><strong>EK 2.2.2B</strong> Being aware of and using multiple levels of abstraction in developing programs helps to more effectively apply available resources and tools to solve problems.</li>
                <li><strong>EK 5.3.1A</strong> Procedures are reusable programming abstractions.</li>
                <li><strong>EK 5.3.1L</strong> Using lists and procedures as abstractions in programming can result in programs that are easier to develop and maintain.</li>
			</ul>
		</div>			


	</body>
</html>
