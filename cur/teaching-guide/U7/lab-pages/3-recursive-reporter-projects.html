<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 7 Teacher Guide</title>
	</head>

	<body>
		<h2>Programming Lab 3: Recursive Reporter Projects</h2>
		<p>This lab features four programming projects where recursive reporters play a significant role:</p>

<ul>
<li><strong>Pascal's Triangle.</strong> This problem asks students to compute values in Pascal's Triangle, a branched recursive function. The code closely follows the idea that each number in the triangle is the sum of two numbers above it. There is some discussion of the efficiency of the recursion, and some options for improving it.</li>
<li><strong>Base Conversion.</strong> This problem asks students to display a number in a different base. The work begins in base 2 and extends to any base, and also involves converting back to base 10. While this problem can be solved using iteration, the recursive solution is more elegant.</li>
<li><strong>Ice Cream Bowls.</strong> This problem asks students to enumerate the different options at an ice cream shop, given a set of flavors. The complexity of the problem increases through extending the number of flavors purchased and the option to duplicate flavors. One challenge is that the result is a list of lists, so students have to be careful to remember whether the input to a  block is a list of simple elements or a list of lists.</li>
<li><strong>Subsets.</strong> This problem asks students to list the 2<sup><em>n</em></sup> subsets of a given set (list), extending the Ice Cream Bowls problem to an unlimited number of purchased flavors. The algorithm for enumerating subsets is tricky, and the coding of the recursion has a tricky base case. This problem should not be attempted before at least one of the others.</p>
</li>
</ul>		
		
<div class="takeNote">
		<p>There are many different ways to use this lab, but one approach is for students to select and work on one of the projects, moving to another if they finish early. There is some crossover between projects; if you expect a student to work through more than one project, you might suggest they start with the Pascal's Triangle project. If a student is interested in the Subsets project, they may want to try the Ice Cream Bowls project first.</p>
		</div>		
		

		<h3>Pacing:</h3>
		<div>
			Depending on worked projects, this lab can take between 2 and 14 days (100-700 minutes). Expected times to complete follow:
			<ul>
				<li>100-200 minutes (2-4 class periods) on <a href="/bjc-r/cur/programming/7-recursive-reporters/3-projects/1-pascals-triangle.html?topic=nyc_bjc%2F7-recursive-reporters.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Pascal's Triangle</a></li>
				<li>100-150 minutes (2-3 class periods) on <a href="/bjc-r/cur/programming/7-recursive-reporters/3-projects/3-binary-conversion.html?topic=nyc_bjc%2F7-recursive-reporters.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Base Conversion</a></li>
				<li>100-150 minutes (2-3 class periods) on <a href="/bjc-r/cur/programming/7-recursive-reporters/3-projects/5-ice-cream-bowls.html?topic=nyc_bjc%2F7-recursive-reporters.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Ice Cream Bowls</a></li>
				<li>100-200 minutes (2-4 class periods) on <a href="/bjc-r/cur/programming/7-recursive-reporters/3-projects/6-subsets.html?topic=nyc_bjc%2F7-recursive-reporters.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Subsets</a></li>
			</ul>
		</div>

		<h3>Students will:</h3>
		<div class="sidenoteBig">
			<strong>Looking Ahead</strong>
			<ul>
				<li>In the next lab, students will learn that higher-order functions follow the same structure as the reporters they have been building in this unit. Base Conversion is particularly aligned to the style of those functions, but any projects can be used before the next lab.</li>
			</ul>
		</div>
		<div>
			<ul>
				<li>Work through one or more challenging projects, each of which can be solved through the use of recursive reporters.</li>
				<li>Investigate the role of base cases and recursion in the code they produce.</li>
			</ul>
		</div> 
			  
		
		<h3>As a Class:</h3>
		<div>
			<ul>
				<li>
					<strong>Project 1: Pascal's Triangle.</strong>
					<ul>
						<li>
							Discussion: How is recursion structured in Pascal's Triangle?
							<ul>
								<li>What are the base cases?</li>
								<li>What potential problems could happen if the base cases are not well specified?</li>
								<li>What problems are caused by the structure of recursion here, and how could you solve them?</li>
							</ul>
						</li>
					</ul>
				</li>

				<li>
					<strong>Project 2: Base Conversion.</strong>
					<ul>
						<li>
							Discussion: How is recursion structured in Base Conversion?
							<ul>
								<li>What are the base cases?</li>
								<li>What potential problems could happen if the base cases are not well specified?</li>
								<li>What parts of the algorithm and base cases change when extending beyond binary conversion?</li>
								<li>How does the <code>from base</code> conversion algorithm compare to the <code>base</code> conversion algorithm?</li>
							</ul>
						</li >
					</ul>
				</li>
				<li>
					<strong>Project 3: Ice Cream Bowls.</strong>
					<ul>
						<li>
							Discussion: How is recursion structured in Ice Cream Bowls?
							<ul>
								<li>What are the base cases?</li>
								<li>How does recursion reduce the problem to a simpler version of itself?</li>
								<li>How does the algorithm for 2-scoop bowls help you build an algorithm for 3-scoop bowls?</li>
								<li>In what ways is this project similar to <code>tree</code>?</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					<strong>Project 4: Subsets.</strong>
					<ul>
						<li>
							Discussion: How is recursion structured in Subsets?
							<ul>
								<li>Where are the base cases this time?</li>
								<li>How does recursion reduce the problem to a simpler version of itself?</li>
								<li>How can you tell from the recursion that the resulting list will have 2<sup><em>n</em></sup> elements?</li>
							</ul>
						</li>
					</ul>
				</li>

			</ul>
		</div>
			
		<h3>Tips:</h3>
		<div>
            <ul>
            	<li>
                	<strong>Project 1: Pascal's Triangle.</strong>
                    <ul>
						<li>Many students will make errors about the numbers in each row, because of the different indexing involved. It is helpful to tell students that the first number in the <em>n</em>th row is <em>n</em>. Even so, expect many debugging issues to come up around improper indexing.</li>
						<li>For students to write the general recursion here, it is very helpful to give multiple numeric examples like the ones used. More numeric examples are better than trying to explain the generalization directly, because that gives away the code students will write.</li>
						<li>Students will make errors by ignoring the base cases, notably the 1s at the end of a given row. This base case is necessary or an indexing error may occur.</li>
						<li>Students may think something is broken when calling <code>pascal</code> with high inputs: this is the effect of the massive recursion. Including a visible counter variable can show students that things are working. However, you'll need to watch for the difference between a long recursion, and an infinite one caused by an error in base cases.</li>
						<li>Advanced students focusing on memoization may decide to scrap the recursion for iteration, and this is fine; encourage them to use recursion if they can figure out how to do so. The memoization function will track the list of known values, use it when one is available, and record a new value when not available. For a simpler version of memoization, you could ask students to build an efficient calculator of Fibonacci numbers using this concept.</li>
                    </ul>
                </li>
            	<li>
                	<strong>Project 2: Base Conversion.</strong>
                    <ul>
					<li>Some students may get confused by the word <strong>base</strong> here, thinking it connects to <strong>base cases</strong>. These are two different uses of the same word.</li>
						<li>Give students a chance to try the binary conversion problem directly, but chances are they will need the hints from the second page. Most of the solutions that students construct without the hints are iterative instead of recursive. Some students also find the general base conversion problem (or a specific one like base 7) to be easier than binary conversion, so if a student continues to be stuck, switch them to a different base.</li>
						<li>Some solutions will involve lists; students may not know about the <code>list->word</code> block (added by using Import tools) that can solve this problem; it is also possible to write a recursive version using <code>join</code>. The provided solution uses <code>join</code> as part of the recursive step, so it is done as part of the process.</li>
						<li>Watch for errors in base cases when students move beyond binary conversion, since more values should be part of the base case. This is a common mistake.</li>
						<li>Students may need to search to find the <img src="/bjc-r/img/7-recursive-reporters/letterblock.png" alt="letter 1 of 6254 reports 6" /> block, which is very helpful for the <code>from base</code> block.</li>
						<li>A counter variable can count the number of calls if you are interested in talking about how the Base Conversion algorithm is linear time.</li>
                    </ul>
                </li>
            	<li>
                	<strong>Project 3: Ice Cream Bowls.</strong>
                    <ul>
					<li>Make sure students understand that a vanilla-chocolate bowl is the same as a chocolate-vanilla bowl. This is helpful in building a recursive algorithm for the problem; once a flavor is used completely, it can be ignored, with a recursive call to the remaining flavors.</li>
						<li>Expect students to have a lot of difficulty starting; encourage them to list all the 2-scoop bowls for 8 flavors as a start. When students write this list, they should notice that all the options for one flavor are exhausted, then all the options for a second flavor, and so on, which should lead them to understand how recursion can solve the problem.</li >
						<li>If students previously worked through Pascal's Triangle, ask them about connections in this project. The total number of possible bowls is driven by the numbers in Pascal's Triangle, and students can even gain insight into the algorithm: a 3-scoop bowl from 8 flavors is found by either a 2-scoop bowl with 7 flavors (then adding the 8th), or by a 3-scoop bowl from 7 flavors (not using the 8th).</li>
						<li>If students still cannot see a recursive way to code the algorithm, ask them to list all the 2-scoop bowls for 9 flavors, starting with a new ninth flavor you declare. It's likely they will exhaust the ninth flavor, then recognize their previous list as the rest of what is needed.</li>
						<li>Some students will have trouble with the data structure here, since the result is a list of small lists. In particular, using the results from the 2-scoop problem to help solve the 3-scoop problem is challenging. Students who make this leap should be capable of handling the <em>n</em>-scoop case, since it is very similar.</li>
						<li>Students are likely to build separate blocks for 2-scoop and 3-scoop algorithms. When prompted to go for 4 scoops, they are likely to recognize the similarities in the previous work, much like the different algorithms for <code>tree2</code> and <code>tree3</code> eventually led to a single overarching <code>tree</code> block.</li>
						<li>Depending on students' programming structure, allowing repeated flavors can be simple or devastatingly difficult. This is a more difficult extension than it appears.</li>
                    </ul>
                </li>
            	<li>
                	<strong>Project 4: Subsets.</strong>
                    <ul>
						<li>As the hints page notes, the base case is very difficult to get right here. It's very common for students to say that if there is one item in the list, the result should be that item, <em>but this is incorrect</em> because of the empty set. There are two possible base cases students should use: if there is <em>nothing</em> in the list, the result should be a list containing one item, which is an empty list:
						<img src="/bjc-r/img/7-recursive-reporters/emptyset.png" alt="A list of one item, the empty set" />
						<p>If there is one item in the list, the result should be a list of two elements: the empty set, and a list containing the item:
						<img src="/bjc-r/img/7-recursive-reporters/oneitemsubset.png" alt="A list of two items, the empty set and the set of item1" /></p>
						<p>Stressing that the empty set must always be part of the output is a step toward this.</p>
						</li>
						<li>It is also helpful to remind students that the output of <code>subsets</code> is always a list of lists. This can help resolve some of the difficulties around the base case; in many ways it is easier to solve the problem with 3 items than it is with 1!</li>
						<li>If students worked on Ice Cream Bowls, they have a leg up on this project in several ways, both in terms of using lists of lists, and in the concept that leads to the recursive call: an item is either in, or it's out, and either way dictates a simpler set. It is even possible to solve Subsets using only calls to Ice Cream Bowls functions: the subsets of <em>n</em> items are all the <em>n</em>-scoop bowls, and the <em>n</em>-1-scoop bowls, &hellip;, and the 1-scoop bowls, and the 0-scoop bowl.</li>
						<li>The hint page lets students know that the <code>append</code> block will be necessary, and shows the general structure of the block.</li>
						<li>Students will have trouble coming up with <code>map</code> as a means to repeat the item into the half of subsets that contain the item. There are other ways to do it, but <code>map</code> is necessary if attempting to do it within the <code>append</code> line.</li>
						<li>A counter variable can count the number of recursive calls to show that for any <em>n</em>, the basic version of the Subsets algorithm runs in exponential time, with the number of calls doubling each time <em>n</em> increases by one. This is the only one of the algorithms that does not complete in "reasonable time".</li>
						<li><em>However</em>, not all is lost. On the last page, students are given the opportunity to simplify the algorithm by eliminating duplicate calls, turning exponential time into linear time! This is pretty amazing and has an obvious impact on the speed of the algorithm. If possible, ask students to compare the two versions of <code>subsets</code> for speed, especially on larger lists. Note that depending on the algorithms students programmed, this may already have happened; if so, show them the version provided on <a href="/bjc-r/cur/programming/7-recursive-reporters/3-projects/7-subsets-and-efficiency.html">this page</a>.</li>
                    </ul>
                </li>
            </ul>
        </div>

			
		<!--<h3>Solutions</h3>
		<div><ul><li>...</li></ul></div>-->
			
<!--			
		<h3>Correlation with AP CS Principles Framework<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<h4>Essential Understandings:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul>
			<h4>Learning Objectives:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul>
		</div>			
-->

	</body>
</html>
