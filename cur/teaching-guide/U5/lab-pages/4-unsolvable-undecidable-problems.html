<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 4 Teacher Guide</title>
	</head>
    
    <body>
        <h2>Lab 4: Unsolvable and Undecidable Problems</h2>
		<p>In earlier labs of this unit, we've explored <em>practical</em> limits to computation. In some cases, it's easy to program a simple algorithm for a problem, but the program would take centuries to solve the problem even for not-so-big input values. Students often find that idea easy to understand (although they may not immediately see why an exponential-time algorithm will withstand even dramatic speedups in computer hardware). This lab asks them to understand something harder: that some problems can't be solved, period.</p>
		<div class="sidenote">We already know enough about quantum computing to understand that it doesn't influence solvability.</div>
        <p>Students may find it hard to accept the idea that some problems are unsolvable <em>in principle.</em> What if some entirely new model of computation comes along that is not just faster but different in kind, the way quantum computing is different today? Perhaps something like "Tachyonic computing" would allow us to solve these problems? To help students access the idea of an unanswerable question, they solve Liar/Truthteller logic puzzles to see that some are tricky but solvable, some set up inherently contradictory situations in which neither true nor false can apply (paradoxical), and a third kind we just don't have enough information to say what the solution is (undecidable). This demonstrates that there exist problems for which truth or falsity can apply but for which the state cannot (ever) be logically determined. The first page is not about computers or algorithms, but these ideas about logic build toward the second page, which <em>is</em> about algorithms and relies on student understanding of proof by contradiction and the idea of an unanswerable question.</p>
		<!--		<p>Some problems  look like they should have clear and definitive yes/no or true/false answers but, in actuality, don't. In simple cases, the lack of a definitive answer is the result of a paradox, and students can complete the proof to show that the "answer" doesn't exist because the statement is <em>neither</em> true <em>nor</em> false. But situations also exist in which it <em>could</em> be either, but we don't know which. Those fall into two categories. Computational problems can be so difficult that no solution <em>has</em> been found, but it's not clear that no solution<em> could</em> potentially be found some day. Others have been shown to be undecidable: we can prove that we will <em>never</em> have a way to solve the problem. </p>
		<p>As an introduction to this challenging content, students solve Liar/Truthteller logic puzzles to see that some are tricky but solvable, and others set up inherently contradictory situations in which neither T nor F can apply. They also explore the halting problem—can an algorithm be developed that will check <em>any</em> other algorithm to see if it will halt and return a result—to appreciate solvable vs. unsolvable and undecidable problems.</p>  
        -->
		<h3>Pacing:</h3>
		<div>
			The 2 lab pages could be split across 2-4 days (<strong>70-140 minutes</strong>). Expected times to complete follow:
			<ul>
				<div class="comment">Brian and Mary agree to change the name of page 1 to "Proof by Contradiction" next year. --MF, 12/28/17</div>
				<li>30-60 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/5-algorithms/4-unsolvable-undecidable/1-logical-inconsistency.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment">Logical Inconsistency</a></li>
				<li>40-80 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/5-algorithms/4-unsolvable-undecidable/2-halting-problem.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment">An Undecidable Problem</a></li>
			</ul>
		</div> 
        
        <h3>Lab Pages</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Logical Inconsistency.</strong>
					<ul>
                    	<li>
                            <strong>Learning goals:</strong>
                            <ul>
                                <li>Understand <em>proof by contradiction</em>.</li>
                                <li>Use proof by contradiction to solve liar/truthteller logic puzzles.</li>
                                <li>Learn that some problems are unanswerable.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Tips:</strong> 
                            <ul>
                                <li>Paradox <em>isn't</em> the important thing for students to learn on this page. (The unsolvable problem presented on the second page isn't paradoxical.) Rather, it's <em><strong>proof by contradiction</strong></em> that's important. Gamal explains this technique in the first dialog.</li>
                                <li>The student page uses the slightly awkward "false-teller" to avoid digressions into the psychology of liars, though you may enjoy Martin Gardner's discussion of the "which way to the village" problem in <a href="http://www.worldcat.org/title/hexaflexagons-and-other-mathematical-diversions-the-first-scientific-american-book-of-puzzles-games/oclc/18018285" target="_blank">Hexaflexagons and other mathematical diversions</a>. It ends with the delightful suggested question, "Did you know that they're giving away free beer in the village?" You ignore their answer and follow the native.</li>
                            </ul>
                        </li>
						<li><strong>Discussion:</strong> The logic puzzles can be done in small groups, but have a whole-class discussion at the end to be sure everyone understands the idea of proof by contradiction. Use problem #1 in which Adam says, "Eve and I are from the same family," and the Thinking Out Loud dialog below it to focus the discussion.</li>
					</ul>
                </li>
                <li>
                    <strong>Page 2: An Undecidable Problem.</strong>
                    <ul>
                        <li>
                            <strong>Learning goals:</strong>
                            <ul>
                                <li>Understand that some computational problems can't ever be solved, no matter how good the computers become.</li>
                                <li>Understand, specifically, that the Halting Problem is a problem that can't be solved, and that we can <em>prove</em> that.</li>
                                <li>Appreciate that Turing proved this theorem at a time when practical computers barely existed, and that that was a huge advance in human understanding.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Tips about the Halting Theorem:</strong>
                            <ul>
                                <li>
                                    We use proof by contradiction to show that the following question <em>can't</em> be answered <em>in general</em>: <strong>Will a certain computer program, given a certain input, report a result in a finite amount of time?</strong>
                                    <div class="endnote">
                                        <a href="#hint-general" data-toggle="collapse">We <em>can</em> answer the question for some <em>specific</em> functions...</a>
                                        <div id="hint-general" class="collapse">
                                            <p>
                                                The "in general" part is important. Of course we can answer the question for certain particular programs. This one halts (reports a value) for any input:<br />
                                                <img class="indent" src="/bjc-r/img/5-algorithms/three-fn.png" alt="three(x): report (3)" title="three(x): report (3)" /> 
                                            </p>
                                            <p> 
                                                This one never halts for any input:<br />
                                                <img class="indent" src="/bjc-r/img/5-algorithms/loop-fn.png" width="158" alt="loop(x): forever (wait 1 secs)" title="loop(x): forever (wait 1 secs)" /> 
                                            </p>
                                            <p>
                                                And this one halts for any input except 87:<br />
                                                <img class="indent" src="/bjc-r/img/5-algorithms/weird-fn.png" width="158" alt="weird(x): if (x = 87) (forever (wait 1 secs)) else (report (3))" title="weird(x): if (x = 87) (forever (wait 1 secs)) else (report (3))" /> 
                                            </p>
                                            <p>The question is whether we can devise a test that will tell us whether <em>any</em> given function will report a value for <em>any</em> given input.</p>
                                        </div>
                                    </div>
                                </li>
                                <li>
                                To make a proof by contradiction, we start by supposing that there is a <code>halts?</code> function that that takes a function and an input to that function and reports <code>true</code> if the function will terminate when given that input and reports <code>false</code> if it won't.<br />
                                <img class="indent" src="/bjc-r/img/5-algorithms/halts-reporting.png" alt="halts?(round())(7.5) reporting true" title="halts?(round())(7.5) reporting true" /><br />
                                Then, we show that there has to be at least one function and one input to that function for which <code>halts?</code> fails, namely, if we call <code>halts?</code> with the function <code>tester</code> as both the function to be tested and the input to give that function, any result reported by <code>halts?</code> will be wrong.<br />
                                <img class="indent" src="/bjc-r/img/5-algorithms/tester-halting.png" alt="tester(function){if(halts?(function)(function){forever{}}else{report(true)}}" title="tester(function){if(halts?(function)(function){forever{}}else{report(true)}}">
                                <img class="indent" src="/bjc-r/img/5-algorithms/halts-tester-tester.png" alt="halts (tester ()) (tester ())" title="halts (tester ()) (tester ())" />
                                    <ul>
                                        <li>It's crucial to the proof that the function given as input to <code>halts?</code> takes an input, and that <code>tester</code> is written so that it tests that function <em>with itself as input.</em> It's tempting to leave out the input, but this is how we get the self-reference that leads to a contradiction proving that there can be no such <code>halts?</code> function.</li>
		
                                        <li>
                                            Showing that <strong>the result has to be wrong</strong> involves a <em>case analysis</em> like the ones used to solve the logic puzzles on page 1:
                                            <ul>
                                                <li>Suppose <code>halts?</code> reports <code>true</code>, telling us that <code>tester(tester)</code> succeeds at reporting a value. Because <code>halts?</code> reports <code>true</code>, <code>tester</code> takes the first branch of the <code>if</code>, and so it loops forever. Thus <code>tester</code> doesn't halt, and so <code>halts?</code> gave the wrong answer.</li>
                
                                                <li>Now suppose instead that <code>halts?</code> reports <code>false</code>, thereby claiming that <code>tester(tester)</code> never halts. But in that case, <code>tester</code> takes the <code>else</code> branch and reports <code>true</code>, and so <code>halts?</code> is wrong again.</li>
                                                <li>Note that it doesn't matter <em>what</em> value <code>tester</code> reports, just that it reports <em>some</em> value, but it <em>does</em> matter what value <code>halts?</code> reports.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>The second page involves mostly reading and discussion; by the nature of a proof by contradiction, there are no concrete examples students can try individually.</li> 
								<div class="endnote">
                                	<a href="#hint-set" data-toggle="collapse">If you know any set theory...</a>
                                	<div id="hint-set" class="collapse"><p>You shouldn't say this to students, but for your own understanding: there are only countably many computer programs because a program is a finite string from a finite alphabet. But there are uncountably many functions! So <em>almost all</em> functions are uncomputable.  The halting function is just one example that's easy to describe.</p></div>                                
								</div>
							</ul>
						</li>
                        <li>
                            <strong>Tips about the Historical Background:</strong>
							<ul>
                                <div class="endnote">
                                	<a href="#hint-hilbert" data-toggle="collapse">Some historical background on Hilbert, Turing, and Church</a>
                                    <div id="hint-hilbert" class="collapse">
                                        <p>In 1928, mathematician David Hilbert posed the "decision problem," asking whether any statement in certain mathematical theories (in the sense of formal axiom systems, not "things we don't know for sure") can be proven true or false. (This is <em>not</em> one of the numbered list of problems Hilbert famously posed in 1900 as tasks for the coming century.) Turing's work was motivated in large part by this problem; his insight was that to solve the problem, he would need a way to describe what "can be" done effectively. In short, he had to invent the idea of an algorithm. He did this with what is now called the <em>Turing machine,</em> a kind of thought-experiment computer too primitive to be of practical use, but just for that reason, simple enough to reason about.</p>
                                        <p>Turing's 1936 paper was truly remarkable. Not only did he come up with the idea of effective algorithms, he also had to invent the idea that a computer program (the concrete representation of an algorithm) is also data, on which the computer can operate.</p>
                                        <p>(Turing was actually anticipated, slightly, by Alonzo Church, the patron saint of Snap<em>!</em>, who developed a very different formalization, namely the <em>lambda calculus,</em> the  study of functions as data. It's Church's work that led to John McCarthy's invention of the Lisp programming language and to the functional programming style central to BJC. Turing is better known than Church partly because of his war work, but also because the imperative, sequential programming style is more widely understood than functional programming. This is just starting to change because of the importance of functional programming to parallel computation.)</p>
                                    </div>
                                </div>
                                <li>The proof of the halting theorem is much easier for us than it was for Turing, because we have the advantage of an advanced programming language that allows procedures to be used as input values. What Turing had to work with was a particularly simple-minded machine language encoded with ones and zeros. He had to work out how to encode a program and then how to write <em>another</em> program that could examine the first one. Church's proof of the Halting Theorem looked much more like ours than like Turing's because he created a notation for functions of functions. In other words, <em>the proof depends on the fact that</em> <code>tester</code> <em>is a higher order function</em> (it can take functions as inputs).</li>
                                <li>In order to give you, the teacher, discretion about what is or isn't appropriate in your district and for your students, the student page does <em>not</em> describe the end of  Turing's life. Turing was hounded to death—sentenced to chemical castration—by the British government because of his homosexuality. This awful truth about social intolerance can become an important part of classroom discussion if your teaching situation permits it.</li>
                                <li><strong>Extension Activity:</strong> Although it's not directly related to this lab, the story of how Turing enabled the Allied victory against the Nazis is thrilling and engaging. It's told, for example, in the book <a href="http://www.turing.org.uk/book/" target="new"><em>Alan Turing: The Enigma</em></a> by Andrew Hodges. (The link also gives information about other resources on Turing.) Researching Turing's life could be a good extra credit assignment that doesn't involve programming.  Students may also be interested in Joan Clarke, the only woman among the Bletchley Park mathematicians. (The code breakers also employed a large number of women in more clerical positions.)</li>
                            </ul>
                        </li>
					</ul>
				</li>
			</ul>
        </div>   
        
        
		<h3>edX BJC Videos:</h3>
        <div class="sidenote">
            <strong>No YouTube access at your school?</strong><br />
            Try these <a href="/bjc-r/cur/teaching-guide/resources/video-list-scratch.html">Alternate Links</a>.
        </div>
        <div>
        	<ul>
            	<li><a href="https://www.youtube.com/watch?v=bkDuw5sBXeM&index=10&list=PLno6_GYnQv_SOQ7nFjItIdn0Xa9IV4VmH" target="_blank">Limits of Computing: Decidability Part 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=n_zcWPo2y-0&index=11&list=PLno6_GYnQv_SOQ7nFjItIdn0Xa9IV4VmH" target="_blank">Limits of Computing: Decidability Part 2</a> </li>
            </ul>
        </div>


		<h3>Solutions</h3>
		<div>
            <ul>
                <li><a href="/bjc-r/cur/teaching-guide/U5/lab-pages/4b-unsolvable-undecidable-problems-solutions.html">Page 1: Logical Inconsistency.</a></li>
            </ul>
        </div>
			
			
		<h3>Correlation with AP CS Principles Framework:<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
                <li><strong>P1 Connecting Computing</strong> Explain connections between computing concepts.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Create an artifact with a practical, personal, or societal intent.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Select appropriate techniques to develop a computational artifact.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Use appropriate algorithmic and information management principles.</li>
                <li><strong>P3 Abstracting</strong> Explain how abstractions are used in computation or modeling.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Evaluate a proposed solution to a problem.</li>
                <li><strong>P5 Communicating</strong> Describe computation with accurate and precise language, notations, or visualizations.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in solving a computational problem.</li>
                <li><strong>P6 Collaborating</strong> Share the workload by providing individual contributions to an overall collaborative effort.</li>
                <li><strong>P6 Collaborating</strong> Foster a constructive, collaborative climate by resolving conflicts and facilitating the contributions of a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Exchange knowledge and feedback with a partner or team member.</li>
			</ul>-->
			<h4>Essential Understandings:</h4>
			<div class="commentBig">Adapted from <a href="/bjc-r/cur/teaching-guide/resources/BJC-Curriculum-Outline.pdf" target="_blank">2016 Outline</a>: As students learn about solvable vs. unsolvable and undecidable problems, they learn that algorithms can solve many but not all computational problems (<strong>EU 4.2</strong>). This lab builds toward this EU by introducing students to the halting problem as an example of an unsolvable problem, sketching Turing's proof by contradiction using Snap<em>!</em> code rather than Turing Machine code. It requires students to explore and understand proof by contradiction, starting with simple Liar/Truthteller puzzles before using proof by contradiction in the context of the halting problem.</div>
            <p>Students learn about solvable vs. unsolvable and undecidable problems (<strong>EU 4.2</strong>) by exploring Liar/Truthteller puzzles and using proof by contradiction to understand the halting problem. This lab builds toward this EU by sketching Turing's proof of the halting problem by contradiction using Snap<em>!</em> code.</p>
			<ul>
				<li><strong>EU 4.2</strong> Algorithms can solve many but not all computational problems.</li>
			</ul>
			<h4>Learning Objectives:</h4>
			<div class="todo">Adapted from <a href="/bjc-r/cur/teaching-guide/resources/BJC-Curriculum-Outline.pdf" target="_blank">2016 Outline</a>: Students learn the difference between solvable and unsolvable problems (<strong>LO 4.2.2</strong>) and about the existence of undecidable problems (<strong>LO 4.2.3</strong>) through work with the halting problem.</div>
            <div class="todo">Brian, we need to add some summarizing problems to the student pages where student actually <em>explain</em> these things. --MF, 1/3/18</div>
		<p>Students explain their thinking about the statement, "The statement I'm making right now is false," (<strong>LO 4.2.3</strong>).</p>
			<ul>
				<li><strong>LO 4.2.2</strong> Explain the difference between solvable and unsolvable problems in computer science. [P1]</li>
                <li><strong>LO 4.2.3</strong> Explain the existence of undecidable problems in computer science. [P1]</li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<ul>
                <li><strong>EK 4.2.2D</strong> Some problems cannot be solved using any algorithm.</li>
                <li><strong>EK 4.2.3A</strong> An undecidable problem may have instances that have an algorithmic solution, but there is not algorithmic solution that solves all instances of the problem.</li>
                <li><strong>EK 4.2.3B</strong> A decidable problem is one in which an algorithm can be constructed to answer "yes" or "no" for all inputs (e.g., "is the number even?").</li>
                <li><strong>EK 4.2.3C</strong> An undecidable problem is one in which no algorithm can be constructed that always leads to a correct yes-or-no answer.</li>
                <div class="todo">
                Selim thinks the following should be:<br />
                Removed: 4.2.3A, 4.2.3B<br />
                Added: Nothing<br />
                </div>
				<div class="todo">Need to address: EK 4.1.2F The language used to express an algorithm can affect characteristics such as clarity or readability but not whether an algorithmic solution exists. --MF, 11/16/17</div>
			</ul>
		</div>			


	</body>
</html>
