<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Teacher Guide</title>
	</head>
    
    <body>
        <h2>Programming Lab 1: Algorithms</h2>
		<div class="todo">Perhaps, at some point, the entire U2L3-GuessNumber activity should move here. We're  eager to shorten U2 and the game is not essential there. For now, we're writing as if GuessNumber <em>remains</em> in U2L3.</div>
		<p>In  U2L3-GuessNumber, students built a Number Guessing game in which  the <em>computer</em> picks a number, the player tries to guess that number, and the computer tells the <em>player</em> if the guesses are too high or too low.</p>
		<p> In this lab, U5L1, students  design an algorithm and program the computer so that <em>it</em> can guess the player's secret number, and  the <em>player</em>  tells the <em>computer</em> if its guesses are too high or too low. An efficient algorithm depends on the fact that  numbers have order. Searching an ordered list to find the location of a given object is most efficiently done with essentially the same algorithm. Searching for the location of an object in an <em>unordered</em> list cannot be done the same way. The time that it takes these two algorithms to find their objects hardly matters when the lists are small, but matters a lot when the lists get large. This is students' first experience analyzing computational complexity.</p> 

		<div class="todo"><h3>From Endorsement:</h3>In a reversal of their number guessing game developed in Unit 2, students design an algorithm and program the computer so that the computer can guess the player's secret number, and the player tells the computer if its guesses are too high or too low. They use this as a basis for developing and analyzing list-search algorithms for ordered and unordered lists.</div>
        
        <div class="todo">
            <div class="todo">
                <p>This was originally in the student pages, but Brian and I agree that it should be in the TG only. --MF</p>
                <p>PG: I also like Dan's card sorting activity. I have not explicitly touched either in the purpose statement, but they fit with that purpose: generating an algorithm and thinking about its efficiency.</p>
            </div>
            
        </div>
        
        
        <h3>Pacing:</h3>
		<div>
			The 2 lab pages could be split across 2 to 3 days (90-140 minutes). Expected times to complete follow:
			<ul>
				<li>40-50 minutes (1 class period) on <a href="/bjc-r/cur/programming/5-algorithms/1-searching-lists/1-sorted-lists.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Searching a Sorted List</a></li>
				<li>50-90 minutes (2 class periods) on <a href="/bjc-r/cur/programming/5-algorithms/1-searching-lists/2-improving-search.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Analyzing and Improving Searches</a></li>
			</ul>
		</div>        
        
        
        <h3>Prepare:</h3>
		<div>
			<ul>
				<li>For <strong>page 2</strong>, decide how to split your class into three groups, each with two teams. Prepare materials (15 cups and 25 small cards as described below) for each group. </li>
			</ul>
		</div>


        <h3>Students will:</h3>
		<div class="sidenoteBig">
			<strong>Looking Ahead</strong>
			<ul>
				<li></li>
			</ul>
		</div>
		<div>
			<ul>
				<li>...</li>
			</ul>
		</div> 
			  
		
        <h3>As a Class:</h3>
        <div>
            <ul>
                <li>
                    <strong>Page 1: Searching a Sorted List.</strong>
                    <ul>
                        
                        
                        <li>
                            Discussion: These questions help students ... :
                            <ul>
                                <li></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Page 2: Analyzing and Improving Searches.</strong>
                    <ul>
                        <li><em><strong>Start with this off-computer game:</strong></em> 
                           <p><strong>Materials for each group:</strong> 15 paper cups numbered 1 through 15, 25 small cards (1/4 of a 3&times;5 card is a perfect size) numbered from 1 through 25.</p>
                           <p><strong>Setup:</strong> Two teams play. 
              				 <ul>
                 			    <li> Students in Team 1 arrange the cups in numerical order. Inside each cup, they place exactly one card. Cards must be placed <em>in numerical order</em>, but cards may be skipped. For example, the cups might contain, in order 3, 4, 7, 8, 9, 11, 16, .... Team 2 must not know what numbers have been placed.</li>
                                <li>A student in Team 2 uses <img src="/bjc-r/img/5-algorithms/pick-random(1)to(25).png" alt="pick-random(1)to(25)"> to select a number at random and tells Team 1. </li>
                             </ul></p>
                           <p><strong>Play: </strong>
             				 <ul>
                 				<li>Then  Team 2 asks Team 1 &quot;is it in cup number __?&quot;</li>
                 				<li>Team 1 must answer &quot;yes&quot; if it is. Otherwise, Team 1 says &quot;the number in this cup is bigger than yours&quot; or  &quot;the number in this cup is bigger than yours.&quot; </li>
                 				<li>Team 2 asks a new question &quot;is it in cup number __?&quot; and the two teams continue until either the number is found or Team 2 concludes that the number isn't in any cup.</li>
              				</ul>
            			  </p>
                          <p><strong>Questions to keep in mind during play:</strong>
                            <ul>
                                <li>What strategies can help you find a particular number with the fewest location checks?</li>
                                <li>On average, how many guesses would it take  to find a number?</li>
                                <li>How many guesses would it take to determine that a number didn't exist in the list at all?</li>
                                <li>How much more work would it be to find a number if the number of cups were doubled?</li>
                            </ul>
                          </p>
                        </li>
                        <li>
                            Discussion after game: 
                            <ul>
                                <li>Have students share some of their thinking about the four questions above: strategies, number of guesses to find a number, number of guesses to determine if a number <em>isn't</em> in the list, amount of additional work if the list length were doubled.</li>
                               
                            </ul>
                        </li>
                        <li>Introduce programming activity by saying that the first part of the lab asks you to figure out a strategy for finding a number if the list is <em>not</em> sorted.</li>
                        <li>
                            Discussion: After students work through the lab page, you might ask these questions:
                            <ul>
                                <li>Which takes fewer computer steps? Finding a number in a sorted list or finding a number in an unsorted list?</li>
                            </ul>
                        </li>
                        <li>
                            Discussion: These questions are designed to inspire students to think about... :
                            <ul>
                            	<li></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </div>


        <h3>Assignments:</h3>
		<div>
        	<ul>
        		<li>
                	Students create a U5L1-GuessNumber project, which includes two new blocks:
                    <ul>
                    	<li><code>Number guessing game - player guesser</code> where the computer picks the number and tells the player if their guesses are too high or too low</li>
                    	<li><code>Number guessing game - computer guesser</code> where the player picks the number and tells the computer if its guesses are too high or too low</li>
                    </ul>
                </li>
                <li>Students also develop a U5L1-ListSearch project, a list searching algorithm that finds a specific number in an ordered list of numbers and reports its position.</li>
        	</ul>
        </div>

			
		<!--<h3>Look For:</h3>
		<div><ul><li>...</li></ul></div>

			
		<h3>Related Resources:</h3>
		<div><ul><li>...</li></ul></div>-->

			
        <h3>Tips:</h3>
        <div>
            <ul>
                <li>
                    <strong>Page 1: Searching a Sorted List.</strong>
                    <ul>
                        <li></li>
                    </ul>
                </li>
                <li>
                    <strong>Page 2: Analyzing and Improving Searches.</strong>
                    <ul>
                        <li></li>
                    </ul>
                </li>
            </ul>
        </div>
			

		<!--<h3>Solutions</h3>
		<div><ul><li>...</li></ul></div>-->
			
			
		<h3>Correlation with AP CS Principles Framework<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
            <ul>
				<li><strong>P2 Creating Computational Artifacts</strong> Create an artifact with a practical, personal, or societal intent.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Select appropriate techniques to develop a computational artifact.</li>
				<li><strong>P2 Creating Computational Artifacts</strong> Use appropriate algorithmic and information management principles.</li>
				<li><strong>P3 Abstracting</strong> Explain how abstractions are used in computation or modeling.</li>
				<li><strong>P3 Abstracting</strong> Identify abstractions.</li>
				<li><strong>P3 Abstracting</strong> Describe modeling in a computational context.</li>
                <div class="comment">Have them do P4 and P5 for their own work. --MF</div>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Evaluate a proposed solution to a problem.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Locate and correct errors.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Explain how an artifact functions.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Justify appropriateness and correctness of a solution, model, or artifact.</li>
                <li><strong>P5 Communicating</strong> Describe computation with accurate and precise language, notations, or visualizations.</li>
                <li><strong>P5 Communicating</strong> Summarize the purpose of a computational artifact.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in producing an artifact.</li>
                <li><strong>P6 Collaborating</strong> Share the workload by providing individual contributions to an overall collaborative effort.</li>
                <li><strong>P6 Collaborating</strong> Foster a constructive, collaborative climate by resolving conflicts and facilitating the contributions of a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Exchange knowledge and feedback with a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Review and revise their work as needed to create a high-quality artifact.</li>
			</ul>-->
			<h4>Essential Understandings:</h4>
			<ul>
				<li><strong>EU 5.2</strong> People write programs to execute algorithms.</li>
                <div class="todo">
                	<p>Endorsement file <em><strong>also</strong></em> included: EU 4.2. Please determine applicability here. --MF</p>
                    <ul>
                        <li><strong>EU 4.2</strong> Algorithms can solve many but not all computational problems.</li>
                    </ul>
                </div>
			</ul>
            <h4>Learning Objectives:</h4>
			<ul>
				<li><strong>LO 5.2.1</strong> Explain how programs implement algorithms. [P3]</li>
                <div class="todo">
                	<p>Endorsement file <em><strong>also</strong></em> included: LO 1.2.3 and LO 4.2.4. Please determine applicability here. --MF</p>
                    <ul>
                    	<li><strong>LO 1.2.3</strong> Create a new computational artifact by combining or modifying existing artifacts. [P2]</li>
                        <li><strong>LO 4.2.4</strong> Evaluate algorithms analytically and empirically for efficiency, correctness, and clarity. [P4]</li>
                    </ul>
				</div>
			</ul>
            <h4>Essential Knowledge:</h4>
			<ul>
				<li><strong>EK 5.2.1A</strong> Algorithms are implemented using program instructions that are processed during program execution.</li>
                <li><strong>EK 5.2.1B</strong> Program instructions are executed sequentially.</li>
                <li><strong>EK 5.2.1C</strong> Program instructions may involve variables that are initialized and updated, read, and written.</li>
                <li><strong>EK 5.2.1D</strong> An understanding of instructions processing and program execution is useful for programming.</li>
                <li><strong>EK 5.2.1E</strong> Program execution automates processes.</li>
                <li><strong>EK 5.2.1F</strong> Processes use memory, a central processing unit (CPU), and input and output.</li>
                <li><strong>EK 5.2.1G</strong> A process may execute by itself or with other processes.</li>
                <li><strong>EK 5.2.1H</strong> A process may execute on one or several CPUs.</li>
                <li><strong>EK 5.2.1I</strong> Executable programs increase the scale of problems that can be addressed.</li>
                <li><strong>EK 5.2.1J</strong> Simple algorithms can solve a large set of problems when automated.</li>
                <li><strong>EK 5.2.1K</strong> Improvements in algorithms, hardware, and software increase the kinds of problems and the size of problems solvable by programming.</li>
                <div class="todo">
                	<p>Endorsement file <em><strong>also</strong></em> included: LO 1.2.3 and LO 4.2.4. Please determine applicability here. --MF</p>
                    <ul>
                        <li><strong>EK 1.2.3A</strong> Creating computational artifacts can be done by combining and modifying existing artifacts or by creating new artifacts.</li>
                        <li><strong>EK 1.2.3B</strong> Computation facilitates the creation and modification of computational artifacts with enhanced detail and precision.</li>
                        <li><strong>EK 1.2.3C</strong> Combining or modifying existing artifacts can show personal expression of ideas.</li>
                        <li><strong>EK 4.2.4A</strong> Determining an algorithm’s efficiency is done by reasoning formally or mathematically about the algorithm.</li>
                        <li><strong>EK 4.2.4B</strong> Empirical analysis of an algorithm is done by implementing the algorithm and running it on different inputs.</li>
                        <li><strong>EK 4.2.4C</strong> The correctness of an algorithm is determined by reasoning formally or mathematically about the algorithm, not by testing an implementation of the algorithm.</li>
                        <li><strong>EK 4.2.4D</strong> Different correct algorithms for the same problem can have different efficiencies.</li>
                        <li><strong>EK 4.2.4E</strong> Sometimes, more efficient algorithms are more complex.</li>
                        <li><strong>EK 4.2.4F</strong> Finding an efficient algorithm for a problem can help solve larger instances of the problem.</li>
                        <li><strong>EK 4.2.4G</strong> Efficiency includes both execution time and memory usage.</li>
                        <li><strong>EK 4.2.4H</strong> Linear search can be used when searching for an item in any list; binary search can be used only when the list is sorted.</li>
                    </ul>
                </div>
			</ul>
		</div>			


	</body>
</html>