<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 3 Teacher Guide</title>
	</head>
    
    <body>
        <h2>Lab 3: Timing Experiments</h2>
		<div class="todo">
            <p>
                From Dan: 
                <ul>
                    <li>Given a ton of card decks, have the class figure out the fastest INDIVIDUAL time to start from a shuffled deck to a sorted deck (students can choose what "in order" means for that, but it has to be a unique order, so "reds in front of blacks" isn't enough â€” people always choose to sort by either rank or suit).  Talk about the different algorithms that evolved, and what were fastest.</li>
                    <li>Tell the class they can work as a TEAM to sort a shuffled desk the fastest.  The teams can be any size. Let them continue to adjust the algorithms and sizes of teams and personnel on the teams to achieve the fastest scores.  Talk about the different algorithms that evolved, and what were fastest.</li>
                </ul>
				This is a great introduction to concurrent algorithms, and allows the kids to come up with algorithms on their own, and builds team spirit. It's really fun and useful to plot the fastest times vs the number of players, and talk about amdahl's law. (Added in by MF) Brian suggested the placement in the middle of Lab 3.
            </p>
		</div>
				
        <p>Students compare and contrast algorithms based on their code and running times. Students write a program that times a computation in milliseconds and then time several processes and compare the results. Students also learn the differences between algorithms that run in reasonable time and algorithms that do not. Algorithms that run in reasonable time are further divided into <em>constant</em> time processes (ones in which computing time is not affected by the magnitude of the input), <em>linear</em> time (computing time proportional to the magnitude of the input), and <em>polynomial</em> time (slower than linear, computing time proportional to some polynomial function of the input).</p>  
        
        
        <h3>Pacing:</h3>
		<div>
			The 3 lab pages could be split across 3-6 days (<strong>120-240 minutes</strong>). Expected times to complete follow:
			<ul>
				<li>30-60 minutes (1 class period) on <a href="/bjc-r/cur/programming/5-algorithms/old/3-timing-experiments/1-comparing-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment" title="Comparing Algorithms">Comparing Algorithms</a></li>
				<li>50-100 minutes (2-3 class periods) on <a href="/bjc-r/cur/programming/5-algorithms/old/3-timing-experiments/2-timing-reporters.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment" title="Timing Reporters">Timing Reporters</a></li>
				<li>40-80 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/5-algorithms/old/3-timing-experiments/3-classifying-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment" title="Classifying Algorithms">Classifying Algorithms</a></li>
			</ul>
		</div> 
               

		<h3>Lab Pages</h3>
		<div>
			<div class="sidenote">
                <strong>Looking Ahead</strong>
                <p>Students will further analyze the runtime of algorithms, notably recursive algorithms and sorting algorithms, in Units 7 and 8.</p>
            </div>
            
            <ul>
				<li>
					<strong>Page 1: Comparing Algorithms.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
                                <li>Consider two different <code>sum from 1</code> algorithms: one that uses <code>combine</code> to sum a list; and one that's a mathematical formula.</li>
                                <li>Develop and debug an algorithm for <code>sum from 1</code>.</li>
                                <li>Compare the efficiency of two or more different correct algorithms.</li>
                                <li>Learn that two different correct algorithms for the same problem can have different efficiencies.</li>
							</ul>
						</li>
                        <li>
                            <strong>Discussion:</strong> Why create more than one algorithm to solve the same problem?
                            <ul>
                                <li>Which of Alphie and Betsy's algorithms solves the problem faster?</li>
								<li>Which of Alphie and Betsy's algorithms is easier to understand?</li>
								<li>What trade-offs are there in programming an algorithm for speed or simplicity?</li>
                            </ul>
                        </li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>
                                    Some students may get stuck understanding Betsy's method for adding the numbers, along with the connection to the formula <span class="katex">\frac{n(n+1)}{2}</span>. 
                                    <ul>
                                        <li>Use additional examples besides 13 and 50 to help, such as the numbers from 1 to 7. In the end, only the accuracy of the formula is necessary to continue.</li>
                                        <li>Another helpful explanation, besides the one on this page, is that the average of the numbers from 1 to <em>n</em> is  <span class="katex">\frac{n+1}{2}</span>, and there are <em>n</em> numbers in the list.</li>
                                    </ul>
                                </li>
                                <li>The timing of the two algorithms may seem the same at first. Continue to grow the size of the input until students see a very clear difference between the two, then ask students why there might be a large difference. Related, ask them why there might not have been very much difference for smaller inputs.</li>
                                <li>A likely student question is whether a good algorithm can't just be badly
        programmed.  The answer is yes, but generally, poor-but-correct programming of an algorithm will change the running time only by a constant factor.  My program might always take twice as long as your program, but both of our programs will grow linearly or quadratically or exponentially as the input size grows.  Something you should understand (and your students should come to understand) is that constant factors don't matter very much.  If my program is too slow by a factor of two, I can just wait a year and buy a new computer. But if my algorithm is quadratic instead of linear, that will still be significant no matter how fast computers become.  That's why we talk about analysis of <em>algorithms</em> rather than analysis of <em>programs</em>.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 2: Timing Reporters.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
                                <li>Develop an algorithm timer to help in determining an algorithm's classification as constant, linear, polynomial, or unreasonable time.</li>
                                <li>Explore the efficiency of <a href="/bjc-r/cur/programming/5-algorithms/1-searching-lists/old/2-improving-search.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment" title="Analyzing and Improving Searches">two search algorithms from Lab 1</a>.</li>
							</ul>
						</li>
                        <li>
                            <strong>Discussion:</strong> What are the values and limitations of algorithm timers?
                            <ul>
                            	<li>What could interfere with the accuracy of a timer?</li>
								<li>At what point can you decide that a timing difference is really caused by a different algorithm and not interference?</li>
                            </ul>
                        </li>
						<li>
                            <strong>Discussion:</strong> What happens to algorithms' timing as the size of the input changes?
                            <ul>
                            	<li>What algorithms, if any, were unaffected by the size of the input?</li>
								<li>For those that were affected, how were they affected?</li>
                            </ul>
                        </li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>Timing experiments are unlikely to give the desired results for small input sizes, because the actual algorithm will be swamped by things like the time Snap<em>!</em> spends switching from one thread to another.  Encourage students to use input sizes of at least 100, better yet 1000, if the running time isn't too slow.  They should compare results for <em>n</em> = 100 versus <em>n</em> = 200, or 1000 versus 2000. You're aiming for times of a minute or two, not just a few milliseconds.</li>
                                <li>One point not explicitly taught is that generating a list of <em>n</em> values has to take at least linear time, because adding a value to a list (using <code>add</code>  or <code>in front of</code>) takes time.  How much time?  An exact answer is tricky, but "constant time" is close enough.  (The real truth is "constant time on average." If a particular student insists, send them to the Wikipedia article on "amortized analysis," but note that the first sentence of that article is "This article may be confusing or unclear to readers.")</li>
                                <li>This is unlikely to come up, but if a students use <em>both</em> <code>add</code>  and <code>in front of</code> on the same list, the result will be extremely poor performance, quadratic time or worse. Don't tell students that, but if it comes up, just tell them to be consistent in their programming style. This matters because Snap<em>!</em> uses two different ways to store lists, and switching styles forces Snap<em>!</em> to convert between the two.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 3: Classifying Algorithms.</strong>
					<ul>
						<li><strong>Learning Goal:</strong> Understand the differences between algorithms that complete in reasonable and unreasonable time.</li>
						<li>
                            <strong>Discussion:</strong> What ways are there to analyze an algorithm's efficiency?
                            <ul>
                            	<li>How can you use a timer to gather evidence about an algorithm's efficiency?</li>
								<li>In an algorithm's code, what is evidence that the algorithm has constant time?</li>
								<li>In an algorithm's code, what is evidence that the algorithm has linear time?</li>
								<li>In an algorithm's code, what is evidence that the algorithm may not complete in a reasonable time?</li>
								<li>What information can you learn from a graph of an algorithm's runtime plotted against its input size?</li>
                            </ul>
                        </li>
                        <li>
							<strong>Tips:</strong>
							<ul>
								<li>Algorithms are classified by how fast they execute <em>on large inputs</em>. There are very slow constant-time algorithms, and very fast algorithms for small inputs that become unreasonable for large inputs. The analysis of an algorithm is generally done by counting atomic (constant-time) steps, not just by timing.  Timing is useful in gathering evidence but is not proof that an algorithm is of a certain category.</li>
                                <li>If you have other instances (perhaps of student work) where different algorithms solve the same problem, highlight them here. It's very likely two student algorithms for the same problem will be of the same category, but the analysis is still useful. Alphie and Betsy's algorithms are specifically built to solve the same problem in different categories.</li>
                                <li>Some students may feel Alphie's algorithm is constant time because they count the call to <code>list from</code> as one step, but note that the creation of a list is a linear-time function, so an algorithm that contains it can be (at best) linear time. The algorithm used by the <code>list from</code> block is a simple recursion. If students dig into it, follow along, it will give a good preview to what will happen in Units 6 and 7.</li>
                                <li>The binary search algorithm to find an item in a sorted list takes<em> logarithmic time,</em> which is more than constant time but a lot less than linear time. Students are <strong>not required</strong> to know specifically about logarithmic time, but they should be able to see that the linear search takes linear time, and the binary search takes less than that, but still not constant time. Whether you talk about logarithmic time should depend on how far advanced in algebra your students are. You can consider lists whose sizes are powers of 2 and ask how many times you have to cut the size in half before you get to a single item.</li>
                                <li>(Similarly, a good sorting algorithm takes<em> n log n</em> time, whereas an obvious sorting algorithm takes quadratic (<em>n<sup>2</sup></em>) time. This is a huge difference when sorting a lot of data. Note that we consider <em>log n</em> and <em>n log n</em> run times as "polynomial" even though these are not really polynomial functions. They are <em>bounded by</em> polynomial functions: <em>n</em> is bigger than <em>log n</em> for large <em>n,</em>, and <em>n</em><sup>2</sup> is bigger than <em>n log n.</em>)</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</div>
        
        
		<h3>edX BJC Videos</h3>
        <div class="sidenote">
            <strong>No YouTube access at your school?</strong><br />
            Try these <a href="/bjc-r/cur/teaching-guide/resources/video-list-scratch.html" title="edX BJC Videos (Alternate Links)">Alternate Links</a>.
        </div>
        <div>
        	<ul>
            	<li><a href="https://www.youtube.com/watch?v=gvOCnDVLhuE&index=8&list=PLno6_GYnQv_SOQ7nFjItIdn0Xa9IV4VmH" target="_blank" title="Limits of Computing: Heuristics, NP, NP-Hard, NP-Complete Part 1">Limits of Computing: Heuristics, NP, NP-Hard, NP-Complete Part 1</a> </li>
                <li><a href="https://www.youtube.com/watch?v=cqvPyqh_pOw&index=9&list=PLno6_GYnQv_SOQ7nFjItIdn0Xa9IV4VmH" target="_blank" title="Limits of Computing: Heuristics, NP, NP-Hard, NP-Complete Part 2">Limits of Computing: Heuristics, NP, NP-Hard, NP-Complete Part 2</a> </li>
                <li><a href="https://www.youtube.com/watch?v=NEFuft8NJjM&list=PLno6_GYnQv_TVRZPH6jYTIZLJ-ZTivhA4&index=7" target="_blank" title="Algorithms: Analysis Part 1">Algorithms: Analysis Part 1</a></li>
                <div class="todo">
                	<li><a href="https://www.youtube.com/watch?v=vtobiUX0I4s&list=PLno6_GYnQv_TVRZPH6jYTIZLJ-ZTivhA4&index=8" target="_blank" title="Algorithms: Analysis Part 2">Algorithms: Analysis Part 2</a> </li>
				</div>
		
            </ul>
        </div>
			
		<h3>Solutions</h3>
		<div>
            <ul>
                <li><a href="http://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U5L3p1%20Comparing%20Algorithms%20(answer%20file)&editMode" target="_blank" title="Solution to Page 1: Comparing Algorithms">Page 1: Comparing Algorithms.</a></li>
                <li><a href="http://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U5L3p2%20Timing%20Reporters%20(answer%20file)&editMode" target="_blank" title="Solution to Page 2: Timing Reporters">Page 2: Timing Reporters.</a></li>
                <li><a href="http://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U5L3p3%20Classifying%20Algorithms%20(answer%20file)&editMode" target="_blank" title="Solution to Page 3: Classifying Algorithms">Page 3: Classifying Algorithms.</a></li>
            </ul>
        </div>
			
			
		<h3>Correlation with AP CS Principles Framework:<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
				<li><strong>P1 Connecting Computing</strong> Explain connections between computing concepts.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Use appropriate algorithmic and information management principles.</li>
                <li><strong>P3 Abstracting</strong> Explain how data, information, or knowledge is represented for computational use.</li>
                <li><strong>P3 Abstracting</strong> Identify abstractions.</li>
                <li><strong>P5 Communicating</strong> Describe computation with accurate and precise language, notations, or visualizations.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in solving a computational problem.</li>
                <li><strong>P6 Collaborating</strong> Share the workload by providing individual contributions to an overall collaborative effort.</li>
                <li><strong>P6 Collaborating</strong> Foster a constructive, collaborative climate by resolving conflicts and facilitating the contributions of a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Exchange knowledge and feedback with a partner or team member.</li>
			</ul>-->
			<h4>Enduring Understandings:</h4>
			<div class="todo">
            <p>Brian, below (outside this TODO) is the new paragraph for you to review. I'm keeping last year's here (inside this TODO) for comparison in case you want to salvage any of it. --MF, 2/22/18</p>
            from <a href="/bjc-r/cur/teaching-guide/resources/BJC-Curriculum-Outline.pdf" target="_blank">2016 Outline</a>: Through the development of the timer program, students continue to see that programs are written to execute algorithms (<strong>EU 5.2</strong>) and also build the foundation for understanding that though algorithms can solve many computational problems, there are constraints that must be taken into consideration (<strong>EU 4.2</strong>). This lab builds toward these EUs by having students time various algorithms, building toward the idea that there are identifiable families of algorithms with similar times as a function of input size: constant, linear, quadratic, and exponential. Students are required to build a timer procedure and apply it to several algorithms from earlier units.</div>
			<p>Students build foundation for understanding that although algorithms can solve many computational problems, there are constraints that must be taken into consideration (<strong>EU 4.2</strong>). This lab builds toward these EUs by having students time various algorithms and categorize them based on their run time as a function of input size: constant, linear, quadratic, and exponential.</p>
			<ul>
				<li><strong>EU 4.2</strong> Algorithms can solve many but not all computational problems.</li>
                <div class="todo">I suggest we cut this one --MF, 2/22/18
					<li><strong>EU 5.2</strong> People write programs to execute algorithms.</li>
                </div>
			</ul>
			<h4>Learning Objectives:</h4>
            <div class="todo">New LO para for BH to review. --MF, 2/22/18</div>
			<p>Students evaluate algorithmic efficiency as they determine whether algorithms run in constant time, sublinear time, linear time, quadratic time, or unreasonable time (<strong>LO 4.2.4</strong>), and they explain the difference between the reasonable and unreasonable time (<strong>LO 4.2.1</strong>).</p>
			<ul>
                <li><strong>LO 4.2.1</strong> Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]</li>
                <li><strong>LO 4.2.4</strong> Evaluate algorithms analytically and empirically for efficiency, correctness, and clarity. [P4]</li>
			</ul>
			<h4>Essential Knowledge:</h4>
            <div class="todo">We cut these &mdash; are we sure about 424B and 424G? Where will these each get covered? --MF, 2/22/18<br />
                <li><strong>E K 4.2.4B</strong> Empirical analysis of an algorithm is done by implementing the algorithm and running it on different inputs.</li>
                <li><strong>E K 4.2.4C</strong> The correctness of an algorithm is determined by reasoning formally or mathematically about the algorithm, not by testing an implementation of the algorithm.</li>
                <li><strong>E K 4.2.4G</strong> Efficiency includes both execution time and memory usage.</li>
            </div>
            <ul>
                <li><strong>EK 4.1.1G</strong> Knowledge of standard algorithms can help in constructing new algorithms.</li>
            
                <li><strong>EK 4.1.1H</strong> Different algorithms can be developed to solve the same problem.</li>
                <li><strong>EK 4.1.1I</strong> Developing a new algorithm to solve a problem can yield insight into the problem.</li>
                <li><strong>EK 4.2.1A</strong> Many problems can be solved in a reasonable time.</li>
                <li><strong>EK 4.2.1B</strong> Reasonable time means that the number of steps the algorithm takes is less than or equal to a polynomial function (constant, linear, square, cube, etc.) of the size of the input.</li>
                <li><strong>EK 4.2.1C</strong> Some problems cannot be solved in a reasonable time, even for small input sizes.</li>
                <li><strong>EK 4.2.1D</strong> Some problems can be solved but not in a reasonable time. In these cases, heuristic approaches may be helpful to find solutions in reasonable time.</li>
                <li><strong>EK 4.2.2A</strong> A heuristic is a technique that may allow us to find an approximate solution when typical methods fail to find an exact solution.</li>
                <li><strong>EK 4.2.2B</strong> Heuristics may be helpful for finding an approximate solution more quickly when exact methods are too slow.</li>
                <li><strong>EK 4.2.2C</strong> Some optimization problems such as 'find the best' or 'find the smallest' cannot be solved in a reasonable time, but approximations to the optimal solution can.</li>
                <li><strong>EK 4.2.4A</strong> Determining an algorithm's efficiency is done by reasoning formally or mathematically about the algorithm.</li>
                <li><strong>EK 4.2.4D</strong> Different correct algorithms for the same problem can have different efficiencies.</li>
                <li><strong>EK 4.2.4F</strong> Finding an efficient algorithm for a problem can help solve larger instances of the problem.</li>
                <li><strong>EK 4.2.4H</strong> Linear search can be used when searching for an item in any list; binary search can be used only when the list is sorted.</li>
                <li><strong>EK 5.5.1G</strong> Intuitive and formal reasoning about program components using Boolean concepts helps in developing correct programs.</li>
            </ul>
            
		</div>			


	</body>
</html>
