<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 3 Teacher Guide</title>
	</head>
    
    <body>
        <h2>Programming Lab 3: Timing Experiments</h2>
		<p>Students compare and contrast algorithms based on their code and running times. Students write a program that times a computation in milliseconds. Students then time several processes and compare the results. Students learn the differences between algorithms that run in reasonable time and algorithms that do not. Algorithms that run in reasonable time are further divided into <em>constant</em> time processes (ones in which computing time is not affected by the magnitude of the input), <em>linear</em> time (computing time proportional to the magnitude of the input), and <em>polynomial</em> time (slower than linear, computing time proportional to some polynomial function of the input).</p>  
        
        
        <h3>Pacing:</h3>
		<div>
			The 4 lab pages could be split across 4 or 5 days (<strong>185-255 minutes</strong>). Expected times to complete follow:
			<ul>
				<li>40-50 minutes (1 class period) on <a href="/bjc-r/cur/programming/5-algorithms/4-timing-experiments/1-comparing-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Comparing Algorithms</a></li>
				<li>45-55 minutes (1 class period) on <a href="/bjc-r/cur/programming/5-algorithms/1-searching-lists/3-comparing-search-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">A Distinct List Algorithm</a></li>
				<li>50-75 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/5-algorithms/4-timing-experiments/2-timing-reporters.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Timing Reporters</a></li>
				<li>50-75 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/5-algorithms/4-timing-experiments/3-classifying-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Classifying Algorithms</a></li>

			</ul>
		</div>        

		<h3>Students will:</h3>
		<div class="sidenoteBig">
			<strong>Looking Ahead</strong>
			<ul>
				<li>Students will further analyze the runtime of algorithms, notably recursive algorithms and sorting algorithms, in Units 6 and 7.</li>
			</ul>
		</div>
		<div>
			<ul>
				<li>Understand the differences between algorithms that complete in reasonable and unreasonable time.</li>
				<li>Recognize and distinguish two distinct algorithms that solve the same problem.</li>
				<li>Use a timer to help in determining an algorithm's classification as constant, linear, polynomial, or unreasonable time.</li>
			</ul>
		</div> 
        <div class="todo">
        	<ul>
            	<li>
                    <strong>Read</strong> about two different <code>sum from 1</code> algorithms: one that uses <code>combine</code> to sum a list; and one that's a mathematical formula:<br /> 
                    <img class="indent" src="/bjc-r/img/5-algorithms/sum-of-list-from-1-to.png" alt="" title="" />
                    <img class="indent" src="/bjc-r/img/5-algorithms/sum-from-1-to-blank-expression.png" alt="" title="" />
                </li>
                <li><strong>Develop and debug</strong> an algorithm for <code>sum from 1</code>.</li>
                <li><strong>Compare the efficiency</strong> of two or more different correct algorithms.</li>
                <li><strong>Learn</strong> that two different correct algorithms for the same problem can have different efficiencies.</li>
            </ul>
        </div>
		
			  
		
		<h3>As a Class:</h3>
        <div>
            <ul>
                <li>
                    <strong>Page 1: Comparing Algorithms.</strong>
                    <ul>
                        <li>
                            Discussion: Why create more than one algorithm to solve the same problem?
                            <ul>
                                <li>Which of Alphie and Betsy's algorithms solves the problem faster?</li>
								<li>Which of Alphie and Betsy's algorithms is easier to understand?</li>
								<li>What trade-offs are there in programming an algorithm for speed or simplicity?</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Page 2: A Distinct List Algorithm.</strong>
                    <ul>
                        <li>
                            Discussion: How is pseudocode useful?
                            <ul>
                                <li>What parallels are there between statements in pseudocode and blocks of Snap<em>!</em> code?</li>
								<li>What ways can you outline your work before creating code?</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Page 3: Timing Reporters.</strong>
                    <ul>
                        <li>
                            Discussion: What are the values and limitations of algorithm timers?
                            <ul>
                            	<li>What could interfere with the accuracy of a timer?</li>
								<li>At what point can you decide that a timing difference is really caused by a different algorithm and not interference?</li>
                            </ul>
                        </li>
						<li>
                            Discussion: What happens to algorithms' timing as the size of the input changes?
                            <ul>
                            	<li>What algorithms, if any, were unaffected by the size of the input?</li>
								<li>For those that were affected, how were they affected?</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Page 4: Classifying Algorithms.</strong>
                    <ul>
                        <li>
                            Discussion: What ways are there to analyze an algorithm's efficiency?
                            <ul>
                            	<li>How can you use a timer to gather evidence about an algorithm's efficiency?</li>
								<li>In an algorithm's code, what is evidence that the algorithm has constant time?</li>
								<li>In an algorithm's code, what is evidence that the algorithm has linear time?</li>
								<li>In an algorithm's code, what is evidence that the algorithm may not complete in a reasonable time?</li>
								<li>What information can you learn from a graph of an algorithm's runtime plotted against its input size?</li>
                            </ul>
                        </li>
                    </ul>
                </li>

            </ul>
        </div>
        
			
		<!--<h3>Look For:</h3>
		<div><ul><li>...</li></ul></div>

			
		<h3>Related Resources:</h3>
		<div><ul><li>...</li></ul></div>-->

			
		<h3>Tips:</h3>
        <div>
            <ul>
                <li>
                    <strong>Page 1: Comparing Algorithms.</strong>
                    <ul>
                        <li>Some students may get stuck understanding Betsy's method for adding the numbers, along with the connection to the formula <span class="katex">\frac{n(n+1)}{2}</span>. Use a second example besides 13 to help, such as the numbers from 1 to 7. In the end, only the accuracy of the formula is necessary to continue.</li>
						<li>Another helpful explanation, besides the one on this page, is that the average of the numbers from 1 to <em>n</em> is  <span class="katex">\frac{n+1}{2}</span>, and there are <em>n</em> numbers in the list.</li>
						<li>The timing of the two algorithms may seem the same at first. Continue to grow the size of the input until students see a very clear difference between the two, then ask students why there might be a large difference. Related, ask them why there might not have been very much difference for smaller inputs.</li>
						<li>A likely student question is whether a good algorithm can't just be badly
programmed.  The answer is yes, but generally poor-but-correct programming of an algorithm will change the running time only by a constant factor.  My program might always take twice as long as your program, but both of our programs will grow linearly or quadratically or exponentially as the input size grows.  Something you should understand, and your students should come to
understand, is that constant factors don't matter very much.  If my program is too slow by a factor of two, I can just wait a year and buy a new computer. But if my algorithm is quadratic instead of linear, that'll still be significant no matter how fast computers become.  That's why we talk about analysis of <em>algorithms</em> rather than analysis of <em>programs</em>.</li>
                    </ul>
                </li>
                <li>
                    <strong>Page 2: A Distinct List Algorithm.</strong>
                    <ul>
                        <li>Students may have different impressions of the pseudocode as written. Encourage them to rewrite it in their own words, in a flowchart, or in any way they prefer. The concept here is to give students a clearer picture of ways they can organize their work somewhere in between a written language and their code.</li>
						<li>In particular here, if a student misunderstands some of the pseudocode, get another student to help them with an alternate description, or try to get the student to write something more useful to them. Ideally, don't show them the corresponding code or blocks, which shortcuts the activity.</li>
						<li>There are multiple ways to make the list of duplicates. Expect most students to build an algorithm similar to the one that determines if the unique list exists. If time permits and you see different algorithms used, highlight their differences. You can also use these algorithms on the next page as your examples for timing tests.</li>
                    </ul>
                </li>
                <li>
                    <strong>Page 3: Timing Reporters.</strong>
                    <ul>
                        <li>Timing experiments are unlikely to give the desired results for small input sizes, because the actual algorithm will be swamped by things like the time Snap<em>!</em> spends switching from one thread to another.  Encourage students to use input sizes of at least 100, better yet 1000, if the running time isn't too slow.  They should compare results for <em>n</em>=100 versus <em>n</em>=200, or 1000 versus 2000. You're aiming for times of a minute or two, not just a few milliseconds.</li>
						<li>One point not explicitly taught is that generating a list of <em>n</em> values has to take at least linear time, because adding a value to a list (using <code>add</code>  or <code>in front of</code>) takes time.  How much time?  An exact answer is tricky, but "constant time" is close enough.  (The real truth is "constant time on average." If a particular student insists, send them to the Wikipedia article on "amortized analysis," but note that the first sentence of
that article is "This article may be confusing or unclear to readers.")</li>

<li>One algorithm note: if you use <em>both</em> <code>add</code>  and <code>in front of</code> on the same list, the result will be extremely poor performance, quadratic time or worse. Don't tell students that; just tell them, if it comes up, to be consistent in
their programming style. The reason is that Snap<em>!</em> uses two different ways to store lists, and switching styles forces Snap<em>!</em> to convert between the two. This is unlikely to come up in the programs of this lab.</li>
                    </ul>
                </li>
                <li>
                    <strong>Page 4: Classifying Algorithms.</strong>
                    <ul>
                        <li>Algorithms are classified by how fast they execute <em>on large inputs</em>. There are very slow constant-time algorithms, and very fast algorithms for small inputs that become unreasonable for large inputs. The analysis of an algorithm is generally done by counting atomic (constant-time) steps, not just by timing.  Timing is useful in gathering evidence but is not proof that an algorithm is of a certain category.</li>
						<li>If you have other instances (perhaps of student work) where different algorithms solve the same problem, highlight them here. It's very likely two student algorithms for the same problem will be of the same category, but the analysis is still useful. Alphie and Betsy's algorithms are specifically built to solve the same problem in different categories.</li>
						<li>Some students may feel Alphie's algorithm is constant time because they count the call to <code>list from</code> as one step, but note that the creation of a list is a linear-time function, so an algorithm that contains it can be (at best) linear time. The algorithm used by the <code>list from</code> block is a simple recursion. If students dig into it, follow along, it will give a good preview to what will happen in Units 6 and 7.</li>
						<li>The binary search algorithm to find an item in a sorted list takes<em> logarithmic time,</em> which is more than constant time but a lot less than linear time. Students are <strong>not required</strong> to know specifically about logarithmic time, but they should be able to see that the linear search takes linear time, and the binary search takes less than that, but still not constant time. Whether you talk about logarithmic time should depend on how far advanced in algebra your students are. You can consider lists whose sizes are powers of 2 and ask how many times you have to cut the size in half before you get to a single item.</li>
						<li>(Similarly, a good sorting algorithm takes<em> n log n</em> time, whereas an obvious sorting algorithm takes quadratic (<em>n<sup>2</sup></em>) time. This is a huge difference when sorting a lot of data. Note that we consider <em>log n</em> and <em>n log n</em> times as &quot;polynomial&quot; even though these are not really polynomial functions. They are <em>bounded by</em> polynomial functions: <em>n</em> is bigger than <em>log n</em> for large <em>n,</em> and<em> n<sup>2</sup></em>is bigger than <em>n log n.</em>)</li>
                    </ul>
                </li>

            </ul>
        </div>
        
        
		<h3>edX BJC Videos:</h3>
        <div>
        	<ul>
            
            <li><a href="https://www.youtube.com/watch?v=NEFuft8NJjM&list=PLno6_GYnQv_TVRZPH6jYTIZLJ-ZTivhA4&index=7" target="_blank">Algorithms: Analysis Part 1</a></li>
                
            </ul>
        </div>
			
		<!--<h3>Solutions</h3>
		<div><ul><li>...</li></ul></div>-->
			
			
		<h3>Correlation with AP CS Principles Framework:<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
				<li><strong>P1 Connecting Computing</strong> Explain connections between computing concepts.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Use appropriate algorithmic and information management principles.</li>
                <li><strong>P3 Abstracting</strong> Explain how data, information, or knowledge is represented for computational use.</li>
                <li><strong>P3 Abstracting</strong> Identify abstractions.</li>
                <li><strong>P5 Communicating</strong> Describe computation with accurate and precise language, notations, or visualizations.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in solving a computational problem.</li>
                <li><strong>P6 Collaborating</strong> Share the workload by providing individual contributions to an overall collaborative effort.</li>
                <li><strong>P6 Collaborating</strong> Foster a constructive, collaborative climate by resolving conflicts and facilitating the contributions of a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Exchange knowledge and feedback with a partner or team member.</li>
			</ul>-->
			<h4>Essential Understandings:</h4>
			<ul>
				<li><strong>EU 4.2</strong> Algorithms can solve many but not all computational problems.</li>
                <li><strong>EU 5.2</strong> People write programs to execute algorithms.</li>
			</ul>
			<h4>Learning Objectives:</h4>
			<ul>
				<li><strong>LO 4.2.1</strong> Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]</li>
                <li><strong>LO 4.2.4</strong> Evaluate algorithms analytically and empirically for efficiency, correctness, and clarity. [P4]</li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<ul>
				<li><strong>EK 4.2.1A</strong> Many problems can be solved in a reasonable time.</li>
                <li><strong>EK 4.2.1B</strong> Reasonable time means that as the input size grows, the number of steps the algorithm takes is proportional to the square (or cube, fourth power, fifth power, etc.) of the size of the input.</li>
                <li><strong>EK 4.2.1C</strong> Some problems cannot be solved in a reasonable time, even for small input sizes.</li>
                <li><strong>EK 4.2.1D</strong> Some problems can be solved but not in a reasonable time. In these cases, heuristic approaches may be helpful to find solutions in reasonable time.</li>
                <li><strong>EK 4.2.4A</strong> Determining an algorithm’s efficiency is done by reasoning formally or mathematically about the algorithm.</li>
                <li><strong>EK 4.2.4B</strong> Empirical analysis of an algorithm is done by implementing the algorithm and running it on different inputs.</li>
                <li><strong>EK 4.2.4C</strong> The correctness of an algorithm is determined by reasoning formally or mathematically about the algorithm, not by testing an implementation of the algorithm.</li>
                <li><strong>EK 4.2.4D</strong> Different correct algorithms for the same problem can have different efficiencies.</li>
                <li><strong>EK 4.2.4E</strong> Sometimes, more efficient algorithms are more complex.</li>
                <li><strong>EK 4.2.4F</strong> Finding an efficient algorithm for a problem can help solve larger instances of the problem.</li>
                <li><strong>EK 4.2.4G</strong> Efficiency includes both execution time and memory usage.</li>
                <li><strong>EK 4.2.4H</strong> Linear search can be used when searching for an item in any list; binary search can be used only when the list is sorted.</li>
			</ul>
		</div>			


	</body>
</html>
