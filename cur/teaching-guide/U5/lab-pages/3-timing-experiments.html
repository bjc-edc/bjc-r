<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 5 Lab 3 Teacher Guide</title>
	</head>
    
    <body>
        <h2>Lab 3: Timing Experiments</h2>
		<p>Students compare and contrast algorithms based on their code and running times. Students write a program that times a computation in milliseconds and then time several processes and compare the results. Students also learn the differences between algorithms that run in reasonable time and algorithms that do not. Algorithms that run in reasonable time are further divided into <em>constant</em> time processes (ones in which computing time is not affected by the magnitude of the input), <em>linear</em> time (computing time proportional to the magnitude of the input), and <em>polynomial</em> time (slower than linear, computing time proportional to some polynomial function of the input).</p>  
        
        
        <h3>Pacing:</h3>
		<div>
			The 3 lab pages could be split across 3-6 days (<strong>120-240 minutes</strong>). Expected times to complete follow:
			<ul>
				<li>30-60 minutes (1 class period) on <a href="/bjc-r/cur/programming/5-algorithms/3-timing-experiments/1-comparing-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment">Comparing Algorithms</a></li>
				<li>50-100 minutes (2-3 class periods) on <a href="/bjc-r/cur/programming/5-algorithms/3-timing-experiments/2-timing-reporters.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment">Timing Reporters</a></li>
				<li>40-80 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/5-algorithms/3-timing-experiments/3-classifying-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment">Classifying Algorithms</a></li>
			</ul>
		</div> 
               

		<h3>Lab Pages</h3>
		<div>
			<div class="sidenote">
                <strong>Looking Ahead</strong>
                <p>Students will further analyze the runtime of algorithms, notably recursive algorithms and sorting algorithms, in Units 7 and 8.</p>
            </div>
            
            <ul>
				<li>
					<strong>Page 1: Comparing Algorithms.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
                                <li>Consider two different <code>sum from 1</code> algorithms: one that uses <code>combine</code> to sum a list; and one that's a mathematical formula.</li>
                                <li>Develop and debug an algorithm for <code>sum from 1</code>.</li>
                                <li>Compare the efficiency of two or more different correct algorithms.</li>
                                <li>Learn that two different correct algorithms for the same problem can have different efficiencies.</li>
							</ul>
						</li>
                        <li>
                            <strong>Discussion:</strong> Why create more than one algorithm to solve the same problem?
                            <ul>
                                <li>Which of Alphie and Betsy's algorithms solves the problem faster?</li>
								<li>Which of Alphie and Betsy's algorithms is easier to understand?</li>
								<li>What trade-offs are there in programming an algorithm for speed or simplicity?</li>
                            </ul>
                        </li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>
                                    Some students may get stuck understanding Betsy's method for adding the numbers, along with the connection to the formula <span class="katex">\frac{n(n+1)}{2}</span>. 
                                    <ul>
                                        <li>Use additional examples besides 13 and 50 to help, such as the numbers from 1 to 7. In the end, only the accuracy of the formula is necessary to continue.</li>
                                        <li>Another helpful explanation, besides the one on this page, is that the average of the numbers from 1 to <em>n</em> is  <span class="katex">\frac{n+1}{2}</span>, and there are <em>n</em> numbers in the list.</li>
                                    </ul>
                                </li>
                                <li>The timing of the two algorithms may seem the same at first. Continue to grow the size of the input until students see a very clear difference between the two, then ask students why there might be a large difference. Related, ask them why there might not have been very much difference for smaller inputs.</li>
                                <li>A likely student question is whether a good algorithm can't just be badly
        programmed.  The answer is yes, but generally, poor-but-correct programming of an algorithm will change the running time only by a constant factor.  My program might always take twice as long as your program, but both of our programs will grow linearly or quadratically or exponentially as the input size grows.  Something you should understand (and your students should come to understand) is that constant factors don't matter very much.  If my program is too slow by a factor of two, I can just wait a year and buy a new computer. But if my algorithm is quadratic instead of linear, that will still be significant no matter how fast computers become.  That's why we talk about analysis of <em>algorithms</em> rather than analysis of <em>programs</em>.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 2: Timing Reporters.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
                                <li>Develop an algorithm timer to help in determining an algorithm's classification as constant, linear, polynomial, or unreasonable time.</li>
                                <li>Explore the efficiency of <a href="/bjc-r/cur/programming/5-algorithms/1-searching-lists/2-improving-search.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment">two search algorithms from Lab 1</a>.</li>
							</ul>
						</li>
                        <li>
                            <strong>Discussion:</strong> What are the values and limitations of algorithm timers?
                            <ul>
                            	<li>What could interfere with the accuracy of a timer?</li>
								<li>At what point can you decide that a timing difference is really caused by a different algorithm and not interference?</li>
                            </ul>
                        </li>
						<li>
                            <strong>Discussion:</strong> What happens to algorithms' timing as the size of the input changes?
                            <ul>
                            	<li>What algorithms, if any, were unaffected by the size of the input?</li>
								<li>For those that were affected, how were they affected?</li>
                            </ul>
                        </li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>Timing experiments are unlikely to give the desired results for small input sizes, because the actual algorithm will be swamped by things like the time Snap<em>!</em> spends switching from one thread to another.  Encourage students to use input sizes of at least 100, better yet 1000, if the running time isn't too slow.  They should compare results for <em>n</em> = 100 versus <em>n</em> = 200, or 1000 versus 2000. You're aiming for times of a minute or two, not just a few milliseconds.</li>
                                <li>One point not explicitly taught is that generating a list of <em>n</em> values has to take at least linear time, because adding a value to a list (using <code>add</code>  or <code>in front of</code>) takes time.  How much time?  An exact answer is tricky, but "constant time" is close enough.  (The real truth is "constant time on average." If a particular student insists, send them to the Wikipedia article on "amortized analysis," but note that the first sentence of that article is "This article may be confusing or unclear to readers.")</li>
                                <li>This is unlikely to come up, but if a students use <em>both</em> <code>add</code>  and <code>in front of</code> on the same list, the result will be extremely poor performance, quadratic time or worse. Don't tell students that, but if it comes up, just tell them to be consistent in their programming style. This matters because Snap<em>!</em> uses two different ways to store lists, and switching styles forces Snap<em>!</em> to convert between the two.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 3: Classifying Algorithms.</strong>
					<ul>
						<li><strong>Learning Goal:</strong> Understand the differences between algorithms that complete in reasonable and unreasonable time.</li>
						<li>
                            <strong>Discussion:</strong> What ways are there to analyze an algorithm's efficiency?
                            <ul>
                            	<li>How can you use a timer to gather evidence about an algorithm's efficiency?</li>
								<li>In an algorithm's code, what is evidence that the algorithm has constant time?</li>
								<li>In an algorithm's code, what is evidence that the algorithm has linear time?</li>
								<li>In an algorithm's code, what is evidence that the algorithm may not complete in a reasonable time?</li>
								<li>What information can you learn from a graph of an algorithm's runtime plotted against its input size?</li>
                            </ul>
                        </li>
                        <li>
							<strong>Tips:</strong>
							<ul>
								<li>Algorithms are classified by how fast they execute <em>on large inputs</em>. There are very slow constant-time algorithms, and very fast algorithms for small inputs that become unreasonable for large inputs. The analysis of an algorithm is generally done by counting atomic (constant-time) steps, not just by timing.  Timing is useful in gathering evidence but is not proof that an algorithm is of a certain category.</li>
                                <li>If you have other instances (perhaps of student work) where different algorithms solve the same problem, highlight them here. It's very likely two student algorithms for the same problem will be of the same category, but the analysis is still useful. Alphie and Betsy's algorithms are specifically built to solve the same problem in different categories.</li>
                                <li>Some students may feel Alphie's algorithm is constant time because they count the call to <code>list from</code> as one step, but note that the creation of a list is a linear-time function, so an algorithm that contains it can be (at best) linear time. The algorithm used by the <code>list from</code> block is a simple recursion. If students dig into it, follow along, it will give a good preview to what will happen in Units 6 and 7.</li>
                                <li>The binary search algorithm to find an item in a sorted list takes<em> logarithmic time,</em> which is more than constant time but a lot less than linear time. Students are <strong>not required</strong> to know specifically about logarithmic time, but they should be able to see that the linear search takes linear time, and the binary search takes less than that, but still not constant time. Whether you talk about logarithmic time should depend on how far advanced in algebra your students are. You can consider lists whose sizes are powers of 2 and ask how many times you have to cut the size in half before you get to a single item.</li>
                                <li>(Similarly, a good sorting algorithm takes<em> n log n</em> time, whereas an obvious sorting algorithm takes quadratic (<em>n<sup>2</sup></em>) time. This is a huge difference when sorting a lot of data. Note that we consider <em>log n</em> and <em>n log n</em> run times as "polynomial" even though these are not really polynomial functions. They are <em>bounded by</em> polynomial functions: <em>n</em> is bigger than <em>log n</em> for large <em>n,</em>, and <em>n</em><sup>2</sup> is bigger than <em>n log n.</em>)</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</div>
        
        
		<h3>edX BJC Videos:</h3>
        <div class="sidenote">
            <strong>No YouTube access at your school?</strong><br />
            Try these <a href="/bjc-r/cur/teaching-guide/resources/video-list-scratch.html">Alternate Links</a>.
        </div>
        <div>
        	<ul>
            	<li><a href="https://www.youtube.com/watch?v=gvOCnDVLhuE&index=8&list=PLno6_GYnQv_SOQ7nFjItIdn0Xa9IV4VmH" target="_blank">Limits of Computing: Heuristics, NP, NP-Hard, NP-Complete Part 1</a> </li>
                <li><a href="https://www.youtube.com/watch?v=cqvPyqh_pOw&index=9&list=PLno6_GYnQv_SOQ7nFjItIdn0Xa9IV4VmH" target="_blank">Limits of Computing: Heuristics, NP, NP-Hard, NP-Complete Part 2</a> </li>
                <li><a href="https://www.youtube.com/watch?v=NEFuft8NJjM&list=PLno6_GYnQv_TVRZPH6jYTIZLJ-ZTivhA4&index=7" target="_blank">Algorithms: Analysis Part 1</a></li>
            </ul>
        </div>
			
		<h3>Solutions</h3>
		<div>
            <ul>
                <li><a href="http://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U5L4p1%20Comparing%20Algorithms%20(answer%20file)" target="_blank">Page 1: Comparing Algorithms.</a></li>
                <li><a href="http://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U5L4p2%20Timing%20Reporters%20(answer%20file)" target="_blank">Page 2: Timing Reporters.</a></li>
                <li><a href="http://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U5L4p3%20Classifying%20Algorithms%20(answer%20file)" target="_blank"> Page 3: Classifying Algorithms.</a></li>
            </ul>
        </div>
			
			
		<h3>Correlation with AP CS Principles Framework:<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
				<li><strong>P1 Connecting Computing</strong> Explain connections between computing concepts.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Use appropriate algorithmic and information management principles.</li>
                <li><strong>P3 Abstracting</strong> Explain how data, information, or knowledge is represented for computational use.</li>
                <li><strong>P3 Abstracting</strong> Identify abstractions.</li>
                <li><strong>P5 Communicating</strong> Describe computation with accurate and precise language, notations, or visualizations.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in solving a computational problem.</li>
                <li><strong>P6 Collaborating</strong> Share the workload by providing individual contributions to an overall collaborative effort.</li>
                <li><strong>P6 Collaborating</strong> Foster a constructive, collaborative climate by resolving conflicts and facilitating the contributions of a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Exchange knowledge and feedback with a partner or team member.</li>
			</ul>-->
			<h4>Essential Understandings:</h4>
			<ul>
				<li><strong>EU 4.2</strong> Algorithms can solve many but not all computational problems.</li>
                <li><strong>EU 5.2</strong> People write programs to execute algorithms.</li>
			</ul>
			<h4>Learning Objectives:</h4>
			<ul>
				<li><strong>LO 4.2.1</strong> Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]</li>
                <li><strong>LO 4.2.4</strong> Evaluate algorithms analytically and empirically for efficiency, correctness, and clarity. [P4]</li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<ul>
				<li><strong>EK 4.2.1A</strong> Many problems can be solved in a reasonable time.</li>
                <li><strong>EK 4.2.1B</strong> Reasonable time means that as the input size grows, the number of steps the algorithm takes is proportional to the square (or cube, fourth power, fifth power, etc.) of the size of the input.</li>
                <li><strong>EK 4.2.1C</strong> Some problems cannot be solved in a reasonable time, even for small input sizes.</li>
                <li><strong>EK 4.2.1D</strong> Some problems can be solved but not in a reasonable time. In these cases, heuristic approaches may be helpful to find solutions in reasonable time.</li>
                <li><strong>EK 4.2.4A</strong> Determining an algorithmâ€™s efficiency is done by reasoning formally or mathematically about the algorithm.</li>
                <li><strong>EK 4.2.4B</strong> Empirical analysis of an algorithm is done by implementing the algorithm and running it on different inputs.</li>
                <li><strong>EK 4.2.4C</strong> The correctness of an algorithm is determined by reasoning formally or mathematically about the algorithm, not by testing an implementation of the algorithm.</li>
                <li><strong>EK 4.2.4D</strong> Different correct algorithms for the same problem can have different efficiencies.</li>
                <li><strong>EK 4.2.4E</strong> Sometimes, more efficient algorithms are more complex.</li>
                <li><strong>EK 4.2.4F</strong> Finding an efficient algorithm for a problem can help solve larger instances of the problem.</li>
                <li><strong>EK 4.2.4G</strong> Efficiency includes both execution time and memory usage.</li>
                <li><strong>EK 4.2.4H</strong> Linear search can be used when searching for an item in any list; binary search can be used only when the list is sorted.</li>
                <div class="todo">
                Selim thinks the following should be:<br />
                Removed: 4.2.4B, 4.2.4C, 4.2.4E, 4.2.4G, 4.2.4H<br />
                Added:<br />
                 4.1.1H Different algorithms can be developed to solve the same problem. <br />
            	 4.2.2A A heuristic is a technique that may allow us to find an approximate solution when typical methods fail to find an exact solution.<br />
				 4.2.2B Heuristics may be helpful for finding an approximate solution more quickly when exact methods are too slow. 
<br />
                </div>
			</ul>
            
		</div>			


	</body>
</html>
