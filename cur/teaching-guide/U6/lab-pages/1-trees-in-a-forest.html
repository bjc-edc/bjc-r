<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 6 Teacher Guide</title>
	</head>

	<body>
		<h2>Programming Lab 1: Trees in a Forest</h2>
        <p>Recursion is the use of a procedure within itself. That definition is simple enough, but <em>using recursion</em> takes some practice and learning it well requires care in the order in which ideas are presented.</p>
        <p><img class="imageRight noshadow" src="/bjc-r/img/6-recursion/recursive-tree.gif" alt="fractal tree" title="fractal tree" />Unit 5 introduces recursion in the context fractal graphics, i.e., pictures that include smaller versions of themselves.  The canonical example is the fractal tree, in which each branch is a smaller sub-tree with branches of its own.</p>
		<p>Most of this lab walks the students through a simple fractal tree using the <em>combining method</em> of explaining recursion.  This approach helps students overcome the feeling that a recursive call is "cheating" because it's calling a block that hasn't been fully written yet. To avoid this confusion, we start with a sequence of simpler (non-recursive) tree blocks, each of which calls the one before it (e.g., <code>tree2</code> calls <code>tree1</code>; <code>tree3</code> calls <code>tree2</code>; and so on.) </p>
		<p>
            A more traditional approach to teaching recursion would start with <em>tail recursion,</em> in which the sole recursive call comes at the tail end, like this:<br />
            <img class="indent" src="/bjc-r/img/6-recursion/tail-recursion.png" alt="tail recursive factorial block" title="tail recursive factorial block" />
        </p>
        <p>However, students often misunderstand this code, thinking that the recursive call at the end means "go back to the beginning." This wrong mental model will work for tail recursive blocks, but when students confront a recursive call that can't be at the end of the definition, they'll be lost. The <em>combining method</em>, where students build up successive calls to similar procedures and then just call the procedure itself, provides a better introduction.</p>
        <p>(Note that while most of the labs in other units provide links to projects with the blocks partly or completely pre-written, this lab does not because students benefit from the tactile experience of building almost the same script repeatedly in order to see the virtue of combining them into a single script using recursion.)</p> 

		<h3>Pacing:</h3>
		<div>
			The 4 lab pages could be split across X or X days (X-X minutes). Expected times to complete follow:
			<ul>
				<li>40-70 minutes (1-2 days) on <a href="/bjc-r/cur/programming/6-recursion/1-trees/1-recursive-tree.html?topic=nyc_bjc%2F6-recursion-trees-fractals.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Recursive Tree</a></li>
                <li>about 15 minutes (&lt;1 day) on <a href="/bjc-r/cur/programming/6-recursion/1-trees/2-tree-input-self-check.html?topic=nyc_bjc%2F6-recursion-trees-fractals.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment"><code>Tree</code> Input Self Check</a></li>
                <li>about 15 minutes (&lt;1 day) on <a href="/bjc-r/cur/programming/6-recursion/1-trees/3-tree-variations-self-check.html?topic=nyc_bjc%2F6-recursion-trees-fractals.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment"><code>Tree</code> Variations Self Check</a></li>
                <li>X-X minutes (X-X days) on <a href="/bjc-r/cur/programming/6-recursion/1-trees/4-vary-your-tree.html?topic=nyc_bjc%2F6-recursion-trees-fractals.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Vary Your Tree</a></li>
			</ul>
		</div>


		<!--<h3>Prepare:</h3>
		<div>
			<ul>
				<li></li>
			</ul>
		</div>-->


		<h3>Students will:</h3>
		<!--<div class="sidenoteBig">
			<strong>Looking Ahead</strong>
			<ul>
				<li></li>
			</ul>
		</div>-->
		<div>
			<ul>
				<li>Get a collective introduction to recursion through the "Vee" project, which selects blocks to draw from a list of shape blocks that includes the <code>vee</code> block itself.</li> 
                <li>Revisit the idea of state transparency and its importance when calling scripts within scripts.</li>
                <li>Develop a recursive program by first creating the program with several non-recursive blocks and then using one recursive block to perform the same function.</li>
                <li>Learn the basic ideas and terms of recursion including: base case, recursive case, and infinite loop.</li>
                <li>Explore and develop variations of the fractal tree.</li>
			</ul>
		</div> 
			  
		
		<h3>As a Class:</h3>
		<div>
            <ul>
                <li>
                	<strong>Before starting the lab pages:</strong>
                	<p>This unit begins with a teacher demonstration because the collective "gasp!" when the first complex picture appears is unforgettable. VEE is a great introduction to recursion because its use of randomness lets you ignore completely the annoying detail of base cases in recursive code. Students who've seen the demo, therefore, aren't ready to write their own recursive programs, but they're motivated to work through the first lab.</p>
                    <ul>
                    	<li>Before students get started, project Snap<em>!</em>, choose "Open..." from the File menu, and select "Vee" from the list of example projects.</li>
                        <li>Click the green flag several times and ask students to <strong>describe what the <code>vee</code> procedure does</strong>. You may even choose to show the block definition and discuss how the steps of the procedure generate the images that appear.</li>
                        <li>Then ask students, "<strong>What will happen if we add <code>vee</code> to the list of shapes to make <code>vee</code> call itself?</strong>" You will likely hear answers such as "We'll  sometimes get another v-shape on one of the ends."</li>
                        <li>Then press the up arrow to add two instances of <code>vee</code> to the list, expand the list watcher so students can see the content, and click the green flag a few more times, stopping after the first significantly complex image appears. Ask students, "<strong>What happened when the <code>vee</code> block called itself?</strong>" Don't worry about getting to a precise answer here; the idea is just to instill a sense of the power behind the simple process of calling a procedure from within itself.</li>
                    </ul>
                    <img class="imageRight noshadow" src="/bjc-r/img/6-recursion/list-of-shape-blocks.jpg" alt="list of shape blocks" title="list of shape blocks" />
                    <p>Note that the <em>list of blocks</em> in the corner of the stage (shown right)	 is something the students won't have seen before, but resist the temptation to talk about it. Students will come to understand it by themselves because they've seen lists before and they've seen blocks before.</p>
                </li>
                <li>
                    <strong>Page 1: Recursive Tree.</strong>
                    <ul>
                        <li>
                             Discussion Questions:
                                <ul>
                                    <li>What is <strong>state transparency</strong>? Why is it important? Have you run in to issues with state transparency before? What happened and how did you resolve it? Students may remember <a href="/bjc-r/cur/programming/1-introduction/4-building-and-debugging/5-debugging-blocks-within-blocks.html?topic=nyc_bjc%2F1-intro-loops.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Debugging Blocks within Blocks in Unit 1</a>, where a script intended to draw five blocks in a row by using a <code>draw square</code> block five times fails because the <code>draw square</code> block leaves the sprite in a different orientation than it started.</li>
                                    <img class="imageRight" src="/bjc-r/img/6-recursion/tree.png" alt="correct tree block definition" title="correct tree block definition" />
                                    <li>
                                        These questions encourage students to attend very closely to the details of how the trees are drawn:
                                        <ul>
                                            <li>Why are we multiplying size by 0.65 and 0.85? Why are we multiplying size by -1?</li>
                                            <li>Why are we turning 25&deg; CCW and then 60 &deg; CW and then 35 &deg; CCW?</li>
                                            <li>Why do we subtract 1 from the level in <code>tree</code>?</li>
                                        </ul>
                                    </li>
                                    <li>
                                    To wrap up:
                                    <ul>
                                        <li>You may want to have students describe <strong>recursion</strong> in their own words.</li>
                                        <li>You may also want to have students share their work on the last "For You To Do" problem, identifying the <strong>base case</strong> and <strong>recursive case</strong> in the final <code>tree</code> script and describing how recursion works in this script.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Page 2: <code>Tree</code> Input Self Check</strong> and <strong>Page 3: <code>Tree</code> Variations Self Check.</strong>
                    <ul>
                        <li>Students can work on these pages at their own pace.</li>
                        <li>The first self check asks students to consider the impact of various changes to the value in the <code>tree</code> <var>level</var> input slot.</li>
                        <li>The second asks students to consider what changes to the script would have created several variations on <code>tree</code>.</li>
                    </ul>
                </li>
                <li>
                    <strong>Page 4: Vary Your Tree.</strong>
                    <ul>
                        <li>
                            Discussion: <em>After students work through the lab page</em>, discuss this question as a group: 
                            <ul>
                            	<li>
<div class="forYouToDo" id="first">
            <ol>
                <div class="todo">Put this debugging excercise in the TG...</div>
                <li>
                    Unfortunately, our attempt (shown below) was unsuccessful (see "tree" on the right). Modify the <code>crazy-tree</code> code to produce the random trees as shown above. <a id="hintbutton" onClick="document.getElementById('hintbutton').innerHTML='(Hint: you may want to create new variables!)';">(Click for big hint.)</a><br />
                    <img class="indent" style="border: 0px solid ; width: 330px; height: 306px;" src="../../../../img/6-recursion/random-tree-buggy-code-snap.png" alt="" />
                    <img src="/bjc-r/img/6-recursion/random-tree-not-working.jpg" alt="" title="" />
                </li>
            </ol>
		</div>                                
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                
			</ul>
        </div>


		<!--<h3>Assignments:</h3>
		<div><ul><li>...</li></ul></div>

			
		<!--<h3>Look For:</h3>
		<div><ul><li>...</li></ul></div>-->

			
		<h3>Related Resources:</h3>
		<div>
            <p>These resources spend a lot of time with examples that could be done iteratively. They are provided as additional reading for teachers but not recommended for students.</p>
            <ul>
                <li><a href="http://interactivepython.org/runestone/static/thinkcspy/Recursion/TheThreeLawsofRecursion.html" target="_blank">The Three Laws of Recursion</a> article from "How To Think Like a Computer Scientist"</li>
                <li><a href="http://interactivepython.org/runestone/static/thinkcspy/Recursion/intro-VisualizingRecursion.html" target="_blank">Visualizing Recursion</a> article from "How To Think Like a Computer Scientist"</li>
                <li><a href="https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/recursion" target="_blank">Recursive Algorithms on Khan Academy</a></li>
            </ul>
        </div>

			
		<!--<h3>Tips:</h3>
		<div><ul><li>...</li></ul></div>-->

			
		<!--<h3>Solutions</h3>
		<div><ul><li>...</li></ul></div>-->
			
			
		<h3>Correlation with AP CS Principles Framework<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul>-->
			<h4>Essential Understandings:</h4>
			<ul>
				<li><strong>EU 2.2</strong> Multiple levels of abstraction are used to write programs or create other computational artifacts</li>
                <li><strong>EU 5.3</strong> Programming is facilitated by appropriate abstractions.</li>
			</ul>
			<h4>Learning Objectives:</h4>
			<ul>
				<li><strong>LO 2.2.2</strong> Use multiple levels of abstraction to write programs. [P3]</li>
				<li><strong>LO 4.2.1</strong> Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]</li>
                <li><strong>LO 5.3.1</strong> Use abstraction to manage complexity in programs. [P3]</li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<ul>
				<li><strong>EK 2.2.2B</strong> Being aware of and using multiple levels of abstraction in developing programs helps to more effectively apply available resources and tools to solve problems.</li>
                <li><strong>EK 5.3.1A</strong> Procedures are reusable programming abstractions.</li>
                <li><strong>EK 5.3.1L</strong> Using lists and procedures as abstractions in programming can result in programs that are easier to develop and maintain.</li>
			</ul>
		</div>			


	</body>
</html>
