<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<script src="https://www.w3schools.com/lib/w3.js"></script>
		<title>Unit 6 Lab 1 Teacher Guide</title>
	</head>

	<body>
		<h2>Lab 1: Computer Abstraction Hierarchy</h2>
		<p>People mostly take for granted the enormous behind-the-curtain mechanism that allows their favorite apps to work. Unit 4 gave a first glimpse at that mechanism for apps that rely on the Internet,  with an abstraction hierarchy that includes application protocols, TCP, IP, and link layer (hardware interface) protocols. There are even more levels of abstraction inside your local computer. The purpose of this lab is to tour the levels of abstraction, from high (application programs) to low (transistors).</p>
		<p>Why tour that whole range? Most computer engineers specialize in one level of abstraction, spending their entire careers  at that level. But the engineers who really change the nature of the technology are always aware of the latest developments at  levels above and below their own work, because those other levels exert pressure on the design of any individual level.</p>
		<p>An example. At the start of the 1970s, computer architectures were mostly designed to provide a  large and flexible set of machine language instructions. By the end of the decade, instruction sets were  smaller and simpler. Why? Two reasons. <strong>Pressure from above.</strong> In the early '70s, a lot of programming was done by human programmers writing machine language (using  assembly language notation). By the end of the decade, compiler technology had improved enough for pretty much everyone to trust compilers to produce efficient programs. For a compiler, simple instruction sets make it easier to optimize programs. <strong>Pressure from below.</strong> In the early '70s,  processor circuitry   was much faster than the computer's memory,  so it made sense to get as much computation as possible out of each instruction loaded from memory. By the end of the decade, multilevel cache memory technology made memory references  about as fast as processor cycles, so the way to make programs  efficient was to load instructions  from memory as fast as possible, each instruction doing only as much computational work as can fit before the next instruction arrives.</p>
		<p>The details of this example aren't important for you or your students to learn; the point of the story is to motivate you in familiarizing students with the entire hierarchy from top to bottom.</p>
		<p>Not all abstraction levels are equally important. We single out two: the <em>software abstraction</em> that allows a computer to solve different problems without having to be physically rewired for each one, and the <em>digital abstraction</em> that allows hardware designers to pretend that a transistor is always either fully on or fully off.</p> 
        
        <h3>Pacing</h3>
		<div>
			The 7 required lab pages could be split across 3-7 days (<strong>140-280 minutes</strong>). Expected times to complete follow:
			<ul>
                <li>15-30 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/01-abstraction.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">Abstraction Inside the Computer</a></li>
                <li>15-30 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/02-software-applications.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Software Domain: Applications</a></li>
                <li>30-60 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/03-software-languages.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Software Domain: Programming Languages</a></li>
                <li>30-60 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/04-software-libraries.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Software Domain: Libraries</a></li>
                <li>15-30 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/05-software-OS.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Software Domain: Operating Systems</a> *</li>
                <div class="commentBig">I'm still worried about the amount of reading on the Architecture page (even just the non-yellow reading; the yellow reading is downright excessive). What if everything in the "The Stored Program Computer" section was yellow? --MF, 12/6/17</div>
                <li>15-30 minutes (&lt;1 class periods) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/06-digital-architecture.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Digital Domain: Architecture</a></li>
                <li>10-20 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/07-digital-components.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Digital Domain: Components</a></li>
                <li>25-50 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/08-digital-IC.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Digital Domain: Integrated Circuits</a> *</li>
                <li>25-50 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/09-digital-logic-gates.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Digital Domain: Logic Gates</a></li>
                <li>10-20 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/10-analog.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Analog Domain: Transistors</a> *</li>	    
            </ul>
		</div>

        <div w3-include-html="/bjc-r/utilities/includes/asterisk.txt"></div><script>w3.includeHTML();</script>

		<h3>Prepare</h3>
		<div>
			<ul>
                <li>To leave  you free to choose, the ideal introduction to this unit  is not mentioned in the student materials, but it's exciting and instructive  for students in groups to take apart an actual  (<em>old</em>) computer.  (Preferably, one  per four students or so, but even just one computer with the whole class watching is still  great.) You don't need a <em>working</em> computer, but working is better; the thrill when they put it back together and it still works is fantastically motivating. In most places, it's no longer legal to dump old computers in the garbage, so nonworking computers can often be obtained free from   recycling centers. Working  antiques (i.e., over ten years old) can be bought very cheaply at used computer stores or    recycling centers. If your school is buying new computers,  you may be able to grab  old ones before they leave the building.</li>
                <li><a href="http://www.ifixit.com" target="_blank">ifixit.com</a> is one good source of teardown guides, such as this example: <a href="https://www.ifixit.com/Teardown/Compaq+Deskpro+EN+Teardown/55804" target="_blank">https://www.ifixit.com/Teardown/Compaq+Deskpro+EN+Teardown/55804</a>. You can perhaps find one specifically for the particular model of old computer you salvaged. It doesn't have to be on their site; just do a web search for your computer model and the word "teardown."</li>
                <li>Safety guide.</li>
                <ul>
                <li><em><strong>Do not tear down a laptop</strong></em> the first time you try this activity. Laptops are very dense, and parts are often held together with glue. People do tear down laptops and even get them working again, but get some experience with desktop/tower computers first. Also, laptop batteries have been known to catch fire.</li>
                <li><em><strong>Do not tear down a cell phone in class ever.</strong></em> Besides sharing all the problems of laptops, they have highly explosive and flammable batteries. </li>
                <li><em><strong>Grounding. </strong></em>If you want the computer to work afterward, whoever works on the electronics should be grounded before opening the case. This is to protect the <em>electronics</em>; the <em>person</em> is safe with or without grounding. Pros use a metal strap wrapped around their wrist with a wire clamped to a water pipe. Or, touching the metal frame of any grounded object—one that has a three-prong power cord (and is plugged in)—will do. Look up "grounding  while working on a computer" to learn more.</li> 
                </ul>
			</ul>
	</div>


		<h3>Lab Pages</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Abstraction Inside the Computer.</strong>
					<ul>
						<img class="imageRight noshadow" src="/bjc-r/img/6-computers/hardware-abstraction.png" alt="diagram of computer abstraction hierarchy showing three levels of decreasing abstraction: software domain (including applications, programming languages, libraries, and operating systems), digital domain (including architecture, components, integrated circuits, and logic gates), and analog domain (including transistors); there is a dividing line between the software and digital domains labeled 'program abstraction barrier' and a dividing line between the digital and analog domains labeled 'digital abstraction barrier;' there is a vertical double-headed arrow on the right indicating that the items listed first on the list (and their sub-lists) have a 'high level of abstraction' and those lower on the list have a 'low level of abstraction'" title="diagram of computer abstraction hierarchy showing three levels of decreasing abstraction: software domain (including applications, programming languages, libraries, and operating systems), digital domain (including architecture, components, integrated circuits, and logic gates), and analog domain (including transistors); there is a dividing line between the software and digital domains labeled 'program abstraction barrier' and a dividing line between the digital and analog domains labeled 'digital abstraction barrier;' there is a vertical double-headed arrow on the right indicating that the items listed first on the list (and their sub-lists) have a 'high level of abstraction' and those lower on the list have a 'low level of abstraction'" height="250"/>
						
                        <li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Understand that the computer abstraction hierarchy includes three major "domains": software, digital, and analog.</li>
                                <li>Understand that these domains are separated by the abstraction of a "program" and the abstraction of data being represented "digitally," as ones and zeros.</li>
								<li>Understand that the software and digital domains each include a sub-hierarchy of abstraction.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>
                                    Don't worry about students memorizing the specific levels of abstraction. The main points are:
                                    <ul>
                                        <li>Software lets you control a computer, abstracting away the actual machine (the program abstraction); and "zeros and ones" are an abstraction over the way transistors really work (the digital abstraction).</li>
                                        <li>The levels of abstraction in the <em>software</em> domain are <em>different programs:</em> the application programs are written in a programming language, and use libraries, and interface with the operating system to control the hardware.</li>
                                        <li>By contrast, the levels of abstraction in the <em>digital</em> domain are <em>different ways of thinking</em> about the <em>same</em> physical object.</li>
                                    </ul>
                                    <div class="todo">
                                        <p>I'm not sure what to do with this, and it doesn't fit for me here. <strong>Brian</strong>, is this needed? What purpose does it serve? --MF, 12/6/17</p>
                                        Envision yourself holding a processor chip in your hand, and asking yourself
                                        <ul>
                                            <li>What's it for?</li>
                                            <li>What are the major structures inside it?</li>
                                            <li>What's physically	inside	the	plastic	case?</li>
                                            <li>What are the primitive building blocks of a digital circuit?</li>
                                        </ul>
                                    </div>
                                </li>
                                <div class="todo">The following abstraction commentary (about nuanced meanings below) should really appear earlier in the year. We should change the next year, and what remains here should just be a nod to that ongoing discussion. --MF, 11/21/17 (with Brian)</div>
                                <li>Abstraction has many nuanced meanings in computer science. At the end of each page that deals with abstraction, ask students, "What does abstraction mean on this page?" and consider keeping a running log.</li>							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 2: The Software Domain: Applications.</strong>
					<ul>
						<li>
                        <div class="todo">
                        Selim's suggestion<br />
                        <strong>Learning Goals:</strong>
                        <ul>
                        	<li>Realize that apps are not the complete story about software but rather the tip of the iceberg, supported by a huge collection of other software.</li>
                            <li>Review what students already know about software but with an emphasis on creation rather than on consuming.</li>
                        </ul>
                        </div>
                        	
							<strong>Learning Goals:</strong>
							<ul>
								<li>This page is  light on technical content, mostly reviewing what students  know from experience but emphasizing <em>creating</em>  rather than just consuming.</li>
								<li>The major point: People may see apps as the complete story about software, but  apps are the tip of the iceberg, supported by a huge collection of other software.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>Here and there in the litany of software uses are bad ones: fake news, finding out your political views, malware. Don't over-emphasize these, but also don't leave the page until at least one comes up in discussion.</li>
								<li>Consider reading and discussing the chapter "Propaganda Machine" (pages 68–83) in <em>Weapons of Math Destruction: How big data increases inequality and threatens democracy</em> by mathematician Cathy O'Neil. It gives examples of destructive sides of "targeted advertising," and mentions a school in Brooklyn that helped expose one such destructive example.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 3: The Software Domain: Programming Languages.</strong>
					<ul>
						<li>
                        <div class="todo">
                        Selim's suggestion<br />
                        <strong>Learning Goals:</strong>
                        <ul>
                        	<li>Understand that some languages are at a higher level of abstraction than others.</li>
                            <li>Realize that in almost all situations, higher level of abstraction is better, both for safety against bugs and for ease of programming.</li>
                            <li>Learn that all general-purpose languages are <em>equivalent</em> in the sense that an algorithm expressible in one language is expressible in any.</li>
                        </ul>
                        </div>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Some languages are at a higher level of abstraction than others.</li>
								<li>In almost all situations, higher is better, both for safety against bugs and for ease of programming.</li>
								<li>On the other hand, all general-purpose languages are <em>equivalent</em> in the sense that an algorithm expressible in one language is expressible in any.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>Keep this entire lab light. Throughout the lab, there's a <em>lot</em> that can be expanded—this page in particular  fills an entire semester course for college computer science students—but your students need just the overview. Some students will want more, so <strong>we use hint boxes differently here</strong> from how we use them elsewhere. Usually these boxes hide support for students who are struggling. Here, they hide  detail that's not needed for the AP exam, but may appeal to student curiosity.</li>
								<li>There are many ways to make taxonomies of programming languages; we take abstraction as our guiding idea. The things that make one language more abstract than another are generally subtle. We tried to pick examples that are relatively easy to explain, even if students may be unfamiliar with them.
								  <ul>
								    <li>Automatic memory management (garbage collection) is perhaps the most important example. When it was introduced in Lisp in 1952, mainstream programmers ridiculed it as being too slow. But since it was used in Java in 1995, every new programming language has included it. Today it would be engineering malpractice to use a language that allows programmers any control over memory allocation. It's easy to make that case, because of a long history of memory management disasters in old software. </li>
		<!--						    <li>Some other examples are harder to explain. One such example in the lab is that high level languages associate data types with values, whereas low level languages associate data types with variables. (That is, if your language makes you say <code>int i</code> or <code>float x</code>, it's a low-level language.) It's  harder to explain why the high-level kind is better. One reason is that in a language with dynamic typing (the high level kind) it's just as easy to make a list whose items are of different data types as to make one whose items are all integers, or all character strings. </li>
        -->
								    <li>A high level language allows users to invent new syntactic forms, such as the <code>for</code> block in the Snap<em>!</em> tools library. Java, for example, has a <code>for</code> notation, but if it didn't, a Java programmer couldn't create one. </li>
								    <li>A final example, discussed at length in Lab 2, is that a high-level language doesn't limit the size or precision of numbers based on the width of the machine architecture; you should be able to compute 200 factorial and get an exact integer answer.</li>
							      </ul>
								</li>
								<!-- <li>The page makes the argument that some languages students have never heard of, such as Scheme, are all-around better than the languages they <em>have</em> heard of, such as Python or Java. It's not important that students, or you, agree with this, but in evaluating the idea, bear in mind that the most widely used operating system on computers is Microsoft Windows. Popularity doesn't imply high quality.</li> 
								<li>Another side point to note is that <em>our</em> language, Snap<em>!</em>, is higher level than many of the "grownup" languages even though it looks like a kid language. It would be great if students come to understand this, although it's not really a goal of the course.</li>-->
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 4: The Software Domain: Libraries.</strong>
					<ul>
						<li>
                        <div class="todo">
                        Selim's suggestion<br />
                        <strong>Learning Goals:</strong>
                        <ul>
                        	<li>Appreciate that anyone who writes an application program is standing on the shoulders of excellent programmers who build libraries that do many of the hard parts.</li>
                            <li>Understand that by hiding vast amounts of complexity from the programmers while providing them with versatile utility, software libaries are excellent examples of abstraction.</li>
                        </ul>
                        </div>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Anyone who writes an application program is standing on the shoulders of excellent programmers who build libraries that do many of the hard parts.
								  <ul>
								    <li>Most of the time, it's the application programmers who get rich and famous, while the library programmers are often university students who do this work for love.
								  <br>
								</li>
								  </ul>
								</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>When people who aren't programming language specialists compare languages, it's almost always really the libraries that they are comparing, e.g., "JavaScript is good because you can make web pages in it."  That's because the JavaScript in web browsers has a web-page library, not because of the language itself.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 5: The Software Domain: Operating Systems.</strong>
					<ul>
						<li>
                        <div class="todo">
                        Selim's suggestion<br />
                        <strong>Learning Goals:</strong>
                        <ul>
                        	<li>Understand that an operating system (Linux, macOS, Windows, etc.) is actually a package of hundreds of programs including applications (Finder, TextEdit, etc.) and libraries, along with one special program: the kernel.</li>
                            <li>Learn that the kernel is generally written in a low level language in order to control hardware and catch a glimpse of the tasks delegated to the kernel.</li>
                        </ul>
                        </div>
							<strong>Learning Goals:</strong>
							<ul>
								<li>An operating system (Linux, macOS, Windows, etc.) is actually a package of hundreds of programs including applications (Finder, TextEdit, etc.) and libraries, along with one special program: the kernel.</li>
								<li>The kernel is almost always written in a low-level language, because it has to have access to specific memory addresses (not general-purpose memory at all, but rather I/O device control registers) and other hardware features such as the clock.</li>
                                </ul>
                                <li><strong>Tips:</strong>
                                <ul>
								<li>The AP Framework doesn't explicitly mention the operating system or its kernel, but some  EKs are indirectly about the kernel, such as "5.2.1G A process may execute by itself or with other processes." If  one processor is running multiple processes  at once,  there has to be a <em>scheduler</em> that switches the hardware's attention among  the processes. That's part of the kernel. Similarly, the kernel is in charge of security in the file system.</li>
							</ul>
						</li>
						<!-- <li>
							<strong>Tips:</strong>
							<ul>
								<li>It would be nice if we could include a programming task here, but we can't; your school's IT person would never permit students to have kernel-level access to the computers.</li>
							</ul>
						</li> -->
					</ul>
				</li>
                <li>
					<strong>Page 6: The Digital Domain: Architecture.</strong>
					<ul>
						<li>
                        <div class="todo">
                        Selim's suggestion<br />
                        <strong>Learning Goals:</strong>
                        <ul>
                        	<li>Learn about the fascinating history of Babbage's Difference and Analytical Engines and understand that long before we had electronic circuit devices, the crucial invention of the <em>stored-program</em> architecture was made by Charles Babbage with Ada Lovelace.</li>
                            <li>Celebrate Ada Lovelace as woman of science and as a pioneer in the field of computing.</li>
                            <li> Understand that the job of a computer architecture is to enable the software abstraction by specifying how to interpret a binary sequence as representing an algorithm.  Many different hardware devices might implement the same architecture, e.g., at different speeds and costs. The architecture is an <em>interface specification, </em>a document you can read, rather than an actual piece of hardware.</li>
                        </ul>
                        </div>
							<strong>Learning Goals:</strong>
							<ul>
								<li>To a first approximation, an architecture is a machine language. The job of the architecture is to enable the software abstraction by specifying how to interpret a binary sequence as representing an algorithm, just as Unicode specifies how to interpret a binary sequence as a character string.</li>
								<li>Many different hardware devices might implement the same architecture, e.g., at different speeds and costs. The architecture is an <em>interface specification, </em>a document you can read, rather than an actual piece of hardware.</li>
								<li>Long before we had electronic circuit devices, the crucial invention of the <em>stored-program</em> architecture was made by Charles Babbage with Ada Lovelace.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>There are several yellow "hint boxes" at the end of the page. The first  makes the point that pretty much all computers these days (except for phones and tablets) use the <em>same</em> Intel x86 architecture. That wasn't always true. PCs have always been Intel-based, but the Mac started out using the Motorola 68000 architecture, then the Apple-specific PowerPC architecture, before switching to x86. If you're interested, these are further questions you can suggest as research topics:
								  <ul>
								    <li>Why did desktop/laptop computers end up with every brand using a single architecture?</li>
								    <li>And why <em>don't </em> phones and tablets use the x86 architecture?</li>
							      </ul>
							  </li>
								<li>Later hint boxes provide similar explorations of phones, hobbyist computers, and Internet-of-things architectures. None of this material is required for the AP, but looking at one or two specific examples can make the <em>idea</em> of an architecture  more concrete.</li>
								<li>The last hint box is about  architecture in general. Second sourcing is just an interesting side point about why all computers use x86, but the note about memory hierarchy is important to a full understanding of the AP's topics about memory. Specifically, the AP wants students to know that the components of a computer include the processor and the memory, but these days, the most important parts of the memory—the level-1 and level-2 caches—are <em>part of the same chip</em> as the processor. One reason for this is that today's processors are fast enough so that the speed of electrons through wire matters; the fastest memory has to be mere nanometers away from the processor.</li>
							</ul>
						</li>
					</ul>
		  </li>
                <li>
					<strong>Page 7: The Digital Domain: Components.</strong>
					<ul>
						<li>
                        <div class="todo">
                        Selim's suggestion<br />
                        <strong>Learning Goals:</strong>
                        <ul>
                        	<li>Learn about different component of a computer, especially about the <em>processor,</em> which carries out the steps of a program, and the <em>memory, </em>which holds both the program and its data. </li>
                            <li>Be able to identify if a device is an input or an output device, or both.</li>
                        </ul>
                        </div>
							<strong>Learning Goals:</strong>
							<div class="comment">These learning goals are getting too complex and tip-like. Need some revision. --MF, 11/29/17</div>
                            <ul>
								<li>The most important components to understand are the <em>processor,</em> which carries out the steps of a program, and the <em>memory, </em>which holds both the program and its data. (But in a modern computer, part of the memory&mdash;the level-1 and level-2 caches&mdash;are in the same chip as the processor. The processor registers are also a very small memory.)</li>
								<li>The relevant AP CSP EK talks about the traditional idea of three components: processor, memory, and input/output. Students, on the other hand, are likely to list the things they can see and feel: the keyboard, the screen, the printer, the backup disk, and so on. In traditional terms, all those are lumped together under I/O devices. And it's the interface hardware <em>inside the box</em> that really counts as the I/O component.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>Not too long ago, there were specific connectors on the back of the computer (or on the side, if it's a laptop) for each kind of external device. Today, though, all of the external devices are likely to connect to the computer through one uniform interface: USB (Universal Serial Bus). So there's a single piece of hardware inside the machine that knows how to talk to <em>any</em> USB device, and then the differences among the external devices are all handled in software. If you have students who are eager for extra work, you could have them research how USB works.</li>
								<li>The bulk of this page is about the student view of components, including the things outside the box. This is because students know about these things and they or you can point to the actual things. Problem 3 is an attempt to bring the focus into the AP idea of components, because what makes one computer model different from another are the processor width and speed, and the memory size and speed. (A third factor is the amount of disk or flash "solid state disk" memory. The disk is inside the box, but outside the chip set on the motherboard.)</li>
								<li>This lab page includes a Snap<em>!</em> programming project. The project just reinforces the component list right above it on the page. Really, the main reason to have a programming exercise here is to break up the reading-heavy nature of this lab. If you're short on time, it can be skipped or made optional for students.</li>
								<li>There's a<em> lot</em> to say about computer hardware that is way beyond the scope of this course. Students may raise questions to which you don't know the answer. Just tell them you don't know, they don't have to know for the AP test, and if they're interested they could look it up online and tell the class the answer next class meeting.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 8: The Digital Domain: Integrated Circuits.</strong>
					<ul>
						<li>
                        <div class="todo">
                        Selim's suggestion<br />
                        <strong>Learning Goals:</strong>
                        <ul>
                        	<li>Realize that ICs are all about <em>miniaturization</em> and it was their invention that got us from the big-as-a-room computers to modern desktop and smaller computers.</li>
                            <li>Consider the social implications of computing in light of the history of <em>conlict materials</em>.</li>
                        </ul>
                        </div>
							<strong>Learning Goals:</strong>
							<ul>
								<li>ICs are all about <em>miniaturization.</em> It was the invention of the IC that got us from the big-as-a-room computers to modern desktop and smaller computers.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>If an IC has billions of transistors in it, the designer of the IC can't position each one individually.  Designers use abstraction; they design in a special purpose programming language that lets them create small circuit elements, such as a one-bit-wide	adder, then combine several of those to make a 32-bit-wide adder, and so on.</li>
								<li>Take a moment to try to give students a sense of the magnitudes involved.  If 10 billion transistors fit on a one-inch  square, the length in meters of one transistor is about 254nm. The length of a simple (inorganic) molecule is around 10nm, so we aren't yet pushing the size limit for chip density—it's heat that limits us right now. But transistors will never be as small as one molecule; to get to that size we'll need a different underlying technology.</li>
								<li>An IC, or chip, is not necessarily a processor. In desktop and laptop computers, besides the processor, there are two dozen or so special-purpose chips: memory, graphics co-processors, USB interfaces, wireless modems, etc.</li>
								<li>The subject of conflict minerals used in everyday technology can be an upsetting one as it involves terrible human rights violations. As part of understanding the social implications of computing, students are asked to research this topic. Before presenting this page to students, research the topic yourself so that you are prepared for students' reactions to this harsh reality. At a minimum, read the two articles quoted on the student page, which present both the issues and some efforts to address them:
								  <ul>
								    <li><a href="https://iq.intel.com/tech-ethics-does-conflict-free-matter" target="_blank">Tech Ethics: Does Conflict Free Matter?</a></li>
								    <li><a href="https://www.intel.com/content/www/us/en/corporate-responsibility/conflict-free-minerals.html" target="_blank">Intel’s Efforts Are Helping Families in the Congo</a></li>
							      </ul>
                                  Bear in mind, though, that these pages were written by Intel's PR department, so there's likely more to the story.
							  </li>
							</ul>
						</li>
					</ul>
                </li>
			</ul>
			<ul>
			  <li>
			    <strong>Page 9: The Digital Domain: Logic Gates.</strong>
			    <ul>
			      <li>
                  <div class="todo">
                        Selim's suggestion<br />
                        <strong>Learning Goals:</strong>
                        <ul>
                        	<li>Understand that computer circuitry is built out of small circuits (&quot;gates&quot;) that compute Boolean functions and that <em>any</em> computable function can be expressed by combining logic gates.</li>
                            
                        </ul>
                        </div>
			        <strong>Learning Goals:</strong>
			        <ul>
			          <li>Computer circuitry is built out of small circuits (&quot;gates&quot;) that compute Boolean functions.</li>
			          <li><em>Any</em> computable function can be expressed by combining logic gates.</li>
			          </ul>
			        </li>
			      <li>
			        <strong>Tips:</strong>
			        <ul>
			          <li>Some students may argue that ICs are less abstract than logic functions. They're right if you think of &quot;IC&quot; and &quot;function&quot; as abstract (in the ordinary sense) concepts. We put them in this order because an IC is designed with logic gates as its building blocks. This is one reason why we tell students not to obsess over the specific abstraction levels within the digital domain.</li>
			          <li>Although we hid them in yellow hint boxes to save time if you're rushed, it's a good thing if students see at least one truth table, so they get the idea that the table <em>completely defines</em> a Boolean function, unlike the addition and multiplication tables they were made to memorize in elementary school, which define the function only for single-digit inputs. A Boolean function has only two possible values for each input, whereas an arithmetic function has infinitely many possible values for each input.</li>
			          <li>Since a truth table completely defines a Boolean function, and you can construct every possible truth table for a two-input Boolean function (this is a good Take It Further exercise), it follows that there are only finitely many Boolean functions—in fact, only 16 of them. This makes for a nice mini-research project: How many of the 16 are useful? How many have names? Are they all commutative? Are they all associative? And so on.</li>
			          <li>Although we've made it optional this year, if at all possible, students should see an adder circuit built out of logic gates, just to show how we make good on the promise that functions with multi-bit outputs can be made out of single-bit-output Boolean functions.</li>
			          </ul>
			        </li>
			      </ul>
			    </li>
			  <li>
			    <strong>Page 10: The Analog Domain: Transistors.</strong>
			    <ul>
			      <li>
                  <div class="todo">
                        Selim's suggestion<br />
                        <strong>Learning Goals:</strong>
                        <ul>
                        	<li>Understand the distinction between digital and analog.</li>
                            <li>Realize that the digital abstraction is made possible by the bistable nature of the transistor (the two flat regions in its input-output curve) and that it still takes engineering effort to be sure that each transistor stays in one of the flat regions.</li>
                        </ul>
                        </div>
			        <strong>Learning Goals:</strong>
			        <ul>
			          <li>It's not a law of nature that wires have to be just &quot;on&quot; or &quot;off.&quot; There have even been <em>analog computers</em> that make use of circuits with a continuous range of possible output values on a wire.</li>
			          <li>The bistable nature of the transistor (the two flat regions in its input-output curve) is what makes the digital abstraction possible. But it still takes engineering effort to be sure each transistor stays in one of the flat regions.</li>
			          </ul>
			        </li>
			      <li>
			        <strong>Tips:</strong>
			        <ul>
			          <li>Students who have studied electronics may complain that the usual way transistor curves are drawn shows output <em>current</em> vs. input voltage. They're right, that's the usual picture, although the shape is the same as what we've shown. We're trying to make this lesson as simple as possible.</li>
			          <li>There's really no student activity on this page; it wouldn't hurt if you treat this as a lecture topic.</li>
			          </ul>
			        </li>
			      </ul>
			    </li>
		  </ul>
		</div>


		<!--<h3>Assignments</h3>
		<div>
			<ul>
				<li>...</li>
			</ul>
		</div>-->

			
		<h3>Solutions</h3>
		<div>
        <ul>
			<li><a href="/bjc-r/cur/teaching-guide/U6/lab-pages/1b-computer-abstraction-hierarchy-solutions.html"> U6 Lab 1 Solutions.</a></li>
            </ul>
		</div>
			
			
		<h3>Correlation with AP CS Principles Framework<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul-->
			<h4>Essential Understandings:</h4>
			<div class="todo">Need to go over each of these EUs (they are just the ones that match the listed EKs) and decide which fit. Then, need to write a single paragraph describing specifically how we cover all of them. --MF, 11/6/17</div>
			<p></p>
			<ul>
				<li><strong>EU 1.3</strong> Computing can extend traditional forms of human expression and experience.</li>
				<li><strong>EU 2.1</strong> A variety of abstractions built upon binary sequences can be used to represent all digital data. </li>
				<li><strong>EU 2.2</strong> Multiple levels of abstraction are used to write programs or create other computational artifacts.</li>
				<li><strong>EU 5.2</strong> People write programs to execute algorithms.</li>
				<li><strong>EU 5.5</strong> Programming uses mathematical and logical concepts.</li>
				<li><strong>EU 7.2</strong> Computing enables innovation in nearly every field.<br>
				</li>
			</ul>
			<h4>Learning Objectives:</h4>
			<div class="todo">Need to go over each of these LOs (they are just the ones that match the listed EKs) and decide which fit. Then, need to write a single paragraph describing specifically how we cover all of them. --MF, 11/6/17</div>
			<p></p>
			<ul>
                <li><strong>LO 1.3.1 </strong>Use computing tools and techniques for creative expression. [P2]</li>
                <li><strong>LO 2.1.2</strong> Explain how binary sequences are used to represent digital data. [P5]</li>
                <li><strong>LO 2.2.3</strong> Identify multiple levels of abstractions that are used when writing programs. [P3] </li>
                <li><strong>LO 5.2.1</strong> Explain how programs implement algorithms. [P3] <br>
                </li>
                <li><strong> LO 5.5.1</strong> Employ appropriate mathematical and logical concepts in programming. [P1]</li>
                <li><strong>LO 7.2.1</strong> Explain how computing has impacted innovations in other fields. [P1]<br>
                </li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<div class="todo">Pulled from the student pages. --MF, 11/6/17</div>
			<ul>
				<li><strong>EK 1.3.1B</strong> Digital audio and music can be created by synthesizing sounds, sampling existing audio and music, and recording and manipulating sounds, including layering and looping.</li>
				<li><strong>EK 1.3.1C</strong> Digital images can be created by generating pixel patterns, manipulating existing digital images, or combining images. </li>
				<li><strong>EK 1.3.1D</strong> Digital effects and animations can be created by using existing software or modified software that includes functionality to implement the effects and animations. </li>
				<li><strong>EK 2.1.2B</strong> In many programming languages, the fixed number of bits used to represent characters or integers limits the range of integer values and mathematical operations; this limitation can result in overflow or other errors. </li>
				<li><strong>EK 2.1.2C</strong> In many programming languages, the fixed number of bits used to represent real numbers (as floating point numbers) limits the range of floating point values and mathematical operations; this limitation can result in roundoff errors </li>
				<li><strong>EK 2.2.3A</strong> Different programming languages offer different levels of abstraction. </li>
				<li><strong>EK 2.2.3B</strong> High level programming languages provide more abstractions for the programmer and make it easier for people to read and write a program. </li>
				<li><strong>EK 2.2.3C</strong> Code in a programming language is often translated into code in another (lower-level) language to be executed on a computer. </li>
				<li><strong>EK 2.2.3D</strong> In an abstraction hierarchy, higher levels of abstraction (the most general concepts) are placed toward the top; lower level abstractions (the more specific concepts) toward the bottom. </li>
				<li><strong>EK 2.2.3E</strong> Binary data is processed by physical layers of computing hardware, including gates, chips, and components. </li>
				<li><strong>EK 2.2.3F</strong> A logic gate is a hardware abstraction that is modeled by a Boolean function.
<!--Exclusion Statement (2.2.3F): Memorization of specific gate visual representations is beyond the scope of this course and the AP Exam.--></li>
				<li><strong>EK 2.2.3G</strong> A chip is an abstraction composed of low level components and circuits that perform a specific function.</li>
				<li><strong>EK 2.2.3H</strong> A hardware component can be low level like a transistor or high level like a video card.</li>
				<li><strong>EK 2.2.3I</strong> Hardware is built using multiple levels of abstractions, such as transistors, logic gates, chips, memory, motherboards, special purposes cards, and storage devices. </li>
				<li><strong>EK 2.2.3J</strong> Applications and systems are designed, developed, and analyzed using levels of hardware, software, and conceptual abstractions. </li>
				<li><strong>EK 5.2.1F</strong> Processes use memory, a central processing unit (CPU), and input and output. </li>
				<li><strong>EK 5.5.1B</strong> Integers may be constrained in the maximum and minimum values that can be represented in a program because of storage limitations. </li>
				<li><strong>EK 5.5.1E</strong> Logical concepts and Boolean algebra are fundamental to programming.</li>
				<li><strong>EK 7.2.1A</strong> Machine learning and data mining have enabled innovation in medicine, business, and science. </li>
				<li><strong>EK 7.2.1B</strong> Scientific computing has enabled innovation in science and business.</li>
				<li><strong>EK 7.2.1C</strong> Computing enables innovation by providing access to and sharing of information. </li>
				<li><strong>EK 7.2.1F</strong> Moore's law has encouraged industries that use computers to effectively plan future research and development based on anticipated increases in computing power. </li>
			</ul>
		</div>			


	</body>
</html>
