<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<script src="https://www.w3schools.com/lib/w3.js"></script>
		<title>Unit 6 Lab 1 Teacher Guide</title>
	</head>

	<body>
		<h2>Lab 1: Computer Abstraction Hierarchy</h2>
		<p>People mostly take for granted the enormous behind-the-curtain mechanism that allows their favorite apps to work. Unit 4 gave a first glimpse at that mechanism for apps that rely on the Internet,  with an abstraction hierarchy that includes application protocols, TCP, IP, and link layer (hardware interface) protocols. There are even more levels of abstraction inside your local computer. The purpose of this lab is to tour the levels of abstraction, from high (application programs) to low (transistors).</p>
		<p>Why tour that whole range? Most computer engineers specialize in one level of abstraction, spending their entire careers  at that level. But the engineers who really change the nature of the technology are always aware of the latest developments at  levels above and below their own work, because those other levels exert pressure on the design of any individual level.</p>
		<p>An example. At the start of the 1970s, computer architectures were mostly designed to provide a  large and flexible set of machine language instructions. By the end of the decade, instruction sets were  smaller and simpler. Why? Two reasons. <strong>Pressure from above.</strong> In the early '70s, a lot of programming was done by human programmers writing machine language (using  assembly language notation). By the end of the decade, compiler technology had improved enough for pretty much everyone to trust compilers to produce efficient programs. For a compiler, simple instruction sets make it easier to optimize programs. <strong>Pressure from below.</strong> In the early '70s,  processor circuitry   was much faster than the computer's memory,  so it made sense to get as much computation as possible out of each instruction loaded from memory. By the end of the decade, multilevel cache memory technology made memory references  about as fast as processor cycles, so the way to make programs  efficient was to load instructions  from memory as fast as possible, each instruction doing only as much computational work as can fit before the next instruction arrives.</p>
		<p>The details of this example aren't important for you or your students to learn; the point of the story is to motivate familiarizing students with the entire hierarchy from top to bottom.</p>
		<p>Not all abstraction levels are equally important. We single out two: the <em>software abstraction</em> that allows a computer to solve different problems without having to be physically rewired for each one, and the <em>digital abstraction</em> that allows hardware designers to pretend that a transistor is always either fully on or fully off.</p> 
		
		<h3>Pacing</h3>
		<div>
			The 6 required lab pages could be split across 3-6 days (<strong>130-260 minutes</strong>). Expected times to complete follow:
			<ul>
                <li>15-30 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/01-abstraction.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">Abstraction Inside the Computer</a></li>
                <li>15-30 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/02-software-applications.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Software Domain: Applications</a></li>
                <li>30-60 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/03-software-languages.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Software Domain: Programming Languages</a></li>
                <li>30-60 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/04-software-libraries.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Software Domain: Libraries</a></li>
                <li>15-30 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/05-software-OS.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Software Domain: Operating Systems</a> *</li>
                <li><div class="comment">Brian and Mary have not decided about the asterisk on the Architecture page. Otherwise, he's approved these asterisks. --MF, 12/1/17 </div>X-X minutes (X-X class periods) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/07-digital-architecture.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Digital Domain: Architecture</a> *</li>
                <li>15-30 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/08-digital-components.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Digital Domain: Components</a></li>
                <li>25-50 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/09-digital-IC.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Digital Domain: Integrated Circuits</a> *</li>
                <li>25-50 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/10-digital-logic-gates.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Digital Domain: Logic Gates</a></li>
                <li>10-20 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/6-computers/1-abstraction/11-analog.html?topic=nyc_bjc%2F6-how-computers-work.topic&course=bjc4nyc.html&novideo&noassignment">The Analog Domain: Transistors</a> *</li>	    
            </ul>
		</div>

        <div w3-include-html="/bjc-r/utilities/includes/asterisk.txt"></div><script>w3.includeHTML();</script>

		<h3>Prepare</h3>
		<div>
			<ul>
                <li>To leave  you free to choose, the ideal introduction to this unit  is not mentioned in the student materials, but it's exciting and instructive  for students in groups to take apart an actual  (<em>old</em>) computer.  (Preferably, one  per four students or so, but even just one computer with the whole class watching is still  great.) You don't need a <em>working</em> computer, but working is better; the thrill when they put it back together and it still works is fantastically motivating. In most places, it's no longer legal to dump old computers in the garbage, so nonworking computers can often be obtained free from   recycling centers. Working  antiques (i.e., over ten years old) can be bought very cheaply at used computer stores or    recycling centers. If your school is buying new computers,  you may be able to grab  old ones before they leave the building.</li>
                <li><a href="ifixit.com">ifixit.com</a> is one good source of teardown guides, such as this example: <a href="https://www.ifixit.com/Teardown/Compaq+Deskpro+EN+Teardown/55804">https://www.ifixit.com/Teardown/Compaq+Deskpro+EN+Teardown/55804</a>. You can perhaps find one specifically for the particular model of old computer you salvaged. It doesn't have to be on their site; just do a web search for your computer model and the word "teardown."</li>
                <li>Safety guide.</li>
                <ul>
                <li><em><strong>Do not tear down a laptop</strong></em> the first time you try this activity. Laptops are very dense, and parts are often held together with glue. People do tear down laptops and even get them working again, but get some experience with desktop/tower computers first. Also, laptop batteries have been known to catch fire.</li>
                <li><em><strong>Do not tear down a cell phone in class ever.</strong></em> Besides sharing all the problems of laptops, they have highly explosive and flammable batteries. </li>
                <li><em><strong>Grounding. </strong></em>If you want the computer to work afterward, whoever works on the electronics should be grounded before opening the case. This is to protect the <em>electronics</em>; the <em>person</em> is safe with or without grounding. Pros use a metal strap wrapped around their wrist with a wire clamped to a water pipe. Or, touching the metal frame of any grounded object—one that has a three-prong power cord (and is plugged in)—will do. Look up "grounding  while working on a computer" to learn more.</li> 
                </ul>
			</ul>
	</div>


		<h3>Lab Pages</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Abstraction Inside the Computer.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>This is a long lab with many pages; the point of this first page is to provide a table of contents, and a grouping of abstraction levels into three major "domains": software, digital, and analog.</li>
								<li></li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>This tip is about the whole lab, not just the first page, but it's about the domains that are introduced here:
								  <ul>
								    <li>The levels of abstraction in the <em>software</em> domain are <em>different programs:</em> the application programs are written in a programming language, and use libraries, and interface with the operating system to control the hardware.</li>
								    <li>By contrast, the levels of abstraction in the <em>digital</em> domain are <em>different ways of thinking</em> about the <em>same</em> physical object. Envision yourself holding a processor chip in your hand, and asking yourself
								      <ul>
								        <li>What's it for?</li>
								        <li>What are the big pieces inside it?</li>
								        <li>What's physically	inside	the	plastic	case?</li>
								        <li>What are the primitive building blocks of a digital circuit?</li>
							          </ul>
								    </li>
							      </ul>
								</li>
								<li>Nobody (you or kids) needs to obsess over the specific levels of abstraction. The main points are that software lets you control a computer, abstracting away the actual machine; and "zeros and ones" are an abstraction over the way transistors really work.</li>
                                <div class="comment">This abstraction commentary should really appear earlier. We should change the next year, and what remains here should just be a nod to that ongoing discussion. --MF, 11/21/17 (with Brian)</div>
                                <li>Abstraction has many nuanced meanings in computer science. At the end of each page that deals with abstraction, ask students, "What does abstraction mean on this page?" and consider keeping a running log.</li>							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 2: The Software Domain: Applications.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>This page is  light on technical content, mostly reviewing what students  know from experience but emphasizing <em>creating</em>  rather than just consuming.</li>
								<li>The major point: People may see apps as the complete story about software, but  apps are the tip of the iceberg, supported by a huge collection of other software.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>Here and there in the litany of software uses are bad ones: fake news, finding out your political views, malware. Don't over-emphasize these, but also don't leave the page until at least one comes up in discussion.</li>
								<li>Consider reading and discussing the chapter "Propaganda Machine" (pages 68–83) in <em>Weapons of Math Destruction: How big data increases inequality and threatens democracy</em> by mathematician Cathy O'Neil. It gives examples of destructive sides of "targeted advertising," and mentions a school in Brooklyn that helped expose one such destructive example.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 3: The Software Domain: Programming Languages.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Some languages are at a higher level of abstraction than others.</li>
								<li>In almost all situations, higher is better, both for safety against bugs and for ease of programming.</li>
								<li>On the other hand, all general-purpose languages are <em>equivalent</em> in the sense that an algorithm expressible in one language is expressible in any.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>Keep this entire lab light. Throughout the lab, there's a <em>lot</em> that can be expanded—this page in particular  fills an entire semester course for college computer science students—but your students need just the overview. Some students will want more, so <strong>we use hint boxes differently here</strong> from how we use them elsewhere. Usually these boxes hide support for students who are struggling. Here, they hide  detail that's not needed for the AP exam, but may appeal to student curiosity.</li>
								<li><div class="comment"> This entire long paragraph is likely to be obscure to nearly all teachers ("programmer-controlled memory management, "dangling pointer bugs," "dynamic typing"). In this form, I don't think it <em>serves</em> its useful purpose. Brian, please fix. The Java example (can't create <code>for</code>) might be clear. Other things might be, without CS jargon. Shorter is better. --PG</div> There are many ways to make taxonomies of programming languages; we take abstraction as our guiding idea. The things that make one language more abstract than another are generally subtle. We tried to pick examples that are relatively easy to explain, even if students may be unfamiliar with them. For example, automatic memory management versus programmer-controlled memory management isn't an obvious difference when reading code, but it's perhaps the most important example; today it would be engineering malpractice to use a language that allows programmers any control over memory allocation. It's easy to make that case, because of a long history of programming disasters caused by dangling pointer bugs in old software. Some other examples are harder to explain. One such example in the lab is that high level languages associate data types with values, whereas low level languages associate data types with variables. (That is, if your language makes you say <code>int i</code> or <code>float x</code>, it's a low-level language.) It's easy enough to say what we just said, but harder to explain why dynamic typing (the high-level kind) is better. (One reason is that in a language with dynamic typing it's just as easy to make a list whose items are of different data types as to make one whose items are all integers, or all character strings.) A high level language allows users to invent new syntactic forms, such as the <code>for</code> block in the Snap<em>!</em> tools library. Java, for example, has a <code>for</code> notation, but if it didn't, a Java programmer couldn't create one. A final example, discussed at length in Lab 2, is that a high-level language doesn't limit the size or precision of numbers based on the width of the machine architecture; you should be able to compute 200 factorial and get an exact integer answer.</li>
								<!-- <li>The page makes the argument that some languages students have never heard of, such as Scheme, are all-around better than the languages they <em>have</em> heard of, such as Python or Java. It's not important that students, or you, agree with this, but in evaluating the idea, bear in mind that the most widely used operating system on computers is Microsoft Windows. Popularity doesn't imply high quality.</li> 
								<li>Another side point to note is that <em>our</em> language, Snap<em>!</em>, is higher level than many of the "grownup" languages even though it looks like a kid language. It would be great if students come to understand this, although it's not really a goal of the course.</li>-->
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 4: The Software Domain: Libraries.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Anyone who writes an application program is standing on the shoulders of excellent programmers who build libraries that do many of the hard parts.
								  <ul>
								    <li>Most of the time, it's the application programmers who get rich and famous, while the library programmers are often university students who do this work for love.</li>
							      </ul>
								</li>
								<li>Two of the specific topics on this page, color codes and data compression, are AP Framework topics as well as being examples of tasks generally done by libraries. <span style="color: #d2691e">(It's because of libraries that programmers can specify colors by name, such as "cinnamon," rather than having to remember or look up numeric codes such as "d2691e".)</span><br>
								</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>We use run-length encoding as an example of lossless compression because this algorithm, unlike many, is  easy for students to understand.</li>
								<li>
                                	If you want to present a similarly simple algorithm for lossy compression, consider reducing the set of possible colors by restricting each of red, green, and blue to the (hexadecimal) values 00, 11, 22, ... dd, ee, and ff, so that <span style="color:#d62">cinnamon would be rounded to dd6622, and then stored in files as d62.</span> Each color number would then take two bytes (including transparency) instead of four. You can see that that color is closer to orange than the real cinnamon, but the change is hardly noticeable in real pictures:<br />
                                    <img class="indent" src="/bjc-r/img/6-computers/pond-small-palette.png" alt="pond with reduced color palette"><br />
                                    By the way, this picture was processed using Snap<em>!</em>'s Pixels library:<br />   <div class="todo">ST-This is confusing and its purpose unclear.<p>The purpose is to make the point that we can create media-computation examples in Snap<em>!</em>.</div>
									<img class="indent" height="132" src="/bjc-r/img/6-computers/small-palette script pic.png" alt="small-palette-script">
                                </li>
								<li>When people who aren't programming language specialists compare languages, it's almost always the libraries that they are comparing, e.g., "JavaScript is good because you can make web pages in it."  That's because the JavaScript in web browsers has a web-page library, not because of the language itself.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 5: The Software Domain: Operating Systems.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>An operating system (Linux, macOS, Windows, etc.) is actually a package of hundreds of programs including applications (Finder, TextEdit, etc.) and libraries, along with one special program: the kernel.</li>
								<li>The kernel is almost always written in a low-level language, because it has to have access to specific memory addresses (not general-purpose memory at all, but rather I/O device control registers) and other hardware features such as the clock.</li>
								<li>The AP Framework doesn't explicitly mention the operating system or its kernel, but some  EKs are indirectly about the kernel, such as "5.2.1G A process may execute by itself or with other processes." If  one processor is running multiple processes  at once,  there has to be a <em>scheduler</em> that switches the hardware's attention among  the processes. That's part of the kernel. Similarly, the kernel is in charge of security in the file system.</li>
							</ul>
						</li>
						<!-- <li>
							<strong>Tips:</strong>
							<ul>
								<li>It would be nice if we could include a programming task here, but we can't; your school's IT person would never permit students to have kernel-level access to the computers.</li>
							</ul>
						</li> -->
					</ul>
				</li>
                <li>
					<strong>Page 6: The Digital Domain: Architecture.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>To a first approximation, an architecture is a machine language. The job of the architecture is to enable the software abstraction by specifying how to interpret a binary sequence as representing an algorithm, just as Unicode specifies how to interpret a binary sequence as a character string.</li>
								<li>Many different hardware devices might implement the same architecture, e.g., at different speeds and costs. The architecture is an <em>interface specification, </em>a document you can read, rather than an actual piece of hardware.</li>
								<li>Long before we had electronic circuit devices, the crucial invention of the <em>stored-program</em> architecture was made by Charles Babbage with Ida Lovelace.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>There are two yellow "hint boxes" at the end of the page. The first  makes the point that pretty much all computers these days (except for phones and tablets) use the <em>same</em> Intel x86 architecture. That wasn't always true. PCs have always been Intel-based, but the Mac started out using the Motorola 68000 architecture, then the Apple-specific PowerPC architecture, before switching to x86. If you're interested, these are further questions you can suggest as research topics:
								  <ul>
								    <li>Why did desktop/laptop computers end up with every brand using a single architecture?</li>
								    <li>And why <em>didn't</em> that happen (so far) for phones and tablets?</li>
							      </ul>
							  </li>
								<li>The second hint box is about  architecture in general. Second sourcing is just an interesting side point about why all computers use x86, but the note about memory hierarchy is important to a full understanding of the AP's topics about memory. Specifically, the AP wants students to know that the components of a computer include the processor and the memory, but these days, the most important parts of the memory—the level-1 and level-2 caches—are <em>part of the same chip</em> as the processor. One reason for this is that today's processors are fast enough so that the speed of electrons through wire matters; the fastest memory has to be mere nanometers away from the processor.</li>
							</ul>
						</li>
					</ul>
		  </li>
                <li>
					<strong>Page 7: The Digital Domain: Components.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<div class="comment">These learning goals are getting too complex and tip-like. Need some revision. --MF, 11/29/17</div>
                            <ul>
								<li>The most important components to understand are the <em>processor,</em> which carries out the steps of a program, and the <em>memory, </em>which holds both the program and its data. (But in a modern computer, part of the memory&mdash;the level-1 and level-2 caches&mdash;are in the same chip as the processor. The processor registers are also a very small memory.)</li>
								<li>The relevant AP CSP EK talks about the traditional idea of three components: processor, memory, and input/output. Students, on the other hand, are likely to list the things they can see and feel: the keyboard, the screen, the printer, the backup disk, and so on. In traditional terms, all those are lumped together under I/O devices. And it's the interface hardware <em>inside the box</em> that really counts as the I/O component.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>Not too long ago, there were specific connectors on the back of the computer (or on the side, if it's a laptop) for each kind of external device. Today, though, all of the external devices are likely to connect to the computer through one uniform interface: USB (Universal Serial Bus). So there's a single piece of hardware inside the machine that knows how to talk to <em>any</em> USB device, and then the differences among the external devices are all handled in software. If you have students who are eager for extra work, you could have them research how USB works.</li>
								<li>The bulk of this page is about the student view of components, including the things outside the box. This is because students know about these things and they or you can point to the actual things. FYTD 3 is an attempt to bring the focus into the AP idea of components, because what makes one computer model different from another are the processor width and speed, and the memory size and speed. (A third factor is the amount of disk or flash "solid state disk" memory. The disk is inside the box, but outside the chip set on the motherboard.)</li>
								<li>This lab page includes a Snap<em>!</em> programming project. The project just reinforces the component list right above it on the page. Really, the main reason to have a programming exercise here is to break up the reading-heavy nature of this lab. If you're short on time, it can be skipped or made optional for students.</li>
								<li>There's a<em> lot</em> to say about computer hardware that is way beyond the scope of this course. Students may raise questions to which you don't know the answer. Just tell them you don't know, they don't have to know for the AP test, and if they're interested they could look it up online and tell the class the answer next class meeting.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 8: The Digital Domain: Integrated Circuits.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li></li>
								<li></li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>
                                	The subject of conflict minerals used in everyday technology can be an upsetting one as it involves terrible human rights violations. As part of understanding the social implications of computing, students are asked to research this topic. Before presenting this page to students, research the topic yourself so that you are prepared for students' reactions to this harsh reality. At a minimum, read the two articles quoted on the student page, which present both the issues and some efforts to address them:
                                    <ul>
                                        <li><a href="https://iq.intel.com/tech-ethics-does-conflict-free-matter" target="_blank">Tech Ethics: Does Conflict Free Matter?</a></li>
                                        <li><a href="https://www.intel.com/content/www/us/en/corporate-responsibility/conflict-free-minerals.html" target="_blank">Intel’s Efforts Are Helping Families in the Congo</a></li>
                                    </ul>
                                </li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 9: The Digital Domain: Logic Gates.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li></li>
								<li></li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li></li>
								<li></li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 10: The Analog Domain: Transistors.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li></li>
								<li></li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li></li>
								<li></li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</div>


		<h3>Assignments</h3>
		<div>
			<ul>
				<li>...</li>
			</ul>
		</div>

			
		<h3>Solutions</h3>
		<div>
			<ul>
				<li>...</li>
			</ul>
		</div>
			
			
		<h3>Correlation with AP CS Principles Framework<a name="AP" class="anchor">&nbsp;</a></h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
				<li>Coming soon...</li>
			</ul-->
			<h4>Essential Understandings:</h4>
			<div class="todo">Need to go over each of these EUs (they are just the ones that match the listed EKs) and decide which fit. Then, need to write a single paragraph describing specifically how we cover all of them. --MF, 11/6/17</div>
			<p></p>
			<ul>
				<li><strong>EU 1.3</strong> Computing can extend traditional forms of human expression and experience.</li>
				<li><strong>EU 2.1</strong> A variety of abstractions built upon binary sequences can be used to represent all digital data. </li>
				<li><strong>EU 2.2</strong> Multiple levels of abstraction are used to write programs or create other computational artifacts.</li>
				<li><strong>EU 5.2</strong> People write programs to execute algorithms.</li>
				<li><strong>EU 5.5</strong> Programming uses mathematical and logical concepts.</li>
				<li><strong>EU 7.2</strong> Computing enables innovation in nearly every field.<br>
				</li>
			</ul>
			<h4>Learning Objectives:</h4>
			<div class="todo">Need to go over each of these LOs (they are just the ones that match the listed EKs) and decide which fit. Then, need to write a single paragraph describing specifically how we cover all of them. --MF, 11/6/17</div>
			<p></p>
			<ul>
                <li><strong>LO 1.3.1 </strong>Use computing tools and techniques for creative expression. [P2]</li>
                <li><strong>LO 2.1.2</strong> Explain how binary sequences are used to represent digital data. [P5]</li>
                <li><strong>LO 2.2.3</strong> Identify multiple levels of abstractions that are used when writing programs. [P3] </li>
                <li><strong>LO 5.2.1</strong> Explain how programs implement algorithms. [P3] <br>
                </li>
                <li><strong> LO 5.5.1</strong> Employ appropriate mathematical and logical concepts in programming. [P1]</li>
                <li><strong>LO 7.2.1</strong> Explain how computing has impacted innovations in other fields. [P1]<br>
                </li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<div class="todo">Pulled from the student pages. --MF, 11/6/17</div>
			<ul>
				<li><strong>EK 1.3.1B</strong> Digital audio and music can be created by synthesizing sounds, sampling existing audio and music, and recording and manipulating sounds, including layering and looping.</li>
				<li><strong>EK 1.3.1C</strong> Digital images can be created by generating pixel patterns, manipulating existing digital images, or combining images. </li>
				<li><strong>EK 1.3.1D</strong> Digital effects and animations can be created by using existing software or modified software that includes functionality to implement the effects and animations. </li>
				<li><strong>EK 2.1.2B</strong> In many programming languages, the fixed number of bits used to represent characters or integers limits the range of integer values and mathematical operations; this limitation can result in overflow or other errors. </li>
				<li><strong>EK 2.1.2C</strong> In many programming languages, the fixed number of bits used to represent real numbers (as floating point numbers) limits the range of floating point values and mathematical operations; this limitation can result in roundoff errors </li>
				<li><strong>EK 2.2.3A</strong> Different programming languages offer different levels of abstraction. </li>
				<li><strong>EK 2.2.3B</strong> High level programming languages provide more abstractions for the programmer and make it easier for people to read and write a program. </li>
				<li><strong>EK 2.2.3C</strong> Code in a programming language is often translated into code in another (lower-level) language to be executed on a computer. </li>
				<li><strong>EK 2.2.3D</strong> In an abstraction hierarchy, higher levels of abstraction (the most general concepts) are placed toward the top; lower level abstractions (the more specific concepts) toward the bottom. </li>
				<li><strong>EK 2.2.3E</strong> Binary data is processed by physical layers of computing hardware, including gates, chips, and components. </li>
				<li><strong>EK 2.2.3F</strong> A logic gate is a hardware abstraction that is modeled by a Boolean function.
<!--Exclusion Statement (2.2.3F): Memorization of specific gate visual representations is beyond the scope of this course and the AP Exam.--></li>
				<li><strong>EK 2.2.3G</strong> A chip is an abstraction composed of low level components and circuits that perform a specific function.</li>
				<li><strong>EK 2.2.3H</strong> A hardware component can be low level like a transistor or high level like a video card.</li>
				<li><strong>EK 2.2.3I</strong> Hardware is built using multiple levels of abstractions, such as transistors, logic gates, chips, memory, motherboards, special purposes cards, and storage devices. </li>
				<li><strong>EK 2.2.3J</strong> Applications and systems are designed, developed, and analyzed using levels of hardware, software, and conceptual abstractions. </li>
				<li><strong>EK 5.2.1F</strong> Processes use memory, a central processing unit (CPU), and input and output. </li>
				<li><strong>EK 5.5.1B</strong> Integers may be constrained in the maximum and minimum values that can be represented in a program because of storage limitations. </li>
				<li><strong>EK 5.5.1E</strong> Logical concepts and Boolean algebra are fundamental to programming.</li>
				<li><strong>EK 7.2.1A</strong> Machine learning and data mining have enabled innovation in medicine, business, and science. </li>
				<li><strong>EK 7.2.1B</strong> Scientific computing has enabled innovation in science and business.</li>
				<li><strong>EK 7.2.1C</strong> Computing enables innovation by providing access to and sharing of information. </li>
				<li><strong>EK 7.2.1F</strong> Moore's law has encouraged industries that use computers to effectively plan future research and development based on anticipated increases in computing power. </li>
			</ul>
		</div>			


	</body>
</html>
