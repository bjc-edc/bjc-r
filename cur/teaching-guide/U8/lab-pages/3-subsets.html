<!DOCTYPE html>
<html lang="en">
	<head>
        <meta charset="utf-8">
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <script src="https://www.w3schools.com/lib/w3.js"></script>
        <title>Unit 8 Lab 3 Teacher Guide</title>
	</head>

	<body>
		<h2>Lab 3: Subsets</h2>
        <p>First, students build a block to enumerate the different options at an ice cream shop, given a set of flavors. The complexity of the problem increases with the number of flavors  and the option to duplicate flavors. One challenge is that the result is a list of lists, so students have to be careful to remember whether the input to a  block is a list of simple elements or a list of lists. Then, students list the 2<sup><em>n</em></sup> subsets of a given set (list), extending the Ice Cream Bowls problem to an unlimited number of purchased flavors. The algorithm for enumerating subsets is tricky, and the coding of the recursion has a tricky base case.</p>

        <h3>Pacing</h3>
		<div>
			The 2 lab pages could be split across 2&ndash;4 days (<strong>70&ndash;140 minutes</strong>). Expected times to complete follow:
			<ul>
				<li>35&ndash;70 minutes (1&ndash;2 class periods) on <a href="/bjc-r/cur/programming/8-recursive-reporters/3-subsets/1-ice-cream-bowls.html?topic=nyc_bjc%2F8-recursive-reporters.topic&course=bjc4nyc.html&novideo&noassignment" title="Counting Ice Cream Bowls">Counting Ice Cream Bowls</a></li>
				<li>35&ndash;70 minutes (1&ndash;2 class periods) on <a href="/bjc-r/cur/programming/8-recursive-reporters/3-subsets/2-subsets.html?topic=nyc_bjc%2F8-recursive-reporters.topic&course=bjc4nyc.html&novideo&noassignment" title="Subsets">Listing the Subsets</a></li>
			</ul>
		</div>

		<h3>Lab Pages</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Counting Ice Cream Bowls</strong>
					<ul>
						<li><strong>Learning Goal:</strong> Explore a problem with a solution of exponentially increasing length.</li>
                        <li>
							<strong>Discussion:</strong> How is recursion structured in "Counting Ice Cream Bowls"?
							<ul>
								<li>What are the base cases?</li>
								<li>How does recursion reduce the problem to a simpler version of itself?</li>
								<li>How does the algorithm for 2-scoop bowls help you build an algorithm for 3-scoop bowls?</li>
								<li>In what ways is this project similar to <code>tree</code>?</li>
							</ul>
						</li>
                        <li>
                            <strong>Tips:</strong>
                            <ul>
                                <li>Make sure students understand that a vanilla-chocolate bowl is the same as a chocolate-vanilla bowl. This is helpful in building a recursive algorithm for the problem; once a flavor is used completely, it can be ignored, with a recursive call to the remaining flavors.</li>
                                <li>Expect students to have a lot of difficulty starting; encourage them to list all the 2-scoop bowls for 8 flavors as a start. When students write this list, they should notice that all the options for one flavor are exhausted, then all the options for a second flavor, and so on, which should lead them to understand how recursion can solve the problem.</li >
                                <li>If students previously worked through Pascal's Triangle, ask them about connections in this project. The total number of possible bowls is driven by the numbers in Pascal's Triangle, and students can even gain insight into the algorithm: a 3-scoop bowl from 8 flavors is found by either a 2-scoop bowl with 7 flavors (then adding the 8th), or by a 3-scoop bowl from 7 flavors (not using the 8th).</li>
                                <li>If students still cannot see a recursive way to code the algorithm, ask them to list all the 2-scoop bowls for 9 flavors, starting with a new ninth flavor you declare. It's likely they will exhaust the ninth flavor, then recognize their previous list as the rest of what is needed.</li>
                                <li>Some students will have trouble with the data structure here, since the result is a list of small lists. In particular, using the results from the 2-scoop problem to help solve the 3-scoop problem is challenging. Students who make this leap should be capable of handling the <em>n</em>-scoop case, since it is very similar.</li>
                                <li>Students are likely to build separate blocks for 2-scoop and 3-scoop algorithms. When prompted to go for 4 scoops, they are likely to recognize the similarities in the previous work, much like the different algorithms for <code>tree2</code> and <code>tree3</code> eventually led to a single overarching <code>tree</code> block.</li>
                                <li>Depending on students' programming structure, allowing repeated flavors can be simple or devastatingly difficult. This is a more difficult extension than it appears.</li>
                            </ul>
                        </li>
					</ul>
				</li>
				<li>
					<strong>Page 2: Subsets.</strong>
					<ul>
						<li><strong>Learning Goal:</strong> Explore one of the classic problems in computer science: subsets.</li>
                        <li>
							<strong>Discussion:</strong> How is recursion structured in "Subsets"?
							<ul>
								<li>Where are the base cases this time?</li>
								<li>How does recursion reduce the problem to a simpler version of itself?</li>
								<li>How can you tell from the recursion that the resulting list will have 2<sup><em>n</em></sup> elements?</li>
							</ul>
						</li>
                        <li>
                            <strong>Tips:</strong>
                            <ul>
                                <li>
                                    As the hints page notes, the base case is very difficult to get right here. Very often, students say that if there is one item in the list, the result should be that item, <em>but this is incorrect</em> because of the empty set. There are two possible base cases students should use: if there is <em>nothing</em> in the list, the result should be a list containing one item, which is an empty list:
                                    <img src="/bjc-r/img/8-recursive-reporters/emptyset.png" alt="list{list{}}" title="list{list{}}"/><br />
                                    If there is one item in the list, the result should be a list of two elements: the empty set, and a list containing the item:<br />
                                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/oneitemsubset.png" alt="list{list{},list{item 1}} reporting a list containing the empty list and list with item 1" title="list{list{},list{item 1}} reporting a list containing the empty list and list with item 1"/>
                                    <p>Stressing that the empty set must always be part of the output is a step toward this.</p>
                                </li>
                                <li>It is also helpful to remind students that the output of <code>subsets</code> is always a list of lists. This can help resolve some of the difficulties around the base case; in many ways it is easier to solve the problem with 3 items than it is with 1!</li>
                                <li>Students who have worked on Ice Cream Bowls are better prepared for this project in several ways. They're more familiar with using lists of lists. They've also built the basic idea that leads to the recursive call: an item is either in, or it's out, and either way dictates a simpler set. It is even possible to solve Subsets using only calls to Ice Cream Bowls functions: the subsets of <em>n</em> items include all the <em>n</em>-scoop bowls, all the <em>n</em>-1-scoop bowls, &hellip;, all the 1-scoop bowls, and the 0-scoop bowl.</li>
                                <li>The hint page tells students  that the <code>append</code> block is needed, and shows the general structure of the block.</li>
                                <li>Students will have trouble coming up with <code>map</code> as a means to repeat the item into the half of subsets that contain the item. There are other ways to do it, but <code>map</code> is necessary if attempting to do it within the <code>append</code> line.</li>
                                <li>A counter variable can count the number of recursive calls to show that for any <em>n</em>, the basic version of the Subsets algorithm runs in exponential time, with the number of calls doubling each time <em>n</em> increases by one. This algorithm  does not complete in "reasonable time.&quot;</li>
                                <li>On the last page, students are given the opportunity to simplify the algorithm by eliminating duplicate calls. The speedup will be very noticeable. Still, since the result is a list of 2<sup><em>n</em></sup> items (each a sublist of the original list), and each of those has to be added to the list somehow. The <em>number of recursive calls</em> is reduced from exponential to linear, but not the running time, because there are still 2<sup><em>n</em></sup> calls to <code>in front of.</code> If possible, ask students to compare the two versions of <code>subsets</code> for speed, especially on larger lists. Note that depending on the algorithms students programmed, their first definition may already avoid redundant recursive calls; if so, show them the version provided on <a href="/bjc-r/cur/programming/8-recursive-reporters/old/2-subsets-and-efficiency.html" title="Subsets and Efficiency">this page</a>.</li>
                            </ul>
                        </li>
					</ul>
				</li>
			</ul>
		</div>


        <h3>Solutions</h3>
        <div w3-include-html="/bjc-r/utilities/includes/8-solutions.txt"></div><script>w3.includeHTML();</script>


	</body>
</html>
