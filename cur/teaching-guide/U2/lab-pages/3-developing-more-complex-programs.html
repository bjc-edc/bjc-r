<!DOCTYPE html>
<html lang="en">
    <head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 2 Teacher Guide</title>
    </head>
    
    <body>
        <h2>Programming Lab 3: Developing More Complex Programs</h2>
        <p>In Lab 3, students build two  complex games, focusing almost exclusively on ideas of <strong>abstraction</strong> to serve the goals  writing clear, debuggable, improvable code&mdash;all essential for developing complex programs. They are given goals and specifications for the programs&mdash;and are given guidance on <em>structuring</em> the programs&mdash;but must find their own ways to build the parts. Both the game board project and the number-guessing-game project are very extensible and modifiable and may lead students to their own ideas.</p>
    <p>There is little new <span class="snap">snap</span> code in Lab 3. Even the idea of abstraction&mdash;analyzing a task to find its chunks or component parts or special cases  and then build blocks that <em>specialize</em> in each of them&mdash;is not really new. Students did that when they built <code>plural</code>. But making a <em>habit</em> of analyzing and chunking tasks takes time and experience. </p>
        <p>The lab ends with three shorter activities&mdash;essentially how-to's&mdash;showing techniques that can be useful in more complex programming tasks.</p>
        
        
        <h3>Pacing:</h3>
        <div>
            <ul>
                <li>The first three pages of this lab (Developing a Board Game, Developing a Number Guessing Game, and Brick Wall) are the most important. Plan with the hopes of doing the last three pages as well, but if students get involved in extensions of the first three pages, give that the priority and feel free to  condense the last three.</li>
                <li>Ideally, the last three pages. all short, could be done in a single period, with page 6 done before page 5. The <strong>Tips</strong> section below suggests how.</li>
            </ul>
        </div>
        <div class="time">
        	<ul>
                <li>Lab 3 page 1: Abstraction: Developing a Board Game (this is required for U3L4, but it's possible to skip that too)</li>
                <li>Lab 3 page 2: Abstraction: Developing a Number Guessing Game</li>
                <li>Lab 3 page 3: Abstraction: Brick Wall</li>
                <li>Lab 3 page 5: Composition of Functions</li>
                <li>Lab 3 page 6: Analyzing Various Definitions of &gt;=</li>
            </ul>
        </div>

    	<h3>Students will:</h3>
        <div class="sidenoteBig">
        	<strong>Looking Ahead</strong>
        	<ul>
            	<li>The tools developed in this unit anticipate a variety of games that students will be able to develop: tic-tac-toe, magic-square games, and others. More powerful programming techniques&mdash;particularly <strong>lists</strong> which are the major new programming idea in Unit 3&mdash;are useful in completing these games.</li>
            </ul>
        </div>
        
        <div>
            <ul>
                <li>Build some tools for board games: a block to draw square arrays of various sizes for the game board, and a block that determines which cell within that array where the sprite is in.</li>
                <li>Build a number guessing game in which the user tries to guess the computer's secret number, and the computer tries to respond with as human-like dialogue as the programmer can build.</li>
                <li>Experience the idea of abstraction in the context of developing blocks that specialize.</li>
                <li>Learn how to specify the type of input that a block is expecting to receive.</li>
                <li>Get practice composing functions.</li>
            </ul>
		</div>
        <h3>Tips:</h3>
        <div><ul>
          <li><strong>Page 1: Developing a board game</strong>. This  is the most complicated project in units 1 and 2, but students are given enough subtasks to make it likely that, <em>working together</em>, they can succeed. Working together is key. Some will figure out how to solve certain parts, and others will figure out how to solve other parts. Sharing, they will learn from each other.</li>
          <li><em>What do I do when a student asks how to solve a problem?</em> There will almost certainly be parts of some of these projects that <em>you</em> don't quickly see how to do. But even when you <em>do</em> know how to solve the problem, the most useful answer you can give is often one of these
          	<ol> 
              <li>Show me what you've already figured out.</li>
          	  <li>What are the <em>parts</em> of the problem that need to be built? </li>
          	  <li>Is there a good starting place (or a thing to do next), something really simple that will get us a bit closer?</li></ol></li>
       
            <li>To avoid overloading the text, the orange box about abstraction doesn't  mention  that even building the board out of boxes is an abstraction-based design decision. That's not how you draw a tic-tac-toe board by hand; you draw long intersecting lines. We could have done that here, too, but wanted a <code>draw tile</code> block that could be modified later.</li>
            <li><strong>Page 2: Developing a number guessing game</strong>. This involves simpler coding, but is very open to students' creative ideas.</li>
            <li><strong>Page 3: Brick wall</strong>. This involves the simplest coding of the three projects, but contains a <strong>key idea</strong> about abstraction. The suggestion to create a <code>draw mortar</code> block is important. It shows how editing <em>one</em> block can update a program in many places. Also, although the coding is simple, figuring out how to make row B's length come out right is a hurdle.</li>
            <li><strong>Page 4: Input types</strong>. The information&mdash;how to constrain a block's inputs  to expect only numbers&mdash;is useful but not essential. Consider <em>demonstrating</em> the method yourself, and having students watch you and follow along. They may find learning from you faster and better than  working through the page.</li>
            <li>Input types in Snap<em>!</em> are <em>program documentation,</em> not constraints on the programmer. You can drop any reporter into any input slot. The input slot shapes are just hints about what the block expects. Don't emphasize type checking. It's really important for a programmer to understand the domain and range of each function, but the domain is often different from the language's types, e.g., "an even positive integer" or "a word of no more than eight letters" or "a list whose items are either Booleans or lists."</li>
            <li><strong>Page 6: Analyzing various definitions of <code>&gt;=</code></strong>. The main point  is for students to see that it's worthwhile learning the Boolean operators. The fourth definition is exactly how you'd explain the <code>&gt;=</code> function in English. By contrast, the versions using <code>if</code> bear no relation to the way you'd think about the function in a non-programming context. Because this page requires no&mdash;it is entirely discussion&mdash;you may want to do this right after showing <strong>Input types</strong>, while the whole class is working together. Then let students loose to work on Page 5.</li>
            <li><strong>Page 5: Composition of functions</strong>. This extremely short page is very useful practice both in problem solving and in programming. It also foreshadows the way associative operators can be composed by the <code>combine</code> function in Unit 3.</li>
          </ul>
</div>

            
        <!--<h3>Solutions</h3>
        <div><ul><li>...</li></ul></div>-->
            
            
        <div class="apStandards">
            <h4>AP CS Principles Computational Thinking Practices:</h4>
            <ul>
                <li>Coming soon...</li>
            </ul>
            <div class="comment">(only the LO, but no specific EK): <strong>LO 4.2.1</strong> Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]</div>
            <h4>AP CS Principles Essential Knowledge:</h4>
            <ul>
                <li><strong>EK 2.2.1A</strong> The process of developing an abstraction involves removing detail and generalizing functionality.</li>
                <li><strong>EK 2.2.1B</strong> An abstraction extracts common features from specific examples in order to generalize concepts.</li>
                <li><strong>EK 2.2.1C</strong> An abstraction generalizes functionality with input parameters that allow software reuse.</li>
                <li><strong>EK 2.2.2A</strong> Software is developed using multiple levels of abstractions, such as constants, expressions, statements, procedures, and libraries.</li>
                <li><strong>EK 4.1.1C</strong> Selection uses a Boolean condition to determine which of two parts of an algorithm is used.</li>
                <li><strong>EK 4.1.1D</strong> Iteration is the repetition of part of an algorithm until a condition is met or for a specified number of times.</li>
                <li><strong>EK 4.1.1E</strong> Algorithms can be combined to make new algorithms.</li>
                <li><strong>EK 4.1.1F</strong> Using existing correct algorithms as building blocks for constructing a new algorithm helps ensure the new algorithm is correct.</li>
                <li><strong>EK 4.1.1H</strong> Different algorithms can be developed to solve the same problem.</li>
                <li><strong>EK 5.1.2A</strong> An iterative process of program development helps in developing a correct program to solve problems.</li>
                <li><strong>EK 5.1.2B</strong> Developing correct program components and then combining them helps in creating correct programs.</li>
                <li><strong>EK 5.1.2C</strong> Incrementally adding tested program segments to correct working programs helps create large correct programs.</li>
                <li><strong>EK 5.1.3A</strong> Collaboration can decrease the size and complexity of tasks required of individual programmers.</li>
                <li><strong>EK 5.1.3B</strong> Collaboration facilitates multiple perspectives in developing ideas for solving problems by programming.</li>
                <li><strong>EK 5.1.3D</strong> Collaboration can make it easier to find and correct errors when developing programs.</li>
                <li><strong>EK 5.1.3E</strong> Collaboration facilitates developing program components independently.</li>
                <li><strong>EK 5.3.1A</strong> Procedures are reusable programming abstractions.</li>
                <li><strong>EK 5.3.1B</strong> A procedure is a named grouping of programming instructions.</li>
                <li><strong>EK 5.3.1C</strong> Procedures reduce the complexity of writing and maintaining programs.</li>
                <li><strong>EK 5.3.1D</strong> Procedures have names and may have parameters and return values.</li>
                <li><strong>EK 5.3.1E</strong> Parameterization can generalize a specific solution.</li>
                <li><strong>EK 5.3.1F</strong> Parameters generalize a solution by allowing a procedure to be used instead of duplicated code.</li>
                <li><strong>EK 5.3.1G</strong> Parameters provide different values as input to procedures when they are called in a program.</li>
                <li><strong>EK 5.4.1B</strong> Duplicated code can make it harder to reason about a program.</li>
                <li><strong>EK 5.4.1C</strong> Meaningful names for variables and procedures help people better understand programs.</li>
                <li><strong>EK 5.4.1D</strong> Longer code blocks are harder to reason about than shorter code blocks in a program.</li>
                <li><strong>EK 5.4.1E</strong> Locating and correcting errors in a program is called debugging the program.</li>
                <li><strong>EK 5.4.1F</strong> Knowledge of what a program is supposed to do is required in order to find most program errors.</li>
                <li><strong>EK 5.5.1A</strong> Numbers and numerical concepts are fundamental to programming.</li>
                <li><strong>EK 5.5.1D</strong> Mathematical expressions using arithmetic operators are part of most programming languages.</li>
                <li><strong>EK 5.5.1E</strong> Logical concepts and Boolean algebra are fundamental to programming.</li>
                <li><strong>EK 5.5.1F</strong> Compound expressions using <em>and</em>, <em>or</em>, and <em>not</em> are part of most programming languages.</li>
            </ul>
        </div>            


	</body>
</html>
