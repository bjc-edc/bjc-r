<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <title>Unit 2 Lab 1 Teacher Guide</title>
        <script type="text/javascript" src="/bjc-r/utilities/gifffer.min.js"></script>
        <script type="text/javascript">window.onload = function() {Gifffer();}</script>
        <link rel="stylesheet" type="text/css" href="/bjc-r/css/bjc-gifffer.css">
    </head>
    
    <body>
        <h2>Lab 2: Making Lists</h2>
		<p>Students have touched on lists in Unit 1, but this lab is where we really dive into them. First, in the very simple shopping list app, students learn list creation and mutation. Then, in the quiz program, we introduce the very important idea of <em>data abstraction, </em>specifying a constructor and two selectors for the <code>quiz item</code> data type.</p>
        <div class="takeNote">Data abstraction is a key idea in computer science.  Many languages provide a special syntax for abstract data types, so you might say something like<br />
<pre>class QuizItem {
   field question;
   field answer;
}</pre>
(That's not any particular language, just a stripped-down syntax to make the point.)  But in Snap<em>!</em> we use procedures instead: the constructor <img src="/bjc-r/img/2-complexity/quiz-item-constructor.png" alt="quiz item, question: ( ) answer: ( )"> to define the type, and selectors <img src="/bjc-r/img/2-complexity/question-selector.png" alt="question from quiz item ( )"> and <img src="/bjc-r/img/2-complexity/answer-selector.png" alt="answer from quiz item ( )"> to retrieve the fields of the object.  By using ordinary procedures to implement the abstract type, we show that there's no magic involved.</div>
		<p>But what we <em>don't</em> do in this lab is to introduce the higher order functions that will be our main tools for list processing later in the course. We hint at them in the third page by using <code>for each item</code>, which is a higher order procedure but not a function, and therefore doesn't require the gray ring notation that will be introduced in the next lab.</p>
        
                
        <h3>Pacing</h3>
		<p>Coming soon...</p>
        <div class="todo">
		<div>
			The 3 lab pages could be split across 3-5 days (<strong>105-210 minutes</strong>). Expected times to complete follow:
			  <ul>
				<li>15-30 minutes (&lt; 1 class period) on Shopping List App</li>
				<li>20-40 minutes (&lt; 1 class period) on Planning a Quiz App</li>
				<li>30-60 minutes (about 1 class period) on Checking Each Quiz Answer</li>
			</ul>
		</div>
        </div>
        
        <h3>Lab Pages</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Shopping List App.</strong>
							<ul>
							  <li><strong>Learning Goals:</strong>
							    <ul>
							      <li>Construct a list, add items to it.</li>
							      <li>The <em>empty list</em> is different from a list with an empty item, and is the right starting point when building a list one item at a time.</li>
							      <li>The <code>when I am clicked</code> block allows a sprite to be used as a button.</li>
						        </ul>
							    </li>
 						    </ul>
				</li>
                <li>
					<strong>Page 2: Planning a Quiz App.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
                                <li>An abstract data type consists of a <em>constructor</em> procedure and one or more <em>selector</em> procedures.</li>
                    			<li>Plan and build an abstract data type.</li>
                   			</ul>
						</li>
						<li><strong>Tips:</strong>
						  <ul>
						    <li>This page has more reading, and less doing, than most. To make it look less intimidating, we have hidden much of the reading behind &quot;hint&quot; links. Exercise 2 asks students to read the text, clicking links one at a time to look at and then re-hide each code picture. This is the only place where we've used the &quot;hinting&quot; mechanism on things we want every student to read; it's an experiment.</li>
						    <li>After the text comes a long vocabulary box that defines six terms. It starts with the most concrete terms, the ones that name procedures you can point to. Then comes the notion of a data type, and the distinction between <em>primitive</em> types built into the language and <em>abstract</em> types that are specific to one application, rather than a general feature of the programming language. At the end, <em>data abstraction</em> itself is defined as the use of abstract data types.</li>
					      </ul>
						</li>
					</ul>
				</li>
                                    <div class="narrower">
                    	<p>The table below compares the &quot;ordinary language&quot; use of <em>abstract</em> with the CS use. (It's not about data abstraction specifically, but the major levels of abstraction in computer science generally.) </p>
                        <p> In ordinary language, the actual physical computer is the "least abstract" thing, because you can hold it in your hand, push its buttons, maybe take it apart.  In ordinary language, programming seems to deal with "more abstract" ideas, things with no visible, tangible existence. In some ways, the physical thing might seem easiest to think about, and the programming at the top of the table harder.</p>
                    	<p>Computer scientists use "abstract" to mean something more like "this is defined in terms of that": application software is written in a high level language, which is itself implemented in a low level language.  It's <em>easier</em> to understand a language than to deal with all the detailsâ€”how the language is built from lower level languages, and how they work with the computer architecture, and how that's built of transistors, which depend on the behavior of electrons, and so on. From that perspective, things get harder as you move down the table.  It's easy to write a program in Snap<em>!</em>, harder to write one in C, because you have to think about more details of memory management.  It's easier to understand the design of a computer architecture (the Intel Core design, for example) than to understand the physical circuits that implement it.</p>
                        <table align="center" frame="box" rules="all">
                            <tr><th>Ordinary language</th><th>Levels of abstraction</th><th>Computer science</th></tr>
                            <tr>
                                <td>&nbsp;most abstract <small>(harder)</small></td><td>&nbsp;application software</td>
                                <td>&nbsp;most abstract <small>(easier)</small></td>
                            </tr>
                            <tr>
                                <td style="background-color:#000000">&nbsp;</td>
                                <td>&nbsp;high level language (Snap<em>!</em>)</td>
                                <td style="background-color:#e0e0e0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#404040">&nbsp;</td>
                                <td>&nbsp;low level language (C)</td>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#808080">&nbsp;</td>
                                <td>&nbsp;machine language</td>
                                <td style="background-color:#a0a0a0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                                <td>&nbsp;computer architecture</td>
                                <td style="background-color:#808080">&nbsp;</td>
                            </tr>
                            <tr>
                                <td>&nbsp;least abstract <small>(easier)</small></td>
                                <td>&nbsp;physical computer (chips, wires)&nbsp;</td>
                                <td style="background-color:#606060">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                                <td>&nbsp;transistors</td>
                                <td style="background-color:#404040">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#707070">&nbsp;</td>
                                <td>&nbsp;atoms</td>
                                <td style="background-color:#202020">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#000000">&nbsp;</td>
                                <td>&nbsp;protons, neutrons, electrons</td>
                                <td style="background-color:#000000">&nbsp;</td>
                            </tr>
                            <tr>
                                <td>&nbsp;most abstract <small>(harder)</small></td>
                                <td>&nbsp;quarks</td>
                                <td>&nbsp;least abstract <small>(harder)&nbsp;</small></td>
                            </tr>
                        </table>
					</div>

                <li>
                    <strong>Page 3: Checking Each Quiz Answer.</strong>
                    <ul>
                        <li>
                            <strong>Learning Goals:</strong>
                            <ul>
                                <li>Traverse the items of a list.</li>
                                <li>Understand and use the abstraction of the <code>for each item</code> block, which hides the use of index numbers to access each item. The programmer can just write the code to handle one item, and the block takes care of supplying items one at a time.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Tips:</strong>
                            <ul>
                                <li>A very common beginner's bug is to mistrust the <code>for each item</code> block and try to do the traversal in the script in the C-shaped slot.</li>
                                <li>Another common bug is to think that the <code>item</code> variable provided by the block contains an index (an item <em>number</em>), whereas it actually contains the item itself.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
			</ul>
		</div>
        
        <h3>Solutions</h3>
		<p>Coming soon...</p>
        <div class="todo">
		<div class="todo"><h1>SOLUTIONS NEED WORK --MF, 7/2/19</h1></div>
        <div class="todo">2.2.3 Solution (and perhaps other files) has household income stag costume in it. Check that this is correct. --MF, 1/18/19</div><div>
        <div class="todo"><h3>OLDSolutions</h3>
            <div>
                <ul>
                    <li><a href="http://snap.berkeley.edu/snapsource/snap.html#cloud:Username=BJCsolutions&ProjectName=U3L1p1%20all%20ShoppingList%20(answer%20file)" target="_blank">page 1 (Shopping List)</a></li>
                </ul>
            </div></div>
        <div>
            <ul>
                
                <li><a href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p1DrawShape%20(answer%20file)&editMode&noRun" target="_blank" title="Solution to Page 1: Processing Each Item in a List">Page 1: Processing Each Item in a List</a></li>
                <li><a href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p2DataTypes%20(answer%20file)&editMode&noRun" target="_blank" title="Solution to Page 2: Abstract Data Types">Page 2: Abstract Data Types</a></li>
             
                <div class="comment">Page 3 filename inconsistent. --MF, 12/13/17</div>
                <li><a href="http://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p3ClickToDraw&editMode&noRun" target="_blank" title="Solution to Page 3: Capturing Clicks To Draw">Page 3: Capturing Clicks To Draw</a></li>
                <li><a href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p4Mandala%20(answer%20file)&editMode&noRun" target="_blank" title="Solution to Page 4: Mandala Design">Page 4: Mandala Design</a></li>
            </ul>
        </div>
        </div>
        </div>
        					
		
        <h3>Correlation with AP CS Principles Framework</h3>
		<p>Coming soon...</p>
        <div class="todo">
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
                <li><strong>P2 Creating Computational Artifacts</strong> Create an artifact with a practical, personal, or societal intent.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Select appropriate techniques to develop a computational artifact.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Use appropriate algorithmic and information management principles.</li>
                <li><strong>P3 Abstracting</strong> Explain how data, information, or knowledge is represented for computational use.</li>
                <li><strong>P3 Abstracting</strong> Explain how abstractions are used in computation or modeling.</li>
                <li><strong>P3 Abstracting</strong> Identify abstractions.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Evaluate a proposed solution to a problem.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Locate and correct errors.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Explain how an artifact functions.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Justify appropriateness and correctness of a solution, model, or artifact.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in solving a computational problem.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in producing an artifact.</li>
                <li><strong>P6 Collaborating</strong> Share the workload by providing individual contributions to an overall collaborative effort.</li>
                <li><strong>P6 Collaborating</strong> Foster a constructive, collaborative climate by resolving conflicts and facilitating the contributions of a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Exchange knowledge and feedback with a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Review and revise their work as needed to create a high-quality artifact.</li>
			</ul>-->
			<h4>Enduring Understandings:</h4>
            <ul>
                <li><strong>EU 2.2</strong> Multiple levels of abstraction are used to write programs or create other computational artifacts.</li>
                <!--not in endorsement docs
                <li><strong>E U 5.1</strong> Programs can be developed for creative expression, to satisfy personal curiosity, to create new knowledge, or to solve problems (to help people, organizations, or society).</li>
                <li><strong>E U 5.2</strong> People write programs to execute algorithms.</li>
                <li><strong>E U 5.3</strong> Programming is facilitated by appropriate abstractions.</li>
                <li><strong>E U 5.5</strong> Programming uses mathematical and logical concepts.</li>
                -->
            </ul>
			<h4>Learning Objectives:</h4>
            <ul>
                <!--not in endorsement docs
                <li><strong>L O 1.2.2</strong> Create a computational artifact using computing tools and techniques to solve a problem. [P2]</li>
				<li><strong>L O 2.1.1</strong> Describe the variety of abstractions used to represent data. [P3]</li>
                -->
                <li><strong>LO 2.2.1</strong> Develop an abstraction when writing a program or creating other computational artifacts. [P2]</li>
                <li><strong>LO 2.2.2</strong> Use multiple levels of abstraction to write programs. [P3]</li>
                <li><strong>LO 2.2.3</strong> Identify multiple levels of abstractions that are used when writing programs. [P3]</li>
                <!--not in endorsement docs
                <li><strong>L O 5.1.2</strong> Develop a correct program to solve problems. [P2]</li>
                <li><strong>L O 5.1.3</strong> Collaborate to develop a program. [P6]</li>
                <li><strong>L O 5.2.1</strong> Explain how programs implement algorithms. [P3]</li>
                <li><strong>L O 5.3.1</strong> Use abstraction to manage complexity in programs. [P3]</li>
                <li><strong>L O 5.5.1</strong> Employ appropriate mathematical and logical concepts in programming. [P1]</li>
                -->
            </ul>
            <h4>Essential Knowledge:</h4>
            <ul>
                <li><strong>EK 2.1.1A</strong> Digital data is represented by abstractions at different levels.</li>
                <li><strong>EK 2.2.1A</strong> The process of developing an abstraction involves removing detail and generalizing functionality.</li>
                <li><strong>EK 2.2.1B</strong> An abstraction extracts common features from specific examples in order to generalize concepts.</li>
                <li><strong>EK 2.2.1C</strong> An abstraction generalizes functionality with input parameters that allow software reuse.</li>
                <li><strong>EK 2.2.2A</strong> Software is developed using multiple levels of abstractions, such as constants, expressions, statements, procedures, and libraries.</li>
                <li><strong>EK 2.2.2B</strong> Being aware of and using multiple levels of abstraction in developing programs helps to more effectively apply available resources and tools to solve problems.</li>
                <li><strong>EK 2.2.3D</strong> In an abstraction hierarchy, higher levels of abstraction (the most general concepts) would be placed toward the top and lower level abstractions (the more specific concepts) toward the bottom.</li>
                <li><strong>EK 5.1.2G</strong> Program development includes identifying programmer and user concerns that affect the solution to problems.</li>
                <li><strong>EK 5.1.2J</strong> A programmer designs, implements, tests, debugs, and maintains programs when solving problems.</li>
                <li><strong>EK 5.1.3B</strong> Collaboration facilitates multiple perspectives in developing ideas for solving problems by programming.</li>
                <li><strong>EK 5.1.3F</strong> Effective communication between participants is required for successful collaboration when developing programs.</li>
                <li><strong>EK 5.2.1C</strong> Program instructions may involve variables that are initialized and updated, read, and written.</li>
                <li><strong>EK 5.2.1E</strong> Program execution automates processes.</li>
                <li><strong>EK 5.2.1J</strong> Simple algorithms can solve a large set of problems when automated.</li>
                <li><strong>EK 5.3.1I</strong> Strings and string operations, including concatenation and some form of substring, are common in many programs.</li>
                <li><strong>EK 5.3.1K</strong> Lists and list operations, such as add, remove, and search, are common in many programs.</li> 
                <li><strong>EK 5.3.1L</strong> Using lists and procedures as abstractions in programming can result in programs that are easier to develop and maintain.</li>
                <li><strong>EK 5.5.1H</strong> Computational methods may use lists and collections to solve problems.</li>
                <li><strong>EK 5.5.1J</strong> Basic operations on collections include adding elements, removing elements, iterating over all elements, and determining whether an element is in a collection.</li>
            </ul>
		</div>
        </div>
        
    </body>
</html>
