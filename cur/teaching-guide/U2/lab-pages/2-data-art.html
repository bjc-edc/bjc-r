<!DOCTYPE html>
<html lang="en">
    <head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 2 Lab 2 Teacher Guide</title>
    </head>
    
    <body>
        <h2>Lab 2: Making Art by Using Data Structures</h2>
        <p>The <code>list</code> block is the basic building block of many  complex structures. Lists can contain anything: numbers, strings, other lists, even blocks. The objects <em>in</em> a list can be all of the same kind, but they do not have to be. A list can, for example, contain an apartment number and a list of people at that address. The tabular data we are familiar with in spreadsheets can be represented as a list of same-length lists, the smaller lists representing each row in the table, and the enclosing list representing the entire spreadsheet.</p>
          <!--A table of data, is a list of rows of data, each row being a list of data.-->
		<p> The "ordered pair" of algebra, the (<em>x</em>, <em>y</em>) coordinates of a point on a plane, can be represented as a list of two numbers. <!--In this lab, students will treat such a two-element list as a <em>point</em>, and they will encounter a list of points: a list of two-element lists. <!--(In this way, vectors and matrices can also be represented as lists of lists, but this unit will not extend into that mathematics.)- -> The <code>list</code> block is the basic building block of many  complex structures. --> Students will use a list of ordered pairs to draw a shape.</p>
		<p><img class="indent" src="/bjc-r/img/3-lists/A.png" alt="set A to {{-50,20}, {-10,120}, {10,120}, {50,20}, {30,20}, {20,50}, {-20,50}, {-30,20}}" title="set A to {{-50,20}, {-10,120}, {10,120}, {50,20}, {30,20}, {20,50}, {-20,50}, {-30,20}}" />
		<img class="imageRight" src="/bjc-r/img/3-lists/drawA.gif" alt="sprite drawing letter A by going to each set of coordinates" title="sprite drawing letter A by going to each set of coordinates" />  </p>
		<p>
            <!--In this lab, students will start first with a list of points already created for them, like the list shown above.-->
            On the first page, students are given a list of points, and they create a <code>go to point</code> block that moves the sprite to any <em>one point</em> given as input. <!--To select information in the dataset, we only need to know where it appears.--> Students can, for example, use <code>item (3) of </code> to access the third point, <var> {10, 120}</var>, and  use the code 
            <img src="/bjc-r/img/2-complexity/U2ImageVideoAddendum_img/go-to-point-item-3-of-A.png" height="50" alt="go-to-point-item-3-of-A" title="go-to-point-item-3-of-A"> 
            to move the sprite to that point. Students then <em>automate</em> this process, using the <code>for each</code> block to travel to each point to draw the shape.
        </p>
		<div class="todo">Add the word <em>automate</em> to the student page, in the dialogue and in a gray vocab box.</div> 
        <!--<p>The point (10, 120) will be the third that it visits.</p>-->
        
        <p>
            On the second page, students develop a <img class="inline" src="/bjc-r/img/3-lists/point()().png" alt="point () ()" title="point () ()" /> block and use it to replace <!--<img src="/bjc-r/img/3-lists/coordinate-list-for-A.png" height="54" alt="coordinate-list-for-A">-->the list for the letter A shown above with the list shown below.<br />
            <img class="indent" src="/bjc-r/img/3-lists/point-list-for-A.png" height="82" alt="point-list-for-A">.
        </p>
		<p> The change seems trivial; everything works the same way (in fact,  <code>point</code> does exactly what <code>list</code> does, so the computer doesn't care which code is used). But the second version makes it easier for <em>humans</em> to write, read, and understand the code. Similarly, students also create <img class="inline" src="/bjc-r/img/3-lists/x-coordinate.png" alt="x coordinate of {}" title="x coordinate of {}" /> and <img class="inline" src="/bjc-r/img/3-lists/y-coordinate.png" alt="y coordinate of {}" title="y coordinate of {}" /> blocks to replace <code>item</code>, using abstraction again to clarify the <em>purpose</em> of the code and to distinguish it from the details. This process is called constructing an <strong>abstract data type</strong>â€”using <code>point</code> as a "constructor" to produce the (<em>x</em>, <em>y</em>) coordinate pair (a list) from two individual coordinates, and "selectors" <code>x coordinate of</code> and <code>y coordinate of</code> to make code more readable. </p>
		<p>On the third page, students analyze and complete partially written code to let the programmer collect and store points in a list by clicking on the stage to indicate which points they want. On the last page, students automate that process to collect the vertices of a polygon in order to make a mandala design.</p>
        <div class="sidenoteBig">Many of the <span class="snap">snap</span> projects linked from the student pages already have the tools imported.</div>
        <p>Students need to <img class="inline" src="/bjc-r/img/icons/import-tools.png" alt="Import Tools" title="Import Tools" /> each time they open a new <span class="snap">snap</span> window.</p>
        
        <h3>Pacing</h3>
        <div>
			The 4 lab pages could be split across 3-5 days (<strong>115-200 minutes</strong>). Expected times to complete follow:
			<ul>
				<li>20-40 minutes (less than 1 class period) on <a href="/bjc-r/cur/programming/2-complexity/2-data-structures-art/1-the-for-each-block.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment">Processing Each Item in a List</a></li>
				<li>25-50 minutes (less than 1 class period) on <a href="/bjc-r/cur/programming/2-complexity/2-data-structures-art/2-data-types.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment">Abstract Data Types</a></li>
				<li>30-60 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/2-complexity/2-data-structures-art/3-click-points-new.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment">Capturing Clicks to Draw</a></li>
				<li>40-50 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/2-complexity/2-data-structures-art/4-mandala.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment">Mandala Design</a></li>
			</ul>
		</div>
        
        
        
        <h3>Lab Pages</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Processing Each Item in a List.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
				                <li>Use the <code>for each</code> block to do something with each item in a list.</li>
                            	<li>Learn how to specify the type of input that a block is expecting to receive.</li>
                            	<li>Debug programs by attending to data types.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                        		<li>The dialogue has some complicated ideas. Arrange so that students get a chance to read it through more than once: individually, in small groups, in front of the class, etc. </li>
                                <!--<img class="imageRight" src="/bjc-r/img/2-complexity/new-for-each-point-script.png" alt="script with for each (item) of (A) {go to point (item)}" title="script with for each (item) of (A) {go to point (item)}" />-->
                                <img class="imageRight" src="/bjc-r/img/2-complexity/U2ImageVideoAddendum_img/gotopoint_fillinTheBlanks.png" height="100" alt="go to point fill in the blanks" title="go to point fill in the blanks"/>
                                <li>Encourage students to  complete the two blanks in the script (shown at right) first, and only after most of the letter is drawing	 correctly to begin addressing the two bugs at the beginning and end of the drawing process.</li>
                                <li>For the Take It Further problem, students may need to review the concept of <em>slope</em> from algebra to identify the remaining points in the letter.</li>
                                <li>Debugging: As students fix the bugs in Alphie and Betty's script, they must seek the cause(s) of the unwanted and missing lines in the drawing and identify the appropriate solution.</li>
                                <li>Students who have programmed before in Scratch will be surprised about the use of lists (points) as inputs to a block, because Scratch doesn't allow that. You don't have to bring this up with the whole class, but if you get questions about it, you can just say that this is one of the ways that Snap<em>!</em> has extended Scratch.</li>
                                <li><strong>Mathematics Note: Coordinates Again.</strong>  The list <strong>A</strong> contains the coordinates of the  points (<em>vertices</em>) that define the picture of the letter <em>A</em> in <em>that position</em> on the stage.  You can transform these coordinates to draw an exact replica of <em>A</em> in another spot on the stage. This would be useful, for example, if you want to set two letters next to each other on the screen, or make a "shadow" of <em>A</em> or to draw an offset image to create a three-dimensional effect. Try creating a list <em>AA</em> from <em>A</em> by adding, say, 50 to each of the coordinates of each of the points, and then plot the resulting points with <code>for each</code>.</li>
								<li>The information on this page about how to declare a block's inputs to expect only numbers is useful, but it's not essential that they learn it from the lab. Consider <em>demonstrating</em> the method yourself, and having students watch you and follow along. They may find learning from you faster and better than  working through the page.</li>
								<li>Input types in Snap<em>!</em> are <em>program documentation,</em> not constraints on the programmer. You can drop any reporter into any input slot. The input slot shapes are just hints about what the block expects. Don't emphasize type checking. It's really important for a programmer to understand the domain and range of each function, but the domain (e.g., "an even positive integer" or "a word of no more than eight letters" or "a list whose items are either Booleans or lists") is often different from the language's types.</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					<strong>Page 2: Abstract Data Types.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
				                <li>Understand what a data type is.</li>
                                <li>Understand how abstract data types help  increase clarity.</li>
                                <li>Create abstract data types to organize and manage data.</li>
								<li>Reconceptualize lists of lists as lists of abstract data, to simplify their use and prevent bugs.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                            	<li>Again, consider having students read the dialogue more than once.</li>
		                        <li>
                                	Discussion: After all students have worked through the dialogue (and perhaps also added the abstract data type to their U3L2-DrawShape project), you might review with questions like these:
                                    <ul>
                                        <li>What are some benefits of creating an abstract data type?</li>
                                        <li>In what other situations might abstract data types be helpful?</li>
                                        <li>What is a <em>primitive</em> data type? What are some examples?</li>
                                        <li>What is an <em>abstract</em> data type? What are some examples?
                                          <ul>
                                            <li>In particular, what data in Unit 1 projects could be treated as abstract data types?</li>
                                          </ul>
                                        </li>
                                        <li>What is the difference between a primitive data type and an abstract data type?</li>
                                        <li>How are abstract data types an example of abstraction?</li>
                                    </ul>
                        		</li>
                                <li>"Abstract data type" (or ADT) sounds like a complicated thing, but programmers actually use them to simplify <em>and clarify</em> the logical structure of their code. It is a thing to help <em>people</em>, not <em>machines</em>. An abstract data type is like a "template" for data&mdash;for example, a registration form on which individuals write their name, address, email, etc., in a particular place helps us know where to look for each part of the data. </li>
							</ul>
						</li>
					</ul>
                    <div class="narrower">
                    	<p>The table below shows, not data abstraction specifically, but the major levels of abstraction in computer science generally.  In ordinary language, the actual physical computer is the "least abstract" thing, because you can hold it in your hand, push its buttons, maybe take it apart, etc.  As you get further away from the computer itself, you get to "more abstract" ideas, things with no visible, tangible existence.  For many people, the physical thing is easiest to think about.</p>
                    	<p>By contrast, the sense in which computer scientists use "abstract" means something more like "this is defined in terms of that": application software is written in a high level language, which is itself implemented in a low level language, etc.  At the bottom of the table, atoms are made out of protons etc., and those are made out of quarks.  From that perspective, things get harder as you move down the table.  It's easy to write a program in Snap<em>!</em>, harder to write one in C, because you have to think about more details of memory management.  It's easier to understand the design of a computer architecture (the Intel Core design, for example) than to understand the physical circuits that implement it.</p>
                        <table align="center" frame="box" rules="all">
                            <tr><th>Ordinary language</th><th>Levels of abstraction</th><th>Computer science</th></tr>
                            <tr>
                                <td>&nbsp;most abstract <small>(hard)</small></td><td>&nbsp;application software</td>
                                <td>&nbsp;most abstract <small>(easy)</small></td>
                            </tr>
                            <tr>
                                <td style="background-color:#000000">&nbsp;</td>
                                <td>&nbsp;high level language (Snap<em>!</em>)</td>
                                <td style="background-color:#e0e0e0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#404040">&nbsp;</td>
                                <td>&nbsp;low level language (C)</td>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#808080">&nbsp;</td>
                                <td>&nbsp;machine language</td>
                                <td style="background-color:#a0a0a0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                                <td>&nbsp;computer architecture</td>
                                <td style="background-color:#808080">&nbsp;</td>
                            </tr>
                            <tr>
                                <td>&nbsp;least abstract <small>(easy)</small></td>
                                <td>&nbsp;physical computer (chips, wires)&nbsp;</td>
                                <td style="background-color:#606060">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                                <td>&nbsp;transistors</td>
                                <td style="background-color:#404040">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#707070">&nbsp;</td>
                                <td>&nbsp;atoms</td>
                                <td style="background-color:#202020">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#000000">&nbsp;</td>
                                <td>&nbsp;protons, neutrons, electrons</td>
                                <td style="background-color:#000000">&nbsp;</td>
                            </tr>
                            <tr>
                                <td>&nbsp;most abstract <small>(hard)</small></td>
                                <td>&nbsp;quarks</td>
                                <td>&nbsp;least abstract <small>(harder)&nbsp;</small></td>
                            </tr>
                        </table>
					</div>
				</li>
                <li>
                	<strong>Page 3: Capturing Clicks to Draw.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>This page prepares for page 4, in which a list of points is generated automatically within a program. This page introduces a program-generated list in an easier context: The user clicks on a point, and the program adds <em>that point</em> to the list.</li>
								<li>This page also introduces the primitive <code>stamp</code> to draw a picture of the sprite at its current location on the stage.</li>
								<li>The page also reinforces the idea of data abstraction. On page 2, students created an ADT and used it to rewrite a program they'd already written. It's hard to make that convincing, but here they are writing entirely new code that's much easier because of the <code>point</code> abstraction.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                                <li>Students should focus mainly on learning how to write code that collects points into a list. Fancy touches, such as visual details, are optional but not important now.</li>
                                <div class="todo">
                                    <p>ST- Brian I am concerned about this next paragraph.  It sounds too convoluted and unnecessary to me to expose teachers to such a bug even though briefly.  What exactly is the point of using non-ASCII  characters in the first place?</p>
                                    <p>I'll change the name of the block as we discussed. --bh</p>
                                </div>
                                <li><strong>The following is a problem only in spring 2017 during some teacher workshops; it will be fixed before students see this page. </strong>There is a Snap<em>!</em> bug that prevents saving to the cloud a project with a name made of non-ASCII characters, such as the script letters in the <img src="/bjc-r/img/2-complexity/stuff-here.png" alt="stuff here"> block. There are two workarounds: (1) replace the script words with plain letters; (2) use "export project" instead This will be an issue only until the page has been finished, at which point the <code>you write</code> block should no longer be used anywhere and can be deleted.</li>
								<li>Note that, when using <code>stamp</code>, you can't see any change until the sprite moves away, because the picture looks exactly like the sprite and is in exactly the same place. Students may think that it "didn't work."</li>
								<li>Some students may object to making <code>list of points</code> a reporter, because the shape is already drawn when it finishes running -- why do we need to keep the list of point? Remind them that they might want to draw a letter <em>more than once,</em> as part of a message, for example.</li>
								<li>Experienced Scratch programmers, who have seen primitive reporters but have not been able to write their own before, may note that the primitive reporters don't <em>do</em> anything visible, but instead <em>only</em> report a value. <code>List of blocks</code>carries on an interaction and draws on the stage before finally reporting a value. They may find this surprising, but it's not a problem or breaking a rule.</li>
							</ul>
						</li>
					</ul>
                </li>
				<li>
					<strong>Page 4: Mandala Design.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Apply everything learned in this lab in an artistic context.</li>
                                <li>Gain experience in breaking a somewhat large and difficult task into smaller managable parts.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>This page relies on the succesful mastery of the previous two pages.</li>
								<li>It may be helpful for students to hand draw a simple version of the Mandala to get a feel how the algorithm might work.</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</div>


        <h3>Solutions</h3>
        <div>
            <ul>
                
                <li><a href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p1DrawShape%20(answer%20file)" target="_blank">Page 1: Processing Each Item in a List</a></li>
                <li><a href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p2DataTypes%20(answer%20file)" target="_blank">Page 2: Abstract Data Types</a></li>
             
                <li><a href="http://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p3ClickToDraw" target="_blank">Page 3: Capturing Clicks To Draw</a></li>
                <li><a href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p4Mandala%20(answer%20file)" target="_blank">Page 4: Mandala Design</a></li>
            </ul>
        </div>	
        					
		
        <h3>Correlation with AP CS Principles Framework</h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
                <li><strong>P2 Creating Computational Artifacts</strong> Create an artifact with a practical, personal, or societal intent.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Select appropriate techniques to develop a computational artifact.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Use appropriate algorithmic and information management principles.</li>
                <li><strong>P3 Abstracting</strong> Explain how data, information, or knowledge is represented for computational use.</li>
                <li><strong>P3 Abstracting</strong> Explain how abstractions are used in computation or modeling.</li>
                <li><strong>P3 Abstracting</strong> Identify abstractions.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Evaluate a proposed solution to a problem.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Locate and correct errors.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Explain how an artifact functions.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Justify appropriateness and correctness of a solution, model, or artifact.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in solving a computational problem.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in producing an artifact.</li>
                <li><strong>P6 Collaborating</strong> Share the workload by providing individual contributions to an overall collaborative effort.</li>
                <li><strong>P6 Collaborating</strong> Foster a constructive, collaborative climate by resolving conflicts and facilitating the contributions of a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Exchange knowledge and feedback with a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Review and revise their work as needed to create a high-quality artifact.</li>
			</ul>-->
			<h4>Enduring Understandings:</h4>
            <ul>
                <li><strong>EU 2.2</strong> Multiple levels of abstraction are used to write programs or create other computational artifacts.</li>
                <!--not in endorsement docs
                <li><strong>E U 5.1</strong> Programs can be developed for creative expression, to satisfy personal curiosity, to create new knowledge, or to solve problems (to help people, organizations, or society).</li>
                <li><strong>E U 5.2</strong> People write programs to execute algorithms.</li>
                <li><strong>E U 5.3</strong> Programming is facilitated by appropriate abstractions.</li>
                <li><strong>E U 5.5</strong> Programming uses mathematical and logical concepts.</li>
                -->
            </ul>
			<h4>Learning Objectives:</h4>
            <ul>
                <!--not in endorsement docs
                <li><strong>L O 1.2.2</strong> Create a computational artifact using computing tools and techniques to solve a problem. [P2]</li>
				<li><strong>L O 2.1.1</strong> Describe the variety of abstractions used to represent data. [P3]</li>
                -->
                <li><strong>LO 2.2.1</strong> Develop an abstraction when writing a program or creating other computational artifacts. [P2]</li>
                <li><strong>LO 2.2.2</strong> Use multiple levels of abstraction to write programs. [P3]</li>
                <li><strong>LO 2.2.3</strong> Identify multiple levels of abstractions that are used when writing programs. [P3]</li>
                <!--not in endorsement docs
                <li><strong>L O 5.1.2</strong> Develop a correct program to solve problems. [P2]</li>
                <li><strong>L O 5.1.3</strong> Collaborate to develop a program. [P6]</li>
                <li><strong>L O 5.2.1</strong> Explain how programs implement algorithms. [P3]</li>
                <li><strong>L O 5.3.1</strong> Use abstraction to manage complexity in programs. [P3]</li>
                <li><strong>L O 5.5.1</strong> Employ appropriate mathematical and logical concepts in programming. [P1]</li>
                -->
            </ul>
            <h4>Essential Knowledge:</h4>
            <ul>
                <li><strong>EK 2.1.1A</strong> Digital data is represented by abstractions at different levels.</li>
                <li><strong>EK 2.2.1A</strong> The process of developing an abstraction involves removing detail and generalizing functionality.</li>
                <li><strong>EK 2.2.1B</strong> An abstraction extracts common features from specific examples in order to generalize concepts.</li>
                <li><strong>EK 2.2.1C</strong> An abstraction generalizes functionality with input parameters that allow software reuse.</li>
                <li><strong>EK 2.2.2A</strong> Software is developed using multiple levels of abstractions, such as constants, expressions, statements, procedures, and libraries.</li>
                <li><strong>EK 2.2.2B</strong> Being aware of and using multiple levels of abstraction in developing programs helps to more effectively apply available resources and tools to solve problems.</li>
                <li><strong>EK 2.2.3D</strong> In an abstraction hierarchy, higher levels of abstraction (the most general concepts) would be placed toward the top and lower level abstractions (the more specific concepts) toward the bottom.</li>
                <li><strong>EK 5.1.2G</strong> Program development includes identifying programmer and user concerns that affect the solution to problems.</li>
                <li><strong>EK 5.1.2J</strong> A programmer designs, implements, tests, debugs, and maintains programs when solving problems.</li>
                <li><strong>EK 5.1.3B</strong> Collaboration facilitates multiple perspectives in developing ideas for solving problems by programming.</li>
                <li><strong>EK 5.1.3F</strong> Effective communication between participants is required for successful collaboration when developing programs.</li>
                <li><strong>EK 5.2.1C</strong> Program instructions may involve variables that are initialized and updated, read, and written.</li>
                <li><strong>EK 5.2.1E</strong> Program execution automates processes.</li>
                <li><strong>EK 5.2.1J</strong> Simple algorithms can solve a large set of problems when automated.</li>
                <li><strong>EK 5.3.1I</strong> Strings and string operations, including concatenation and some form of substring, are common in many programs.</li>
                <li><strong>EK 5.3.1K</strong> Lists and list operations, such as add, remove, and search, are common in many programs.</li> 
                <li><strong>EK 5.3.1L</strong> Using lists and procedures as abstractions in programming can result in programs that are easier to develop and maintain.</li>
                <li><strong>EK 5.5.1H</strong> Computational methods may use lists and collections to solve problems.</li>
                <li><strong>EK 5.5.1J</strong> Basic operations on collections include adding elements, removing elements, iterating over all elements, and determining whether an element is in a collection.</li>
            </ul>
		</div>
        
        
	</body>
</html>
