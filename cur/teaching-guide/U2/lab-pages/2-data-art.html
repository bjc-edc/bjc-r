<!DOCTYPE html>
<html lang="en">
    <head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 2 Lab 2 Teacher Guide</title>
    </head>
    
    <body>
        <h2>Lab 2: Making Art by Using Data Structures</h2>
        <p>The <code>list</code> block is the basic building block of many  complex structures. Lists can contain anything: numbers, strings, other lists, even blocks. The objects <em>in</em> a list can be all of the same kind or of different kinds. A list can, for example, contain an apartment number and a list of people at that address. The tabular data we see in spreadsheets can be represented as a list of same-length lists, the smaller lists representing each row in the table, and the enclosing list representing the entire spreadsheet.</p>
        <p> The "ordered pair" of algebra, the (<em>x</em>, <em>y</em>) coordinates of a point on a plane, can be represented as a list of two numbers. Students will use a list of ordered pairs to draw a shape or plot a graph.</p>
        <p>
            <img class="indent" src="/bjc-r/img/3-lists/A.png" alt="set A to {{-50,20}, {-10,120}, {10,120}, {50,20}, {30,20}, {20,50}, {-20,50}, {-30,20}}" title="set A to {{-50,20}, {-10,120}, {10,120}, {50,20}, {30,20}, {20,50}, {-20,50}, {-30,20}}" />
            <img class="imageRight" src="/bjc-r/img/3-lists/drawA.gif" alt="sprite drawing letter A by going to each set of coordinates" title="sprite drawing letter A by going to each set of coordinates" />  
        </p>
        <p>In this lab, students also practice one kind of problem-decomposition, in the form of building a <em>simple</em> tool that solves a repetitive <em>part</em> of the problem, and then using it to solve the whole problem. </p>
        <p>
                On the first page of this lab, students are given a list of points, and they create a <code>go to point</code> block that moves the sprite to any <em>one point</em> given as input. <!--To select information in the dataset, we only need to know where it appears.--> Students can, for example, use <code>item (3) of </code> to access the third point, <var> {10, 120}</var>, and  use the code 
                <img class = "inline" src="/bjc-r/img/2-complexity/U2ImageVideoAddendum_img/go-to-point-item-3-of-A.png" height="45" alt="go-to-point-item-3-of-A" title="go-to-point-item-3-of-A"> 
                to move the sprite to that point. Having built a tool for getting to <em>one</em> point, students then use that tool and <em>automate</em> the process of getting to all the points, using  <code>for each</code>.
        </p>
		
        
        <p>
            <img class="inline" src="/bjc-r/img/3-lists/point()().png" alt="point () ()" title="point () ()" />block and use it to replace <!--<img src="/bjc-r/img/3-lists/coordinate-list-for-A.png" height="54" alt="coordinate-list-for-A">-->the list for the letter A shown above with the list shown below.<br />
            <img class="indent" src="/bjc-r/img/3-lists/point-list-for-A.png" height="82" alt="point-list-for-A">.
        </p>
        <p> The change seems trivial; everything works the same way (in fact,  <code>point</code> does exactly what <code>list</code> does, so the computer doesn't care which code is used). But the second version makes it easier for <em>humans</em> to write, read, and understand the code. Similarly, students also create <img class="inline" src="/bjc-r/img/3-lists/x-coordinate.png" alt="x coordinate of {}" title="x coordinate of {}" /> and <img class="inline" src="/bjc-r/img/3-lists/y-coordinate.png" alt="y coordinate of {}" title="y coordinate of {}" /> blocks to replace <code>item</code>, using abstraction again to clarify the <em>purpose</em> of the code and to distinguish it from the details. This process is called constructing an <strong>abstract data type</strong>â€”using <code>point</code> as a "constructor" to produce the (<em>x</em>, <em>y</em>) coordinate pair (a list) from two individual coordinates, and "selectors" <code>x coordinate of</code> and <code>y coordinate of</code>. </p>
        <p>On the third page, students analyze and complete partially written code to let the programmer collect and store points in a list by clicking on the stage to indicate which points they want. </p>
        <p>On the last page, students automate that process to collect the vertices of a polygon in order to make a mandala design.</p>
        <div class="sidenoteBig">Many of the <span class="snap">snap</span> projects linked from the student pages already have the tools imported.</div>
        <p>Students need to <img class="inline" src="/bjc-r/img/icons/import-tools.png" alt="Import Tools" title="Import Tools" /> each time they open a new <span class="snap">snap</span> window.</p>
        
        <h3>Pacing</h3>
        <div>
			The 3 required lab pages could be split across 2-4 days (<strong>75-150 minutes</strong>). Expected times to complete follow:
			<ul>
				<li>20-40 minutes (less than 1 class period) on <a href="/bjc-r/cur/programming/2-complexity/2-data-structures-art/1-the-for-each-block.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment">Processing Each Item in a List</a></li>
				<li>25-50 minutes (less than 1 class period) on <a href="/bjc-r/cur/programming/2-complexity/2-data-structures-art/2-data-types.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment">Abstract Data Types</a></li>
				<li>30-60 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/2-complexity/2-data-structures-art/3-click-points.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment">Capturing Clicks to Draw</a></li>
				<li>If used, 40-50 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/2-complexity/2-data-structures-art/4-mandala.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment">Mandala Design</a>*</li>
			</ul>
		</div>
        		
        
        <h3>Lab Pages</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Processing Each Item in a List.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
				                <li><strong>Problem decomposition: </strong>Solving a problem by building a useful part, and then using that.</li>
                                <li>Use the <code>for each</code> block to do something with each item in a list.</li>
                            	<li>(Minor) Learn how to specify the type of input that a block is expecting to receive.</li>
                            	
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                        		<li><strong>The dialog</strong> has some complicated ideas. Arrange so that students  can read it through more than once (perhaps, individually, in small groups, as a &quot;dramatic reading&quot;....) For out loud reading, students are often more comfortable if they've had a chance to prepare first, so you might invite three students, as they enter class, to prepare to be Alphie, Betsy, or Gamal for today.</li>
                                <!--<img class="imageRight" src="/bjc-r/img/2-complexity/new-for-each-point-script.png" alt="script with for each (item) of (A) {go to point (item)}" title="script with for each (item) of (A) {go to point (item)}" />-->
                                <img class="imageRight" src="/bjc-r/img/2-complexity/U2ImageVideoAddendum_img/gotopoint_fillinTheBlanks.png" height="100" alt="go to point fill in the blanks" title="go to point fill in the blanks"/>
                                <li><strong>Debugging: </strong>Have students first think about what goes in the two blanks inside the <code>go to point</code> script. Only after the letter is mostly being drawn correctly should they tackle the two bugs, one at the beginning and one at the end of the drawing process.</li>
                                
                                <li>Students who have programmed before in Scratch will be surprised about the use of lists (points) as inputs to a block, because Scratch doesn't allow that. You don't have to bring this up with the whole class, but if you get questions about it, you can just say that this is one of the ways that Snap<em>!</em> has extended Scratch.</li>
                                
								<li><strong>Specifying an input type</strong>: The information about is useful, but  not essential. Students may also find it faster and better to learn from you than by working through the page. Consider <em>demonstrating</em> with students  following along. </li>
								<li>Input types in Snap<em>!</em> are <em>program documentation,</em> not constraints on the programmer. You can drop any reporter into any input slot. The input slot shapes are just hints about what the block expects. Don't emphasize type checking. It's really important for a programmer to understand the domain and range of each function, but the domain (e.g., "an even positive integer" or "a word of no more than eight letters" or "a list whose items are either Booleans or lists") is often different from the language's types.</li>
                                <li><strong>Take It Further</strong>: Let students eyeball the three new points rather than worrying about precision. The goal here is to find a way to draw shapes that have disconnected parts, like the  A that has an inside triangle. Students might bundle the two separate parts (both lists of points) in a list-of-lists-of-points, or a might use a special pseudo-point that means &quot;pick the pen up before going to the next point.&quot; Some students might care to apply what they know about <em>slope</em> from algebra to identify the remaining points in the letter exactly and, for that matter, to correct the original list, which doesn't get it quite right!</li>
                                <li><strong>Mathematical Take-it-Further for interested students: Transforming Coordinates.</strong>  The list <strong>A</strong> contains the coordinates of the  points (<em>vertices</em>) that define the picture of the letter <em>A</em> in <em>that position</em> on the stage.  You can transform these coordinates to draw an exact replica of <em>A</em> in another spot on the stage. This can let you set two letters next to each other on the screen, or make a "shadow" of <em>A</em> or to draw an offset image to create a three-dimensional effect. Try creating a list <em>AA</em> from <em>A</em> by adding, say, 50 to each of the coordinates of each of the points and plotting the resulting points, with <code>for each</code>.</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					<strong>Page 2: Abstract Data Types.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
				                <li>Understand what a data type is (e.g., number, text, list) and what an abstract data type is.</li>
                                <li>Understand how abstract data types (ADT) make code more readable  and help organize and manage data; be able to <em>create</em> ADTs.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                            	<li>Again, consider having students think through the dialog more than once.</li>
		                        <li>
                                	Discussion: After  students have worked through the dialog (and perhaps also added the abstract data type to their U3L2-DrawShape project), you might review with questions like these:
                                      <ul>
                                        <li>What are some benefits of creating an abstract data type?</li>
                                        <li>What's a <em>primitive</em> data type? What are some examples?</li>
                                        <li>What's an <em>abstract</em> data type? What are some examples?
                                          <ul>
                                            <li>In particular, what data in Unit 1 projects could be treated as abstract data types?</li>
                                          </ul>
                                        </li>
                                        <li>What is the difference between a primitive data type and an abstract data type?</li>
                                    </ul>
                        		</li>
                                <li>"Abstract data type" (or ADT) sounds like a complicated thing, but programmers actually use them to simplify <em>and clarify</em> the logical structure of their code. It is a thing to help <em>people</em>, not <em>machines</em>. An abstract data type is like a "template" for data. For example, a registration form on which individuals write their name, address, and email in a particular place helps us know where to look for each part of the data. </li>
							</ul>
						</li>
					</ul>
                    <div class="narrower">
                    	<p>The table below compares the &quot;ordinary language&quot; use of <em>abstract</em> with the CS use. (It's not about data abstraction specifically, but the major levels of abstraction in computer science generally.) </p>
                        <p> In ordinary language, the actual physical computer is the "least abstract" thing, because you can hold it in your hand, push its buttons, maybe take it apart.  In ordinary language, programming seems to deal with "more abstract" ideas, things with no visible, tangible existence. In some ways, the physical thing might seem easiest to think about, and the programming at the top of the table harder.</p>
                    	<p>Computer scientists use "abstract" to mean something more like "this is defined in terms of that": application software is written in a high level language, which is itself implemented in a low level language.  It's <em>easier</em> to understand a language than to deal with all the detailsâ€”how the language is built from lower level languages, and how they work with the computer architecture, and how that's built of transistors, which depend on the behavior of electrons, and so on. From that perspective, things get harder as you move down the table.  It's easy to write a program in Snap<em>!</em>, harder to write one in C, because you have to think about more details of memory management.  It's easier to understand the design of a computer architecture (the Intel Core design, for example) than to understand the physical circuits that implement it.</p>
                        <table align="center" frame="box" rules="all">
                            <tr><th>Ordinary language</th><th>Levels of abstraction</th><th>Computer science</th></tr>
                            <tr>
                                <td>&nbsp;most abstract <small>(harder)</small></td><td>&nbsp;application software</td>
                                <td>&nbsp;most abstract <small>(easier)</small></td>
                            </tr>
                            <tr>
                                <td style="background-color:#000000">&nbsp;</td>
                                <td>&nbsp;high level language (Snap<em>!</em>)</td>
                                <td style="background-color:#e0e0e0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#404040">&nbsp;</td>
                                <td>&nbsp;low level language (C)</td>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#808080">&nbsp;</td>
                                <td>&nbsp;machine language</td>
                                <td style="background-color:#a0a0a0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                                <td>&nbsp;computer architecture</td>
                                <td style="background-color:#808080">&nbsp;</td>
                            </tr>
                            <tr>
                                <td>&nbsp;least abstract <small>(easier)</small></td>
                                <td>&nbsp;physical computer (chips, wires)&nbsp;</td>
                                <td style="background-color:#606060">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                                <td>&nbsp;transistors</td>
                                <td style="background-color:#404040">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#707070">&nbsp;</td>
                                <td>&nbsp;atoms</td>
                                <td style="background-color:#202020">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#000000">&nbsp;</td>
                                <td>&nbsp;protons, neutrons, electrons</td>
                                <td style="background-color:#000000">&nbsp;</td>
                            </tr>
                            <tr>
                                <td>&nbsp;most abstract <small>(harder)</small></td>
                                <td>&nbsp;quarks</td>
                                <td>&nbsp;least abstract <small>(harder)&nbsp;</small></td>
                            </tr>
                        </table>
					</div>
				</li>
                <li>
                	<strong>Page 3: Capturing Clicks to Draw.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Knowing how to get a program to add a point to a list. On this page, the user clicks on a point, and the program adds <em>that point</em> to the list. This  prepares students for page 4, a program generates a list of points  automatically.  </li>
								<li>The page also reinforces the idea of data abstraction. On page 2, students created an ADT and used it to rewrite a program they'd already written. It's hard to make that convincing, but here they are writing entirely new code that's much easier because of the <code>point</code> abstraction.</li>
								<li>(Minor) This page also introduces the primitive <code>stamp</code> to draw a picture of the sprite at its current location on the stage.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                                <li>Focus mainly on learning how to write code that collects points into a list. Fancy touches, such as visual details, are optional but not important.</li>
								<li>Students may initially think that <code>stamp</code> "didn't work"; you can't see the effect until the sprite moves away  because the picture looks exactly like the sprite and is in exactly the same place. </li>
								<li>The following hints apply, not to the version in the main curriculum, but to the alternate version suggested in the Take It Further section:
								  <ul style="color:#404040">
								    <li><strong>The following is a problem only in spring 2017 during some teacher workshops; it will be fixed before students see this page. </strong>There is a Snap<em>!</em> bug that prevents saving to the cloud a project with a name made of non-ASCII characters, such as the script letters in the <img src="/bjc-r/img/2-complexity/stuff-here.png" alt="stuff here"> block. There are two workarounds: (1) replace the script words with plain letters; (2) use "export project" instead This will be an issue only until the page has been finished, at which point the <code>you write</code> block should no longer be used anywhere and can be deleted.</li>
								    <li>Some students may object to making <code>list of points</code> a reporter, because the shape is already drawn when it finishes running -- why do we need to keep the list of point? Remind them that they might want to draw a letter <em>more than once,</em> as part of a message, for example.</li>
								    <li>Experienced Scratch programmers, who have seen primitive reporters but have not been able to write their own before, may note that the primitive reporters don't <em>do</em> anything visible, but instead <em>only</em> report a value. <code>List of blocks</code> carries on an interaction and draws on the stage before finally reporting a value. They may find this surprising, but it's not a problem or breaking a rule.</li>
							      </ul>
								</li>
                            </ul>
						</li>
					</ul>
                </li>
				<li>
					<strong>Page 4: Mandala Design.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Apply everything learned in this lab in an artistic context.</li>
                                <li>Gain experience in breaking a somewhat large and difficult task into smaller manageable parts.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
								<li>This page relies on the successful mastery of lists of points, as developed in the previous three pages.</li>
								<li>It may be helpful for students to hand draw a five-sided version of the Mandala to get a feel how the algorithm might work.</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
</div>


        <h3>Solutions</h3>
        <div>
            <ul>
                
                <li><a href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p1DrawShape%20(answer%20file)" target="_blank">Page 1: Processing Each Item in a List</a></li>
                <li><a href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p2DataTypes%20(answer%20file)" target="_blank">Page 2: Abstract Data Types</a></li>
             
                <li><a href="http://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p3ClickToDraw" target="_blank">Page 3: Capturing Clicks To Draw</a></li>
                <li><a href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=bjcsolutions&ProjectName=U2L2p4Mandala%20(answer%20file)" target="_blank">Page 4: Mandala Design</a></li>
            </ul>
        </div>	
        					
		
        <h3>Correlation with AP CS Principles Framework</h3>
		<div class="apStandards">
			<!--<h4>Computational Thinking Practices:</h4>
			<ul>
                <li><strong>P2 Creating Computational Artifacts</strong> Create an artifact with a practical, personal, or societal intent.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Select appropriate techniques to develop a computational artifact.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Use appropriate algorithmic and information management principles.</li>
                <li><strong>P3 Abstracting</strong> Explain how data, information, or knowledge is represented for computational use.</li>
                <li><strong>P3 Abstracting</strong> Explain how abstractions are used in computation or modeling.</li>
                <li><strong>P3 Abstracting</strong> Identify abstractions.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Evaluate a proposed solution to a problem.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Locate and correct errors.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Explain how an artifact functions.</li>
                <li><strong>P4 Analyzing Problems and Artifacts</strong> Justify appropriateness and correctness of a solution, model, or artifact.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in solving a computational problem.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in producing an artifact.</li>
                <li><strong>P6 Collaborating</strong> Share the workload by providing individual contributions to an overall collaborative effort.</li>
                <li><strong>P6 Collaborating</strong> Foster a constructive, collaborative climate by resolving conflicts and facilitating the contributions of a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Exchange knowledge and feedback with a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Review and revise their work as needed to create a high-quality artifact.</li>
			</ul>-->
			<h4>Enduring Understandings:</h4>
            <ul>
                <li><strong>EU 2.2</strong> Multiple levels of abstraction are used to write programs or create other computational artifacts.</li>
                <!--not in endorsement docs
                <li><strong>E U 5.1</strong> Programs can be developed for creative expression, to satisfy personal curiosity, to create new knowledge, or to solve problems (to help people, organizations, or society).</li>
                <li><strong>E U 5.2</strong> People write programs to execute algorithms.</li>
                <li><strong>E U 5.3</strong> Programming is facilitated by appropriate abstractions.</li>
                <li><strong>E U 5.5</strong> Programming uses mathematical and logical concepts.</li>
                -->
            </ul>
			<h4>Learning Objectives:</h4>
            <ul>
                <!--not in endorsement docs
                <li><strong>L O 1.2.2</strong> Create a computational artifact using computing tools and techniques to solve a problem. [P2]</li>
				<li><strong>L O 2.1.1</strong> Describe the variety of abstractions used to represent data. [P3]</li>
                -->
                <li><strong>LO 2.2.1</strong> Develop an abstraction when writing a program or creating other computational artifacts. [P2]</li>
                <li><strong>LO 2.2.2</strong> Use multiple levels of abstraction to write programs. [P3]</li>
                <li><strong>LO 2.2.3</strong> Identify multiple levels of abstractions that are used when writing programs. [P3]</li>
                <!--not in endorsement docs
                <li><strong>L O 5.1.2</strong> Develop a correct program to solve problems. [P2]</li>
                <li><strong>L O 5.1.3</strong> Collaborate to develop a program. [P6]</li>
                <li><strong>L O 5.2.1</strong> Explain how programs implement algorithms. [P3]</li>
                <li><strong>L O 5.3.1</strong> Use abstraction to manage complexity in programs. [P3]</li>
                <li><strong>L O 5.5.1</strong> Employ appropriate mathematical and logical concepts in programming. [P1]</li>
                -->
            </ul>
            <h4>Essential Knowledge:</h4>
            <ul>
                <li><strong>EK 2.1.1A</strong> Digital data is represented by abstractions at different levels.</li>
                <li><strong>EK 2.2.1A</strong> The process of developing an abstraction involves removing detail and generalizing functionality.</li>
                <li><strong>EK 2.2.1B</strong> An abstraction extracts common features from specific examples in order to generalize concepts.</li>
                <li><strong>EK 2.2.1C</strong> An abstraction generalizes functionality with input parameters that allow software reuse.</li>
                <li><strong>EK 2.2.2A</strong> Software is developed using multiple levels of abstractions, such as constants, expressions, statements, procedures, and libraries.</li>
                <li><strong>EK 2.2.2B</strong> Being aware of and using multiple levels of abstraction in developing programs helps to more effectively apply available resources and tools to solve problems.</li>
                <li><strong>EK 2.2.3D</strong> In an abstraction hierarchy, higher levels of abstraction (the most general concepts) would be placed toward the top and lower level abstractions (the more specific concepts) toward the bottom.</li>
                <li><strong>EK 5.1.2G</strong> Program development includes identifying programmer and user concerns that affect the solution to problems.</li>
                <li><strong>EK 5.1.2J</strong> A programmer designs, implements, tests, debugs, and maintains programs when solving problems.</li>
                <li><strong>EK 5.1.3B</strong> Collaboration facilitates multiple perspectives in developing ideas for solving problems by programming.</li>
                <li><strong>EK 5.1.3F</strong> Effective communication between participants is required for successful collaboration when developing programs.</li>
                <li><strong>EK 5.2.1C</strong> Program instructions may involve variables that are initialized and updated, read, and written.</li>
                <li><strong>EK 5.2.1E</strong> Program execution automates processes.</li>
                <li><strong>EK 5.2.1J</strong> Simple algorithms can solve a large set of problems when automated.</li>
                <li><strong>EK 5.3.1I</strong> Strings and string operations, including concatenation and some form of substring, are common in many programs.</li>
                <li><strong>EK 5.3.1K</strong> Lists and list operations, such as add, remove, and search, are common in many programs.</li> 
                <li><strong>EK 5.3.1L</strong> Using lists and procedures as abstractions in programming can result in programs that are easier to develop and maintain.</li>
                <li><strong>EK 5.5.1H</strong> Computational methods may use lists and collections to solve problems.</li>
                <li><strong>EK 5.5.1J</strong> Basic operations on collections include adding elements, removing elements, iterating over all elements, and determining whether an element is in a collection.</li>
            </ul>
		</div>
        
        
	</body>
</html>
