<!DOCTYPE html>
<html lang="en">
    <head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 2 Lab 1 Teacher Guide</title>
		<script type="text/javascript" src="/bjc-r/utilities/gifffer.min.js"></script>
        <script type="text/javascript">window.onload = function() {Gifffer();}</script>
        <link rel="stylesheet" type="text/css" href="/bjc-r/css/bjc-gifffer.css">
    </head>
    
    <body>
        <h2>Lab 2: Making Lists</h2>
		<p>Students have touched on lists in Unit 1, but this lab is where we really dive into them. First, in the very simple shopping list app, students learn list creation and mutation. Then, in the quiz program, we introduce the very important idea of <em>data abstraction, </em>specifying a constructor and two selectors for the <code>quiz item</code> data type.</p>
        <div class="takeNote">Data abstraction is a key idea in computer science.  Many languages provide a special syntax for abstract data types, so you might say something like<br />
<pre>class QuizItem {
   field question;
   field answer;
}</pre>
(That's not any particular language, just a stripped-down syntax to make the point.)  But in Snap<em>!</em> we use procedures instead: the constructor <img src="/bjc-r/img/2-complexity/quiz-item-constructor.png" alt="quiz item, question: ( ) answer: ( )"> to define the type, and selectors <img src="/bjc-r/img/2-complexity/question-selector.png" alt="question from quiz item ( )"> and <img src="/bjc-r/img/2-complexity/answer-selector.png" alt="answer from quiz item ( )"> to retrieve the fields of the object.  By using ordinary procedures to implement the abstract type, we show that there's no magic involved.</div>
		<p>But what we <em>don't</em> do in this lab is to introduce the higher order functions that will be our main tools for list processing later in the course. We hint at them in the third page by using <code>for each item</code>, which is a higher order procedure but not a function, and therefore doesn't require the gray ring notation that will be introduced in the next lab.</p>
        
                
        <h3>Pacing</h3>
		<div>
			The 3 lab pages could be split across 3-5 days (<strong>105-210 minutes</strong>). Expected times to complete follow:
			  <ul>
				<li>15-30 minutes (&lt; 1 class period) on Shopping List App</li>
				<li>20-40 minutes (&lt; 1 class period) on Planning a Quiz App</li>
				<li>30-60 minutes (about 1 class period) on Checking Each Quiz Answer</li>
			</ul>
		</div>
        
        <h3>Lab Pages</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Shopping List App.</strong>
							<ul>
							  <li><strong>Learning Goals:</strong>
							    <ul>
							      <li>Construct a list, add items to it.</li>
							      <li>The <em>empty list</em> is different from a list with an empty item, and is the right starting point when building a list one item at a time.</li>
							      <li>The <code>when I am clicked</code> block allows a sprite to be used as a button.</li>
						        </ul>
							    </li>
 						    </ul>
				</li>
                <li>
					<strong>Page 2: Planning a Quiz App.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
                                <li>An abstract data type consists of a <em>constructor</em> procedure and one or more <em>selector</em> procedures.</li>
                    			<li>Plan and build an abstract data type.</li>
                   			</ul>
						</li>
						<li><strong>Tips:</strong>
						  <ul>
						    <li>This page has more reading, and less doing, than most. To make it look less intimidating, we have hidden much of the reading behind &quot;hint&quot; links. Exercise 2 asks students to read the text, clicking links one at a time to look at and then re-hide each code picture. This is the only place where we've used the &quot;hinting&quot; mechanism on things we want every student to read; it's an experiment.</li>
						    <li>After the text comes a long vocabulary box that defines six terms. It starts with the most concrete terms, the ones that name procedures you can point to. Then comes the notion of a data type, and the distinction between <em>primitive</em> types built into the language and <em>abstract</em> types that are specific to one application, rather than a general feature of the programming language. At the end, <em>data abstraction</em> itself is defined as the use of abstract data types.</li>
					      </ul>
						</li>
					</ul>
				</li>
                                    <div class="narrower">
                    	<p>The table below compares the &quot;ordinary language&quot; use of <em>abstract</em> with the CS use. (It's not about data abstraction specifically, but the major levels of abstraction in computer science generally.) </p>
                        <p> In ordinary language, the actual physical computer is the "least abstract" thing, because you can hold it in your hand, push its buttons, maybe take it apart.  In ordinary language, programming seems to deal with "more abstract" ideas, things with no visible, tangible existence. In some ways, the physical thing might seem easiest to think about, and the programming at the top of the table harder.</p>
                    	<p>Computer scientists use "abstract" to mean something more like "this is defined in terms of that": application software is written in a high level language, which is itself implemented in a low level language.  It's <em>easier</em> to understand a language than to deal with all the detailsâ€”how the language is built from lower level languages, and how they work with the computer architecture, and how that's built of transistors, which depend on the behavior of electrons, and so on. From that perspective, things get harder as you move down the table.  It's easy to write a program in Snap<em>!</em>, harder to write one in C, because you have to think about more details of memory management.  It's easier to understand the design of a computer architecture (the Intel Core design, for example) than to understand the physical circuits that implement it.</p>
                        <table align="center" frame="box" rules="all">
                            <tr><th>Ordinary language</th><th>Levels of abstraction</th><th>Computer science</th></tr>
                            <tr>
                                <td>&nbsp;most abstract <small>(harder)</small></td><td>&nbsp;application software</td>
                                <td>&nbsp;most abstract <small>(easier)</small></td>
                            </tr>
                            <tr>
                                <td style="background-color:#000000">&nbsp;</td>
                                <td>&nbsp;high level language (Snap<em>!</em>)</td>
                                <td style="background-color:#e0e0e0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#404040">&nbsp;</td>
                                <td>&nbsp;low level language (C)</td>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#808080">&nbsp;</td>
                                <td>&nbsp;machine language</td>
                                <td style="background-color:#a0a0a0">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                                <td>&nbsp;computer architecture</td>
                                <td style="background-color:#808080">&nbsp;</td>
                            </tr>
                            <tr>
                                <td>&nbsp;least abstract <small>(easier)</small></td>
                                <td>&nbsp;physical computer (chips, wires)&nbsp;</td>
                                <td style="background-color:#606060">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#c0c0c0">&nbsp;</td>
                                <td>&nbsp;transistors</td>
                                <td style="background-color:#404040">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#707070">&nbsp;</td>
                                <td>&nbsp;atoms</td>
                                <td style="background-color:#202020">&nbsp;</td>
                            </tr>
                            <tr>
                                <td style="background-color:#000000">&nbsp;</td>
                                <td>&nbsp;protons, neutrons, electrons</td>
                                <td style="background-color:#000000">&nbsp;</td>
                            </tr>
                            <tr>
                                <td>&nbsp;most abstract <small>(harder)</small></td>
                                <td>&nbsp;quarks</td>
                                <td>&nbsp;least abstract <small>(harder)&nbsp;</small></td>
                            </tr>
                        </table>
					</div>

                <li>
					<strong>Page 3: Checking Each Quiz Answer.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Traverse the items of a list.</li>
                                <li>Understand and use the abstraction of the <code>for each item</code> block, which hides the use of index numbers to access each item. The programmer can just write the code to handle one item, and the block takes care of supplying items one at a time.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                                <li>A very common beginner's bug is to mistrust the <code>for each item</code> block and try to do the traversal in the script in the C-shaped slot.</li>
                                <li>Another common bug is to think that the <code>item</code> variable provided by the block contains an index (an item <em>number</em>), whereas it actually contains the item itself.</li>
							</ul>
						</li>
					</ul>
                </li>
			</ul>
		</div>
    </body>
</html>
