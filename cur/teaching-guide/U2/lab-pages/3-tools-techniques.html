<!DOCTYPE html>
<html lang="en">
    <head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 2 Teacher Guide</title>
    </head>
    
    <body>
        <h2>Programming Lab 3: Tools and Techniques</h2>
        <p>The lab contains four short activities&mdash;essentially how-to's&mdash;showing techniques that are useful in more complex programming tasks. Students get a bit more experience with Boolean expressions, essential for the AP CSP test. They learn how to indicate the intended <em>type</em> of an input to a block&mdash;whether the intended input is to be a number, a string, a list, or something else. They get a bit more practice creating reporter blocks that take multiple inputs, and they use a composition of functions on those inputs. And they compare multiple <em>correct</em> ways of solving a problem, thinking about the esthetics of programming.</p>
        
        
        <h3>Pacing:</h3>
        <div>
			The 4 lab pages could be split across 2-4 days (80-160 minutes). Expected times to complete follow:
			<ul>
				<li>20-40 minutes (1 class period or less) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/3-tools-techniques/1-predicates-logic.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Predicates and Logic</a></li>
				<li>20-40 minutes (1 class period or less) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/3-tools-techniques/2-input-types.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Input Types</a></li>
				<li>20-40 minutes (1 class period or less) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/3-tools-techniques/3-analyzing-definitions-of-ge.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Analyzing Various Definitions of <code>&gt;=</code></a></li>
				<li>20-40 minutes (1 class period or less) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/3-tools-techniques/4-composition-of-functions.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Composition of Functions</a></li>
			</ul>
		</div>
        <div class="time">
        	<ul>
                <li>Composition of Functions</li>
                <li>Analyzing Various Definitions of &gt;=</li>
            </ul>
        </div>

    	<h3>Students will:</h3>
        <!--<div class="sidenoteBig">
        	<strong>Looking Ahead</strong>
        	<ul>
            	<!-- Used in U1 
                <li>The tools developed in this unit anticipate a variety of games that students will be able to develop: tic-tac-toe, magic-square games, and others. More powerful programming techniques&mdash;particularly <strong>lists</strong> which are the major new programming idea in Unit 3&mdash;are useful in completing these games.</li>- ->
            </ul>
        </div>-->
        <div>
            <ul>
                <li>Broaden and refine their understanding of the mathematics of computer science including basic arithmetic operations, the <code>round</code> block, the <code>mod</code> block, the <code>random</code> block, and logical operators.</li>
                <li>Learn how to specify the type of input that a block is expecting to receive.</li>
                <li>Get practice composing functions.</li>
            </ul>
		</div>
        
        <h3>Tips:</h3>
        <div>
        	<ul>
            	<li>
					<strong>Page 1: Predicates and Logic.</strong>
					<ul>
						<li>
                        	Some <strong>vocabulary</strong> (for <em>you</em> to use in context,  not to require of students):
                            <ul>
                                <li>A <em>command</em> is a single Lego-brick-shaped block, without its inputs.</li>
                                <li>A <em>reporter</em> is a single oval-shaped block, without its inputs.</li>
                                <li>A <em>predicate</em> is a single hexagonal block, without its inputs.</li>
                                <li>An <em>instruction</em> is a command block along with its inputs or input expressions.</li>
                                <li>An <em>expression</em> is a reporter block along with its inputs or input expressions.</li>
                                <li>A <em>Boolean expression</em> is a predicate block along with its inputs or input expressions.</li>
                                <li>A <em>Boolean value</em> is <img src="/bjc-r/img/blocks/true.png" alt="true"> or <img src="/bjc-r/img/blocks/false.png" alt="false">. (Not the text strings "true" and "false"; not 0 and 1.)</li>
                            </ul>
                            So a reporter or a predicate is a function; an expression is a function applied to input values (often called &quot;arguments&quot;).</li>
					</ul>
				</li>
                <li>
					<strong>Page 2: Input Types.</strong>
					<ul>
						<li>The information on this page&mdash;how to constrain a block's inputs  to expect only numbers&mdash;is useful but not essential. Consider <em>demonstrating</em> the method yourself, and having students watch you and follow along. They may find learning from you faster and better than  working through the page.</li>
						<li>Input types in Snap<em>!</em> are <em>program documentation,</em> not constraints on the programmer. You can drop any reporter into any input slot. The input slot shapes are just hints about what the block expects. Don't emphasize type checking. It's really important for a programmer to understand the domain and range of each function, but the domain (e.g., "an even positive integer" or "a word of no more than eight letters" or "a list whose items are either Booleans or lists") is often different from the language's types.</li>
					</ul>
				</li>
                <li>
					<strong>Page 3: Analyzing Various Definitions of <code>&gt;=</code>.</strong>
					<ul>
						<li>The main point  is for students to see that there are multiple correct ways of programming and that there are different standards for elegance and clarity. This page also helps clarify the Boolean operators. The third and fourth definition resemble the way we might explain the <code>&gt;=</code> function in English. By contrast, the versions using <code>if</code> are not much like the way we'd think  in a non-programming context. Because this page requires no programming&mdash;it is entirely discussion&mdash;you may want to do this right after showing <strong>Input types</strong>, while the whole class is working together.</li>
					</ul>
				</li>
                <li>
					<strong>Page 4: Composition of Functions.</strong>
					<ul>
						<li>This extremely short page is very useful practice both in problem solving and in programming. It also foreshadows the way associative operators can be composed by the <code>combine</code> function in Unit 3.</li>
					</ul>
				</li>
            </ul>
	</div>

            
        <!--<h3>Solutions</h3>
        <div><ul><li>...</li></ul></div>-->
            
            
        <div class="apStandards">
            <!--<h4>AP CS Principles Computational Thinking Practices:</h4>
            <ul>
                <li>Coming soon...</li>
            </ul>-->
            <h4>Enduring Understandings:</h4>
            <ul>
                <li><strong>EU 1.1</strong> Creative development can be an essential process for creating computational artifacts.</li>
                <li><strong>EU 2.2</strong> Multiple levels of abstraction are used to write programs or create other computational artifacts.</li>
                <li><strong>EU 5.3</strong> Programming is facilitated by appropriate abstractions.</li>
                <li><strong>EU 5.5</strong> Programming uses mathematical and logical concepts.</li>
            </ul>
            <h4>Learning Objectives:</h4>
            <ul>
                <li><strong>LO 1.1.1</strong> Apply a creative development process when creating computational artifacts. [P2]</li>
                <!--not in endorsement docs
                <li><strong>LO 2.2.1</strong> Develop an abstraction when writing a program or creating other computational artifacts. [P2]</li>
                -->
                <li><strong>LO 2.2.2</strong> Use multiple levels of abstraction to write programs. [P3]</li>
                <!--not in endorsement docs
                <li><strong>LO 4.1.1</strong> Develop an algorithm for implementation in a program. [P2]</li>
                <li><strong>LO 5.3.1</strong> Use abstraction to manage complexity in programs. [P3]</li>
                <li><strong>LO 5.4.1</strong> Evaluate the correctness of a program. [P4]</li>
                -->
                <li><strong>LO 5.5.1</strong> Employ appropriate mathematical and logical concepts in programming. [P1]</li>
            </ul>
            <h4>Essential Knowledge:</h4>
            <ul>
                <li><strong>EK 2.2.1A</strong> The process of developing an abstraction involves removing detail and generalizing functionality.</li>
                <li><strong>EK 2.2.1B</strong> An abstraction extracts common features from specific examples in order to generalize concepts.</li>
                <li><strong>EK 2.2.1C</strong> An abstraction generalizes functionality with input parameters that allow software reuse.</li>
                <li><strong>EK 2.2.2A</strong> Software is developed using multiple levels of abstractions, such as constants, expressions, statements, procedures, and libraries.</li>
                <li><strong>EK 4.1.1C</strong> Selection uses a Boolean condition to determine which of two parts of an algorithm is used.</li>
                <li><strong>EK 4.1.1D</strong> Iteration is the repetition of part of an algorithm until a condition is met or for a specified number of times.</li>
                <li><strong>EK 4.1.1E</strong> Algorithms can be combined to make new algorithms.</li>
                <li><strong>EK 4.1.1F</strong> Using existing correct algorithms as building blocks for constructing a new algorithm helps ensure the new algorithm is correct.</li>
                <li><strong>EK 4.1.1H</strong> Different algorithms can be developed to solve the same problem.</li>
                <li><strong>EK 5.1.2A</strong> An iterative process of program development helps in developing a correct program to solve problems.</li>
                <li><strong>EK 5.1.2B</strong> Developing correct program components and then combining them helps in creating correct programs.</li>
                <li><strong>EK 5.1.2C</strong> Incrementally adding tested program segments to correct working programs helps create large correct programs.</li>
                <li><strong>EK 5.1.3A</strong> Collaboration can decrease the size and complexity of tasks required of individual programmers.</li>
                <li><strong>EK 5.1.3B</strong> Collaboration facilitates multiple perspectives in developing ideas for solving problems by programming.</li>
                <li><strong>EK 5.1.3D</strong> Collaboration can make it easier to find and correct errors when developing programs.</li>
                <li><strong>EK 5.1.3E</strong> Collaboration facilitates developing program components independently.</li>
                <li><strong>EK 5.3.1A</strong> Procedures are reusable programming abstractions.</li>
                <li><strong>EK 5.3.1B</strong> A procedure is a named grouping of programming instructions.</li>
                <li><strong>EK 5.3.1C</strong> Procedures reduce the complexity of writing and maintaining programs.</li>
                <li><strong>EK 5.3.1D</strong> Procedures have names and may have parameters and return values.</li>
                <li><strong>EK 5.3.1E</strong> Parameterization can generalize a specific solution.</li>
                <li><strong>EK 5.3.1F</strong> Parameters generalize a solution by allowing a procedure to be used instead of duplicated code.</li>
                <li><strong>EK 5.3.1G</strong> Parameters provide different values as input to procedures when they are called in a program.</li>
                <li><strong>EK 5.4.1B</strong> Duplicated code can make it harder to reason about a program.</li>
                <li><strong>EK 5.4.1C</strong> Meaningful names for variables and procedures help people better understand programs.</li>
                <li><strong>EK 5.4.1D</strong> Longer code blocks are harder to reason about than shorter code blocks in a program.</li>
                <li><strong>EK 5.4.1E</strong> Locating and correcting errors in a program is called debugging the program.</li>
                <li><strong>EK 5.4.1F</strong> Knowledge of what a program is supposed to do is required in order to find most program errors.</li>
                <li><strong>EK 5.5.1A</strong> Numbers and numerical concepts are fundamental to programming.</li>
                <li><strong>EK 5.5.1D</strong> Mathematical expressions using arithmetic operators are part of most programming languages.</li>
                <li><strong>EK 5.5.1E</strong> Logical concepts and Boolean algebra are fundamental to programming.</li>
                <li><strong>EK 5.5.1F</strong> Compound expressions using <em>and</em>, <em>or</em>, and <em>not</em> are part of most programming languages.</li>
            </ul>
        </div>            


	</body>
</html>
