<!DOCTYPE html>
<html lang="en">
    <head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unit 2 Teacher Guide</title>
    </head>
    
    <body>
        <h2>Programming Lab 1: Conditional Blocks</h2>
        <div class="todo">
            <ul>
                <li>GH Feedback 9/8/15: Looking specifically at the Introducing conditionals yellow box...those examples are a bit confusing.If you touch "here" do one thing else do something else - do you mean if the user touches anywhere else only one something else happens? That doesn't make sense and students will be confused. The ATM example is fine because you don't introduce else, but that is problematic. A better example might be checking a password or ATM pin number - if the password matches then let the person in else ask them to enter it again. That analogy is extensible to else if that checks to see the number of times the password has been entered, etc.</li>
                <li>We need to write tips for using the Thinking Out Loud dialog. --MF</li>
            </ul>
        </div>
        <p>This lab introduces two small and extensible projects programming the computer to produce parts of English phrases: a block that can decide which of "a" or "an" to use with the following noun and a block that spells the correct plurals of input nouns. Both of these projects require <strong>conditionals</strong> (students focus on <code>if else</code> and <code>if</code>) using <strong>predicates</strong> (blocks that report <code>true</code> or <code>false</code> based on tests they perform) to control the behavior of their programs. Students use built-in predicates such as <code>&lt;</code> and <code>=</code>, and they learn to build their own special purpose predicates, like <code>vowel?</code>, which reports <code>true</code> if its input letter is a vowel and <code>false</code> if it is not. Students also use conditionals to control action based on the results of predicates that test the <var>direction</var> and <var>y position</var> of the sprite.</p>
        <div class="endnote"><strong>One way to introduce the idea of conditionals to your students.</strong> When you go to an ATM machine, you touch buttons on its screen to indicate whether you want to deposit or withdraw. Hereâ€™s how it "knows" what you want. Someone wrote a program that places those words&mdash;deposit and withdraw&mdash;somewhere on the screen. The program then <em>tests</em> to determine where you touch the screen or which button you press. The action the program takes next is conditional; it depends on what input you've given it with your touch. Another part of the program may test the size of the withdrawal you request and indicate if that is too large or not an amount it can give, or it may deliver that amount. Your smart phone's screen works a similar way. The program knows only where you touch, but because it also knows what word or picture it put in that location, it can "know what you want"&mdash;<code>if</code> you touch <em>here</em>, do one thing, <code>else</code> do something else. Distinguishing conditions and basing action on the distinction is central to all programming.</div>
        <p>Small projects focus especially on using multiple <code>if</code> statements to distinguish multiple conditions. Students design a program that tests to see whether "red," "yellow," or "green" has been typed, and sets a traffic signal to that color; they design another program to decide when to add <em>s</em> and when to add <em>es</em> to make the plural of a noun.</p>
		<p>This lab also re-emphasizes <strong>abstraction</strong>. Students <strong>analyze</strong> the complex task of correctly spelling plurals by breaking it into subtasks and creating blocks that specialize in these subtasks. They also practice reading and analyzing scripts they have not created, one particularly powerful way to learn to program similar behaviors. Debugging is an essential skill&mdash;especially as one's programs become more complex&mdash;but it takes time to acquire and hone that skill because there is no single formula or sub-skill for doing it well. This lab also begins to draw explicit attention to one aspect of debugging: deliberately trying to "break" a program, searching for ways that a user's input (or some other situation that arises) can cause a program to fail and accounting for those ways by testing for them and responding appropriately.</p>

		<h3>Pacing:</h3>
		<div>
			The 6 lab pages could be split across 6 to 11 days (225-450 minutes). Estimated times for each page follow:
			  <ul>
				<li>40-80 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/1-conditionals/1-getting-started-with-conditionals.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">More Work with <code>If Else</code></a></li>
				<li>40-80 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/1-conditionals/2-creating-predicates.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Creating and Using Predicates</a></li>
				<li>25-50 minutes (around 1 class period) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/1-conditionals/3-first-list-experience.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Using Lists to Write <code>Vowel?</code></a></li>
				<li>40-80 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/1-conditionals/4-multiple-ifs.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Using Multiple <code>If</code> Statements</a></li>
				<li>40-80 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/1-conditionals/5-plurals1.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Developing a Block That Makes Plurals</a></li>
				<li>40-80 minutes (1-2 class periods) on <a href="/bjc-r/cur/programming/2-conditionals-abstraction-testing/1-conditionals/6-plurals2.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc_2015-2016.html&novideo&noassignment">Plurals, Continued</a></li>
			</ul>
</div>
			
        <!-- from Y1
        <div>
            <ul>
                <li> This week contains two labs. Though they differ in page length, each will probably take roughly half the time you have available. </li>
                <li> The goal is for students to learn and succeed, not rush, and to have chances to  try some of the Take It Further problems and to be creative on their own. Plan accordingly, but... </li>
                <li>...if you notice that the first two pages of Lab 1 are taking longer than you had anticipated, consider doing <em>only</em> problems 1-3 on page 3 (Using Multiple <code>If</code> Statements) and skipping the rest of that page (problems 4 through 7).  There will be many other opportunities to work with multiple <code>if</code>s.</li>
            </ul>
        </div>
        <div class="time">
        	<ul>
                <li>Lab 1 page 5: Plurals, Continued</li>
            </ul>
        </div>-->

    	<h3>Prepare:</h3>
        <div>
        	<ul>
                <li>Prepare several <a href="/bjc-r/cur/teaching-guide/U1/general-support/computing-in-the-news.html?topic=nyc_bjc%2F1-teaching-guide.topic&course=bjc4nyc_2015-2016_teacher.html&novideo&noassignment">Computing in the News</a> stories.</li>
            </ul>
        </div>
        
        <h3>As a Class:</h3>
        <div>
            <ul>
                <li>
                	To launch Lab 1 &mdash; <strong>Make a Prediction</strong>: Project these scripts and ask students to describe what they will do. Discuss in small groups and/or as a class. Students have seen similar things.<br />
                <a href="/bjc-r/img/1-introduction/follow-that-mouse.png" target="_blank"><img class="indent" src="/bjc-r/img/1-introduction/follow-that-mouse.png" alt="Follow That Mouse Script"/></a> and <a href="/bjc-r/img/2-conditionals-abstraction-testing/repeat-until-direction-equals-90-move-1-turn-cw-1.png" target="_blank"><img src="/bjc-r/img/2-conditionals-abstraction-testing/repeat-until-direction-equals-90-move-1-turn-cw-1.png" alt="repeat-until-direction-equals-90-move-1-turn-clockwise-1"></a>
                </li>
            </ul>
        </div>
        
        <h3>Students will:</h3>
        <div class="sidenoteBig">
        	<strong>Looking Ahead</strong>
        	<ul>
        		<li>Several pages preview lists and list blocks. Students will study lists in depth in Unit 3.</li>
        		<li>The Take-It-Further on the last page of this lab, <em>Plurals, continued</em>, foreshadows recursion, a powerful idea that students will study in Unit 6. Students develop  <code>plural</code> to spell the plural of an English noun, creating separate blocks for various special cases (nouns ending with s, x, h, y, and so on) and otherwise just appending <strong>s</strong>. Then they <em>fix</em> <code>plural</code> to handle a "word ending with a space" and use <code>plural</code>, itself, as the specialist to handle the word after that space has been removed. It may surprise them to see that this solution works even with "words" that end with many spaces.</li>
        	</ul>
        </div>
        <div>
            <ul>
                <li>Analyze <em>scripts</em> to understand how they work and to learn to use those methods for their own scripts.</li>
                <li>Develop <strong>predicates</strong> to test for various <strong>conditions</strong> and use <strong>conditional blocks</strong> to control programs based on those conditions.</li>
                <li>Analyze <em>tasks</em> to find subtasks that can be handled independently, develop blocks that specialize in each of the subtasks, and use conditionals to determine which of these specialist blocks to use.</li>
                <li>Use <strong>abstraction</strong> to simplify and clarify code.</li>
                <li><strong>Debug</strong> code by deliberately trying to find ways to "break" it.</li>
            </ul>
		</div> 
              
        <h3>Tips:</h3>
        <div>
            <ul>
                <li>
					<strong>Page 1: More Work with <code>If Else</code>.</strong>
					<ul>
						<li>This page involves some pure experimentation (students use code to see what it does) and some puzzles. Some of the puzzles are hard. Let students know that if they've done the experiments, the playing around, they have most of the knowledge they need for the puzzles. But puzzles are puzzling! Try, tinker, try something new, talk to your partner. And if you still can't solve the puzzle yourself, that's ok. Talk to another group.</li>
						<li>Make sure that students don't skip over the "<em>figure out how it works</em>" part of problem 1.  The figuring out helps students do problems 2 and 3. It's probably not necessary to do anything formal with that "figure out" part&mdash;talking with the pair programmer is likely to be enough&mdash;but if you feel your students need  more structure, you might prepare a paper copy of the scripts for students to annotate, or some other way to make the results of problem 1 more tangible than discussion.</li>
					</ul>
				</li>
				<li>
					<strong>Page 2: Creating and Using Predicates.</strong>
					<ul>
						<li>Problem 1 uses a video to show how to create the <code>even?</code> block. You may prefer to demonstrate on a projector, have your students  watch you  and copy what you do in <span class="snap">snap</span>. That may be easier than having both the student guide and the <span class="snap">snap</span> page open on their machine. For the rest of the problems on the page, <em>avoid</em> demonstrating. Students will learn most by puzzling them out. Take-It-Further challenge B is especially worthwhile for students who have the time.</li>
					</ul>
				</li>
				<li>
					<strong>Page 3: Using Lists to Write <code>Vowel?</code></strong>
					<ul>
						<li>This page previews lists, giving students a first experience using lists and list blocks in a simple context in their <code>vowel?</code> block and to test their <code>join "a" or "an" with</code> block. Students do not need to master lists or list blocks at this time. They will be covered in much greater depth in Unit 3.</li>
					</ul>
				</li>
				<li>
					<strong>Page 4: Using Multiple <code>If</code> Statements.</strong>
					<ul>
						<li>If time is short, have students do only the first three problems on this page. There will be other opportunities to learn what they may skip here.</li>
					</ul>
				</li>
				<li>
					<strong>Page 5: Developing a Block That Makes Plurals.</strong>
					<ul>
                        <li>Students, even in high school, may have questions about what <em>is</em> the correct plural or correct way to spell it. Encourage them to  check with each other, but also feel free to ask you. Nobody can possibly think of all possible words anyway, so let students know that it is equally okay to ignore words that they're not yet sure about. One side-benefit of this project is that it helps students notice how much they <em>do</em> know and take for granted, and how much work it is for a computer to do what humans do naturally! <em>Students may do this kind of activity in another language if they like. The Take It Further on page 4 suggests one such investigation. </em></li>
					</ul>
				</li>
				<li>
					<strong>Page 6: Plurals, Continued.</strong>
					<ul>
<li>
                            The following rule summaries are for <em>your</em> benefit. Don't teach them to students. The point is not for them to know the rules in advance but to discover them the way computational linguists do, by making a model, seeing if it works, and fixing it if it does not. You can contribute by debugging a specialist block they think they've finished by proposing a word that it might get wrong.
                            <ul>
                          <li><code>plural-h</code> needs to recognize words that end with <em>ch</em> and <em>sh</em> so that it can <code>join</code> <em>es</em> to those. To all other word (for example, ones that end with <em>th</em>), we just <code>join</code> <em>s</em>. To do this, <code>plural-h</code> must look at the next-to-last letter of the word. </li>
                                <li><code>plural-y</code> also needs to look at the next-to-last letter, in this case to see if it is a vowel. To words like <em>day</em> and <em>boy</em> with vowels before the <em>y</em>, we just <code>join</code> <em>s</em>. For the others, like <em>spy</em> and <em>fly</em>, we "change" the last letter (<em>y</em>) to <em>i</em> (by removing the <em>y</em> and using <code>join</code> to replace it with an <em>i</em>) and then <code>join</code> <em>es</em>. </li>
                            </ul>
                        </li>
                        <li>The Take It Further contains more experience with lists and a wonderful surprise that foreshadows a powerful programming technique students will learn in unit 6. All Take It Furthers are optional but this one is especially worthwhile and not difficult. If there is time, encourage students to do all of them, and especially the last two (labeled "Surprise!").</li>
                    </ul>
				</li>
            </ul>
        </div>

<!--        
        <h3>As a Class:</h3>
        <div><ul>
          <li><strong>Launching the first day&mdash;</strong><strong>Analyze a task</strong>: Project this animated image
            <p><img src="/bjc-r/img/2-conditionals-abstraction-testing/Writing-Mouse-on-the-stage.gif" alt="using the mouse to write "mouse" on the stage"></p>
                <p>and ask students to describe the behavior they are seeing.</p>
                <p>You can expect that initial contributions will be fairly general&mdash;"The computer is writing the word 'mouse'" or even "It's writing in two colors." It's <em>sensible</em>  to start with the global behavior. Continue asking for contributions, that add more precision or detail: "It looks like  the writing changes to red when it gets to the top half of the screen" or "the sprite <em>and</em> the mouse are moving together" or.... </p>
      <p>Observations like these help the student recognize what features might be needed in a <em>program</em> that can create this behavior.</p></li>
          <li>Elsewhere, except where you may choose to have a "Computing in the News" discussion or have students share techniques they used or particularly interesting results they got, this lab can productively be  all pair-programming work.</li>
        </ul>
    </div>


        <h3>Look For:</h3>
        <div><ul>
          <li>Always look for pairs in which students are not getting the help that they need from their partner.</li>
          <li>Look for students who elaborate the tasks, or creatively produce new tasks or have other ideas worth sharing with the class.</li>
        </ul>
    </div>

            
   <h3>Solutions</h3>
        <div><ul><li>...</li></ul></div>  -->
            
            
        <div class="apStandards">
            <!--<h4>AP CS Principles Computational Thinking Practices:</h4>
            <ul>
                <li>Coming soon...</li>
            </ul>-->
            <h4>Enduring Understandings:</h4>
            <ul>
                <li><strong>EU 4.1</strong> Algorithms are precise sequences of instructions for processes that can be executed by a computer and are implemented using programming languages.</li>
                <li><strong>EU 5.1</strong> Programs can be developed for creative expression, to satisfy personal curiosity, to create new knowledge, or to solve problems (to help people, organizations, or society).</li>
                <li><strong>EU 5.2</strong> People write programs to execute algorithms.</li>
                <li><strong>EU 5.3</strong> Programming is facilitated by appropriate abstractions.</li>
            </ul>
            <h4>Learning Objectives:</h4>
            <ul>
                <li><strong>LO 2.2.1</strong> Develop an abstraction when writing a program or creating other computational artifacts. [P2]</li>
                <li><strong>LO 4.1.1</strong> Develop an algorithm for implementation in a program. [P2]</li>
                <div class="comment">(only the LO, but no specific EK): <strong>LO 4.2.1</strong> Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]</div>
                <li><strong>LO 5.1.2</strong> Develop a correct program to solve problems. [P2]</li>
                <li><strong>LO 5.1.3</strong> Collaborate to develop a program. [P6]</li>
                <li><strong>LO 5.3.1</strong> Use abstraction to manage complexity in programs. [P3]</li>
                <li><strong>LO 5.4.1</strong> Evaluate the correctness of a program. [P4]</li>
            </ul>
            <h4>Essential Knowledge:</h4>
            <ul>
                <li><strong>EK 2.2.1A</strong> The process of developing an abstraction involves removing detail and generalizing functionality.</li>
                <li><strong>EK 2.2.1B</strong> An abstraction extracts common features from specific examples in order to generalize concepts.</li>
                <li><strong>EK 2.2.2A</strong> Software is developed using multiple levels of abstractions, such as constants, expressions, statements, procedures, and libraries.</li>
                <li><strong>EK 2.2.2B</strong> Being aware of and using multiple levels of abstraction in developing programs helps to more effectively apply available resources and tools to solve problems.</li>
                <li><strong>EK 4.1.1A</strong> Sequencing, selection, and iteration are building blocks of algorithms.</li>
                <li><strong>EK 4.1.1B</strong> Sequencing is the application of each step of an algorithm in the order in which the statements are given.</li>
                <li><strong>EK 4.1.1C</strong> Selection uses a Boolean condition to determine which of two parts of an algorithm is used.</li>
                <li><strong>EK 4.1.1D</strong> Iteration is the repetition of part of an algorithm until a condition is met or for a specified number of times.</li>
                <li><strong>EK 4.1.1E</strong> Algorithms can be combined to make new algorithms.</li>
                <li><strong>EK 4.1.1F</strong> Using existing correct algorithms as building blocks for constructing a new algorithm helps ensure the new algorithm is correct.</li>
                <li><strong>EK 4.1.1H</strong> Different algorithms can be developed to solve the same problem.</li>
                <li><strong>EK 4.1.1I</strong> Developing a new algorithm to solve a problem can yield insight into the problem.</li>
                <li><strong>EK 5.1.2A</strong> An iterative process of program development helps in developing a correct program to solve problems.</li>
                <li><strong>EK 5.1.2B</strong> Developing correct program components and then combining them helps in creating correct programs.</li>
                <li><strong>EK 5.1.2C</strong> Incrementally adding tested program segments to correct working programs helps create large correct programs.</li>
                <li><strong>EK 5.1.3D</strong> Collaboration can make it easier to find and correct errors when developing programs.</li>
                <li><strong>EK 5.1.3E</strong> Collaboration facilitates developing program components independently.</li>
                <li><strong>EK 5.3.1A</strong> Procedures are reusable programming abstractions.</li>
                <li><strong>EK 5.3.1B</strong> A procedure is a named grouping of programming instructions.</li>
                <li><strong>EK 5.3.1C</strong> Procedures reduce the complexity of writing and maintaining programs.</li>
                <li><strong>EK 5.3.1D</strong> Procedures have names and may have parameters and return values.</li>
                <li><strong>EK 5.4.1C</strong> Meaningful names for variables and procedures help people better understand programs.</li>
                <li><strong>EK 5.4.1F</strong> Knowledge of what a program is supposed to do is required in order to find most program errors.</li>
            </ul>
        </div>            


	</body>
</html>
