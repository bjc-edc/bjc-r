<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <script src="https://www.w3schools.com/lib/w3.js"></script>
		<title>Unit 3 Lab 1 Teacher Guide</title>
	</head>

	<body>
		<h2>Lab 1: Dealing with Complexity</h2>
		<p>
            This first lab includes four projects in its six pages. Pages 2 and 3 are a single project, and page 6 brings together ideas about debugging some of which were introduced earlier in the course; it isn't a project at all. What the four projects have in common is that they introduce different ways of thinking about more complex programming problems than students have seen so far:		
            <ul>
                <li>p. 1 (Maze): planning an algorithm without actually programming it.</li>
                <li>pp. 2-3 (Fractal Art): using <em>recursion</em> to get complex results from simple code.</li>
                <li>p. 4 (Brick Wall): multiple levels of abstraction.</li>
                <li>p. 5 (TTT Board): multiprocessing via cloned sprites.</li>
            </ul>
        </p>
		<p>The later programming labs in this unit focus on lists for data abstraction.</p>

		<h3>Pacing</h3>
		<div>
			The 6 lab pages could be split across 3&ndash;5 days (<strong>110&ndash;220 minutes</strong>). Expected times to complete follow:
			<ul>
				<li>25&ndash;50 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/3-lists/1-abstraction/1-robot-in-a-maze.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment" title="Page 1: Robot in a Maze">Robot in a Maze</a></li>
				<li>15&ndash;30 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/3-lists/1-abstraction/2-fractal-art.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment" title="Page 2: Fractal Art">Fractal Art</a></li>
				<li>10&ndash;20 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/3-lists/1-abstraction/3-fractal-art-recursive.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment" title="Page 3: Using Abstraction to Nest Triangles">Using Abstraction to Nest Triangles</a></li>
				<li>20&ndash;40 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/3-lists/1-abstraction/4-brick-wall.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment" title="Page 4: Brick Wall">Brick Wall</a></li>
				<li>30&ndash;60 minutes (about 1 class period) on <a href="/bjc-r/cur/programming/3-lists/1-abstraction/5-building-tic-tac-toe.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment" title="Page 5: Building a Tic-Tac-Toe Board">Building a Tic-Tac-Toe Board</a></li>
				<li>10&ndash;20 minutes (&lt;1 class period) on <a href="/bjc-r/cur/programming/3-lists/1-abstraction/6-debugging-recap.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment" title="Page 6: Debugging Recap">Debugging Recap</a></li>
			</ul>
		</div>
        		        
        <h3>Lab Pages</h3>
		<div>
			<ul>
				<li>
					<strong>Page 1: Robot in a Maze.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
                                <li>Gain experience with a type of question (robot movement) that often appears  in  AP CSP exams.</li>
                              <li>Satisfy AP CSP Framework items requiring students to develop algorithms without coding them. Following a maze is a nontrivial problem.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                                <li>The AP CSP Framework talks in several places about <em>sequence</em>, <em>selection</em>, and <em>repetition</em> as the building blocks of an algorithm. This triad of building blocks comes from a piece of theoretical computer science called the Structured Program Theorem <a href="https://en.wikipedia.org/wiki/Structured_program_theorem" target="_blank">(Wikipedia)</a>, which proves that any algorithm can be expressed using those building blocks. The historical importance of this theorem was that at the time (1966) most programming included &quot;go to&quot; statements that would jump into the middle of loops, or just anywhere, resulting in &quot;spaghetti code&quot; that was hard to debug. But the theorem was a theoretical minimum structure, like a Turing Machine, not meant as a practical programming discipline. Instead, the Structured Programming discipline based on it includes a fourth, extremely important control structure: the <em>procedure call.</em> As you know, this is the basis of most forms of <em>abstraction,</em> the most central idea in computer science. Indeed, a different minimum structure theorem, due to Alonzo Church, proved (decades earlier) that any algorithm can be encoded in <em>Lambda Calculus, </em>using nothing but the ability to <em>create</em> a procedure  and the ability to <em>call</em> a procedure. You don't even need any naming mechanism (such as assignment to variables) other than procedure inputs. Nobody really programs in such a stripped-down language (you don't even get arithmetic!), but it's useful for proving theorems about what computers can and can't do. Since modern programming languages don't even <em>have</em> a &quot;go to&quot; statement, the CSP Framework is fighting a battle that was over 50 years ago. Nevertheless, we humor them, but we also try to teach students that procedures are at least as important as the other three.</li>
                                <li>&quot;Follow the left wall&quot; seems to fail in the maze on this page, because it gets you back to the starting point. But <em>keep going,</em> still touching the left wall, and it will eventually get you to the exit.</li>
							</ul>
						</li>
					</ul>
				</li>
                <li>
                    <strong>Page 2: Fractal Art.</strong>
                    <ul>
                        <li>
                            <strong>Learning Goals:</strong>
                            <ul>
                                <li>Understand the result of nested repeat blocks.</li>
                                <li>Read a program and predict the result of running it.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Tips:</strong>
                            <ul>
                                <li>On this page we tell students to duplicate (copy and paste) a block of code, so that they can insert the copy into the original.  Students who are on the ball may remember that back on 
                                <a href="/bjc-r/cur/programming/1-introduction/2-gossip-and-greet/2-gossip.html">U1L2p2</a> we told them not to copy and paste code, but instead to put the code in a custom block, and call that block in both places. If so, congratulate them on paying attention, and tell them that we're going to fix the problem on the next page.</li>
                                <li>If students wonder about the 120Â° turn in the triangle, have them review <a href="/bjc-r/cur/programming/1-introduction/3-drawing/1-exploring-motion.html">U1L3</a> on drawing polygons.</li>
                            </ul>
						</li>
					</ul>
				</li>
                <li>
                    <strong>Page 3: Using Abstraction to Nest Triangles.</strong>
                    <ul>
                        <li>
                            <strong>Learning Goals:</strong>
                            <ul>
                                <li>Explore <em>recursion</em>, one of the greatest ideas in computer science.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Tips:</strong>
                            <ul>
                                <li>
                                    <strong>Mathematics Note: Preview of recursion.</strong> The figures in the animation at the top of the page  seem quite complicated. But they can be generated by a programming style that previews a technique that will be developed in more depth in Unit 6. To get a feel for what's going on, start with a script that draws a triangle:<br />
                                    <img class="indent" src="/bjc-r/img/1-introduction/triangle-script.png" alt="repeat (3) {move (50) steps; turn right (120) degrees}" title="repeat (5) {move (50) steps; turn right (120) degrees}" />
                                    <img class="indent noshadow" src="/bjc-r/img/1-introduction/triangle.png" alt="sprite drawing a triangle" title="sprite drawing a triangle" /><br />
                                    Now make it take a break at each vertex and do something simple, like play a note:<br />
                                    <img class="indent" src="/bjc-r/img/1-introduction/triangle-sound-script.png" alt="repeat (3) {move (100) steps; play note (60) for (0.5) beats; turn clockwise (120) degrees}" title="repeat (3) {move (100) steps; play note (60) for (0.5) beats; turn clockwise (120) degrees}" /><br />
                                    Instead of making it play a note, have it draw a smaller triangle:<br />
                                    <img class="indent" src="/bjc-r/img/1-introduction/triangle-nested-script.png" alt="repeat (3) {move (100) steps; repeat (3) {move (50) steps; turn right (120) degrees}; turn right (120) degrees}" title="repeat (3) {move (100) steps; repeat (3) {move (50) steps; turn right (120) degrees}; turn right (120) degrees}" />
                                    <img class="indent noshadow" src="/bjc-r/img/1-introduction/triangle-nested.png" alt="sprite drawing a red triangle with a smaller nested triangle at each vertex" title="sprite drawing a red triangle with a smaller nested triangle at each vertex" /><br />
                                    Now you can get as intricate as you want by inserting ever-smaller triangles between each <code>move</code> and <code>turn</code>.
                                </li>
                                <li><em>Recursion</em> is one the most profound (and potentially difficult) concepts in all of computer science due to its <em>self-referential</em> nature.  Your kids (and you) will succeed now, but comfort and mastery can take a long time. This is just an appetizer; with more experience later this year, the purpose and enormous value of recursion will become more apparent.</li>  
                                <li>
                                    If you had exposure to recursion before, you may be wondering where in our code  we are dealing with the "base case" that terminates the iterative process.  A little reflection will show that the condition that terminates the recursion is the <code>if (size &gt; 9)</code> block and the implicit "base case" is: <code>if size &le; 9</code> then stop drawing.<br />
                                    <img class="indent" src="/bjc-r/img/3-lists/nested-triangle-9.png"  alt="nested triangle, size:(size){if((size)&gt;(9)){repeat(3){move(size) steps; nested triangle, size:((size)/2); turn clockwise(120) degrees}}}" title="nested triangle, size:(size){if((size)>(9)){repeat(3){move(size) steps; nested triangle, size:((size)/2); turn clockwise(120) degrees}}}" />
                                </li>                                
                            </ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 4: Brick Wall.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
								<li>Get more experience with abstraction in the context of developing blocks that specialize on specific tasks.</li>
                                <li>Use abstraction to create a somewhat complex program built on relatively simple custom blocks.</li>
                                <li>Learn the programming strategy of getting individual aspects working completely instead of trying to build all aspects simultaneously.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                                <li>Note three levels of procedural abstraction: a <em>wall</em> is made of <em>rows,</em> which are made of <em>bricks,</em> which are made out of primitive <code>move</code> blocks.</li>
                                <li>Most students will find it easier to develop the <code>draw row A</code> block than the <code>draw row B</code> block due to its two smaller bricks.  Getting the two rows to span the same length will require some trial and error.</li>
                                <li>The <code>draw brick wall</code> block definition must identify whether an even or an odd numbered row is being built. One way to do that is to call <code>odd?</code> on the row number for each row. Another way is to make height/2 repetitions of a <code>draw row A</code> and a <code>draw row B</code>, then see if the total height is even or odd to decide whether or not to draw a final <code>draw row A</code>.</li>
                                <li>Think about what helper blocks besides <img src="/bjc-r/img/abstraction/new-brickwall/draw-brick.png" alt="Draw Brick" title="Draw Brick"/> you might want.</li>
                                <li>Ten minutes before the end of class, make sure that students  discuss the question: "How do you think procedural abstraction manages the complexity of a program?" Take reports from several groups and collectively converge on a single explanation.</li>
                                <div class="takeNote"> 
                                    <p><strong>Too much abstraction? </strong>It's possible to go overboard on abstraction and build so many blocks that your program is just as cluttered as it would be without the special blocks. </p>
                                    <p>But it can also be useful to make a special block even when its definition is just one built-in block. For example, to draw the mortar (the cement between bricks, shown  as white space), you can just use <code>move (4) steps</code>, but it might make sense to define a <code>draw mortar</code> block. </p>
                                    <p>Why? You might later decide that 4 steps is the wrong thickness for mortar, and you'd rather have 5. Or you might want the mortar to be cement-colored, slightly gray. With many <code>move</code> blocks scattered through your program, you would have to find and change each one, and keep putting in <code>set pen color</code> blocks. With a <code>draw mortar</code> block, you can just change its definition and all the mortar in your picture will be changed.</p>
                                </div>
							</ul>
						</li>
					</ul>
				</li>
                <li>
					<strong>Page 5: Building a Tic-Tac-Toe Board.</strong>
                    <ul>

						<li>
							<strong>Learning Goals:</strong>
							<ul>
							  <li>Appreciate the important CS concept of <em>parallelism</em>&mdash;the fact that multiple processes can be running at the same time (in this case, multiple sprites remaining simultaneously &quot;aware&quot; and waiting for a click).</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                        		<li>Later when students extend Tic-Tac-Toe to check for legal moves, to check for wins, and ultimately to <!-- develop the Artificial Intelligence (AI) to--> have the machine play competently, the machine will need to keep a record of each move. The approach in previous years to Tic-Tac-Toe required the programmer to design a way to sense where on the screen a player moved; in this alternative version, the squares of the Tic-Tac-Toe board are <strong><em>click-conscious </em></strong> sprites, thus eliminating the need for the programmer to compute the board cell numbers from the coordinates of the mouse click.  This approach takes advantage of a capability of Snap<em>!</em> that is not in all programming languages&mdash;clones&mdash;a sophisticated and valuable abstraction that  simplifies the programmer's task in languages that provide it.</li>
                                <li>
                                    This project hints at two important modern ideas in computer science:
                                    <ul>
                                    	<li>One is <strong>object oriented programming</strong>: Instead of a single sequence of instructions, the program has several <em>independent</em> objects (also called "agents" or "actors"), each of which has its own behavior.  In this project, the player can only click on one sprite at a time, and it then carries out a very quick task (changing costume) before the player clicks another sprite.  But a more complicated program might have one sprite send a <em>message</em> to another sprite, which would respond with its own behavior, while the first sprite continues with its own script.</li>
                                        <li>The other idea is <strong>parallelism</strong> or <strong>distributed computing</strong>. This project runs on a single computer, and the apparent ability of sprites to run simultaneously is an illusion provided by Snap<em>!</em>, which runs one script for a little while, then switches to a different script, and so on, then updates the display, then continues the first script. But it's possible to use nine separate computers, one for each sprite. That would be overkill for this small project, but large web servers such as Google or Twitter have many thousands of computers all cooperating to handle the large amounts of data they require.</li>
                                    </ul>
                                </li>
							</ul>
						</li>
                    </ul>
                </li>
				<li>
					<strong>Page 6: Debugging Recap.</strong>
                    <ul>

						<li>
							<strong>Learning Goals:</strong>
							<ul>
                       			<li>Review previously learned strategies for debugging and preventing bugs.</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                        		<li>Some of these suggestions and strategies might make for a nice classroom poster.</li>
							</ul>
						</li>
                    </ul>
                </li>
                
	        </ul>
        </div>


		<!--<h3>Assignments:</h3>
		<div>
			<ul>
				<li>...</li>
			</ul>
		</div>-->

			
		<h3>BJC Videos from UC Berkeley</h3>
        <div class="sidenoteBig">
            <strong>No YouTube access at your school?</strong><br />
            <ul>
				<li><a href="http://scratch.mit.edu/discuss/youtube/E-UMuAB0JOo" target="_blank">Abstraction: Abstraction &amp; Detail Removal</a></li>
				<li><a href="http://scratch.mit.edu/discuss/youtube/97jcSsTUtzY" target="_blank">Abstraction: Generalization</a></li>
				<li><a href="http://scratch.mit.edu/discuss/youtube/MIva9WH-kuU" target="_blank">Abstraction: Abstraction Interfaces and Summary</a></li>
				<li><a href="http://scratch.mit.edu/discuss/youtube/btVdslI-L9M" target="_blank">Abstraction: Power, Limitations</a></li>
			</ul>
        </div>
        <div>
        	<ul>
                <li><a href="https://www.youtube.com/watch?v=E-UMuAB0JOo&list=PLno6_GYnQv_Shd5NHuuYRO0GIxIgft2DM&index=3&noredirect=1" target="_blank" title="edX Video- Abstraction: Abstraction &amp; Detail Removal">Abstraction: Abstraction &amp; Detail Removal</a></li>
                <li><a href="https://www.youtube.com/watch?v=97jcSsTUtzY&list=PLno6_GYnQv_Shd5NHuuYRO0GIxIgft2DM&index=4" target="_blank" title="edX Video- Abstraction: Generalization">Abstraction: Generalization</a></li>
                <li><a href="https://www.youtube.com/watch?v=MIva9WH-kuU&list=PLno6_GYnQv_Shd5NHuuYRO0GIxIgft2DM&index=5" target="_blank" title="edX Video- Abstraction: Abstraction Interfaces and Summary">Abstraction: Abstraction Interfaces and Summary </a></li>
                <li><a href="https://www.youtube.com/watch?v=btVdslI-L9M&list=PLno6_GYnQv_Shd5NHuuYRO0GIxIgft2DM&index=12" target="_blank" title="edX Video- Abstraction: Power, Limitations">Abstraction: Power, Limitations</a></li>
            </ul>
        </div>

		<h3>Solutions</h3>
        <div w3-include-html="/bjc-r/utilities/includes/3-solutions.txt"></div><script>w3.includeHTML();</script>
   		
			
		<h3>Correlation with 2020 AP CS Principles Framework<a name="AP" class="anchor">&nbsp;</a></h3>
        <div class="apStandards">
            <h4>Computational Thinking Practices: Skills</h4>
            <ul>
                <li><strong>2.A:</strong> Represent algorithmic processes without using a programming language.</li>
                <li><strong>3.B:</strong> Use abstraction to manage complexity in a program.</li>
                <li><strong>3.C:</strong> Explain how abstraction manages complexity.</li>
            </ul>
            <h4>Learning Objectives:</h4>
            <ul>
                <li><strong>AAP-2.A:</strong> Express an algorithm that uses sequencing without using a programming language. (2.A)</li>
                <li><strong>AAP-2.G:</strong> Express an algorithm that uses selection without using a programming language. (2.A)</li>
                <li><strong>AAP-2.J:</strong> Express an algorithm that uses iteration without using a programming language. (2.A)</li>
                <li><strong>AAP-3.B:</strong> Explain how the use of procedural abstraction manages complexity in a program. (3.C)</li>
                <li><strong>AAP-3.C:</strong> Develop procedural abstractions to manage complexity in a program by writing procedures. (3.B)</li>
            </ul>
            <h4>Essential Knowledge:</h4>
            <ul>
                <li><strong>AAP-1.A.2:</strong> Using meaningful variable names helps with the readability of program code and understanding of what values are represented by the variables.</li>
                <li><strong>AAP-2.B.7:</strong> Clarity and readability are important considerations when expressing an algorithm in a programming language.</li>
                <li>
                    <strong>AAP-2.M.2:</strong> Knowledge of existing algorithms can help in constructing new ones. Some existing algorithms include:
                    <ul>
                        <li>determining a robot's path through a maze</li>
                    </ul>
                </li>
                <li><strong>AAP-3.B.1:</strong> One common type of abstraction is procedural abstraction, which provides a name for a process and allows a procedure to be used only knowing what it does, not how it does it. </li>
                <li><strong>AAP-3.B.5:</strong> Using parameters allows procedures to be generalized, enabling the procedures to be reused with a range of input values or arguments. </li>
            </ul>
        </div>
        

    </body>
</html>